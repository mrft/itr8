/**
 * The interface/general module contains helper functions to interface from or to
 * simple data representations like arrays, objecs, Sets, Maps, strings, ...
 * but it also contains a few 'generators' that produce an iterator based onsome
 * input parameters (like itr8Range and itr8Interval).
 *
 * @module
 */

import { forEach } from "..";
import { TPipeable, TPushable } from "../types";
import { itr8Pipe } from '../util';

import { takeWhile } from "../operators/general/takeWhile";
import { isPromise } from "util/types";


// function itr8PipeArray(
//   params:Array<(any) => any>
// ):any {
//   return params.reduce<(any) => any>(
//     (acc, cur) => {
//       return (arg) => cur(acc(arg))
//     },
//     (x) => x,
//   );
// }

/**
 * This will wrap the sync or async iterator and adds:
 *  * a pipe(operator) function to allow for easy composition of transIt operators
 *    to an iterable
 *
 * We often need to read backwards (first filter, then map) due to the current lack of
 * a |> operator in Javascript/Typescript.
 * ```typescript
 *    map(mapFn)(
 *      filter(filterFn)(
 *        iterator
 *      )
 *    )
 * ```
 * but due to the pipe function this would become
 * ```typescript
 *    itr8FromIterator(iterator)
 *      .pipe(filter(filterFn))
 *      .pipe(map(mapFn))
 * ```
 * which is closer to the even more readable (future?) syntax:
 * ```typescript
 *    iterator
 *      |> filter(filterFn)`
 *      |> map(mapFn)
 * ```
 *
 * @param iterator
 * @returns an iterator augmented with a useful pipe function
 *
 * @category utils
 */
function itr8FromIterator<PTIterator extends IterableIterator<any> | AsyncIterableIterator<any>>
 (iterator:PTIterator):TPipeable & PTIterator {
 // new Proxy(iterator, itr8FromIteratorHandler);
 // const origNext = iterator.next;
 // iterator.next = () => {
 //   // console.log('next has been called on the iterator');
 //   const nextVal = origNext.apply(iterator) // origNext();
 //   // console.log(`next has been called on the iterator and it wil return ${JSON.stringify(nextVal)}`);
 //   if (nextVal.hasOwnProperty('done')) {
 //     // synchronous
 //   }
 //   return nextVal;
 // }

 // for . chaining (but then you'd need to know all possible operators up front)
 // for (let x of Object.keys(TransIt)) {
 //   // console.log(`Adding ${x} to iterator object`)
 //   iterator[x] = TransIt[x](iterator);
 // }
 const retVal = (iterator as TPipeable & PTIterator);
 // retVal.pipe = (transIt:TTransIteratorSyncOrAsync, ...moreTransits:Array<TTransIteratorSyncOrAsync>) => {
 //   return itr8FromIterator(itr8Pipe(transIt, ...moreTransits)(iterator));
 // }
 retVal.pipe = <A=any,B=any>(
   fn1:((a:TPipeable & (IterableIterator<A> | AsyncIterableIterator<A>)) => B),
   ...moreFns:Array<(any) => any>
 ) => {
   return itr8Pipe(fn1, ...moreFns)(iterator);
 }
 return retVal;
}


/**
 * When you want to process the same iterator mutltiple times in different ways
 * (you can think of it as 'splitting the stream'),
 * it would be cool to have a way to 'subscribe' many times to the same iterator.
 * An IterableIterator returns an iterator, but that will always return the current iterator,
 * and not a new one.
 *
 * This function produces an Iterable that returns a new iterator each time [Symbol.asyncIterator]()
 * gets called, so one needs to call next on all output iterators separately to get the next element
 * of the input iterator.
 *
 * This method creates a function that turns the iterator into an Iterable that returns
 * a new iterator on calling [Symbol.asynIterator] that starts from the current element
 * (or the oldest element any of the subscribers is at?) that we are at in the source iterator.
 *
 * In order to support the fact that not all output iterators will be pulled at the same time,
 * we need to keep a cache + the position that each iterator is at.
 *
 * TODO: In order to protect ourselves from 'abandoned' iterators, a timeout could be used
 * to clean them up, so the cache can be emptied up to the oldest 'active' iterator.
 *
 * @category iterator_converters
 */
function itr8ToMultiIterable<T>(/* abandonedTimeoutMilliseconds = Infinity */)
  : (it: Iterator<T> | AsyncIterator<T>) => AsyncIterable<T> {
  return (it: Iterator<T> | AsyncIterator<T>) => {
    const subscriberMap: Map<AsyncIterableIterator<T>, number> = new Map();
    const buffer: Map<number, IteratorResult<T> | Promise<IteratorResult<T>>> = new Map();

    const retVal: AsyncIterable<T> = {
      [Symbol.asyncIterator]: () => {
        const outIt: AsyncIterableIterator<T> = {
          [Symbol.asyncIterator]: () => outIt,
          next: async () => {
            const index = subscriberMap.get(outIt) as number;
            if (!buffer.has(index)) {
              buffer.set(index, it.next());
            }
            // remove old stuff in buffer
            const minIndex = Math.min(...subscriberMap.values());
            itr8FromIterable(buffer.keys()).pipe(
              takeWhile((i) => i < minIndex), // Maps are iterated in insertion order !
              forEach((i) => {
                buffer.delete(i);
              }),
            );
            // for (const b of buffer.keys()) {
            //   if (i < minIndex) {}
            // }
            subscriberMap.set(outIt, index + 1);
            return buffer.get(index) as Promise<IteratorResult<T>>;
          },
        };

        // add the new iterator to the subscriberMap
        subscriberMap.set(outIt, buffer.size === 0 ? 0 : Math.min(...buffer.keys()));
        // TODO: set a disconnect timeout (we'll need to store the last get time, or the timeout id)
        return itr8FromIterator(outIt) as AsyncIterator<T>;
      }
    };
    // subscriberMap.set(outIt, buffer.size > 0 ? buffer.values.next().value : 0);
    return retVal as AsyncIterableIterator<T>;
  };
}

/**
 * Gets a wrapped instance of the iterator OR the async iterator from any iterable (including arrays)
 * so that we can easily pipe it into the operators.
 *
 * @example
 * ```typescript
 * itr8FromIterable([1,2,3])
 *  .pipe(
 *    map((x) => x + 100),
 *  )
 * ```
 *
 * @category iterator_factories
 */
 function itr8FromIterable<T>(it:Iterable<T> | AsyncIterable<T>):TPipeable & (IterableIterator<T> | AsyncIterableIterator<T>) {
  if (it[Symbol.iterator]) {
    return itr8FromIterator(it[Symbol.iterator]());
  } else {
    return itr8FromIterator(it[Symbol.asyncIterator]());
  }
}

/**
 * Turns an array into an Iterator
 * (itr8FromIterable is more generic, this one is mainly useful for writing tests together
 * with its async brother itr8FromArrayAsync).
 *
 * @param a an array
 * @returns an iterator
 *
 * @category iterator_factories
 */
function itr8FromArray<T>(a: Array<T>): TPipeable & IterableIterator<T> {
  return itr8FromIterator(
    a[Symbol.iterator]()
  );
}

/**
 * Turns an array into an (async) Iterator. Mainly useful for testing.
 *
 * @param a an array
 * @returns an async iterator
 *
 * @category iterator_factories
 */
function itr8FromArrayAsync<T>(a: Array<T>): TPipeable & AsyncIterableIterator<T> {
  return itr8FromIterator(
    (async function*() { for (const x of a) { yield x; } })()
  );
}

/**
 * Turns a string into an Iterator that outputs every character of the string separately.
 * 
 * (but since a string is an Iterable, you can use itr8FromIterable on strings as well!)
 *
 * @param s string
 * @returns an iterator
 *
 * @category iterator_factories
 */
function itr8FromString(s: string): TPipeable & IterableIterator<string> {
  return itr8FromIterable(s) as TPipeable & IterableIterator<string>;
}


/**
 * Turns a string into an (async) Iterator that outputs every character of
 * the string separately.
 *
 * @param s a string
 * @returns an iterator
 *
 * @category iterator_factories
 */
function itr8FromStringAsync(s: string): TPipeable & AsyncIterableIterator<string> {
  return itr8FromIterator(
    (async function* () { for (const x of s) { yield x; } })()
  );
}


/**
 * Turns a single value into an Iterator that will produce 1 result.
 * Should work for boolean, number, string, object, ...
 *
 * @param a anything like object, string, number, ...
 * @returns an iterator
 *
 * @category iterator_factories
 */
function itr8FromSingleValue<T>(v: any): TPipeable & IterableIterator<T> {
  return itr8FromIterator(
    (function* () { yield v; })()
  );
}

/**
 * Turns a single value into an (async) Iterator that will produce 1 result.
 * Should work for boolean, number, string, object, ...
 *
 * @param a anything like object, string, number, ...
 * @returns an iterator
 *
 * @category iterator_factories
 */
function itr8FromSingleValueAsync<T>(v: any): TPipeable & AsyncIterableIterator<T> {
  return itr8FromIterator(
    (async function* () { yield v; })()
  );
}


/**
 * Creates an AsyncIterableIterator, that also exposes
 * * a push(...) method that can be used to push values into it (for example based on events).
 * * a done() method that can be used to indicate that no more values will follow.
 *
 * The optional bufferSize parameter defines how large the buffer is that will hold the
 * messages until they are pulled by a next() call. The oldest messages will be
 * dropped if no one is consuming the iterator fast enough.
 *
 * If no bufferSize is specified, the buffer will keep growing indefinitely.
 *
 * @param observable
 * @returns
 *
 * @category iterator_factories
 */
function itr8Pushable<T>(bufferSize?:number):TPipeable & AsyncIterableIterator<T> & TPushable {
  const buffer:any[] = [];

  let currentResolve;
  // let currentReject;
  let currentDataPromise;
  // let done = false;

  const createNewCurrentDataPromise = () => {
    currentDataPromise = new Promise((resolve /*, reject */) => {
      currentResolve = resolve;
      // currentReject = reject;
    });
    buffer.push(currentDataPromise);
    while (bufferSize !== undefined && buffer.length > bufferSize + 1) {
        // remove the oldest one from the buffer
        buffer.shift();
    }
  }

  createNewCurrentDataPromise();

  const retVal = {
    [Symbol.asyncIterator]: () => retVal,
    next: async () => {
      // if (done) {
      //   return { done: true };
      // }
      if (buffer.length > 0) {
        // const [firstOfBufferPromise, ...restOfBuffer] = buffer;
        // buffer = restOfBuffer;
        const firstOfBufferPromise = buffer.shift();
        const asyncNext = await firstOfBufferPromise;
        return asyncNext;
      } else {
        throw new Error('[itr8FromObservable] No elements in the buffer?')
      }
    },
    push: (value:T) => {
      currentResolve({ value });
      createNewCurrentDataPromise();
    },
    done: () => {
      currentResolve({ done: true });
      createNewCurrentDataPromise();
      // done = true;
    },
  };

  return itr8FromIterator(retVal as AsyncIterableIterator<T>) as TPipeable & AsyncIterableIterator<T> & { push:(T) => void, done:() => void };
}

/**
 * Turns an itr8 into an array.
 *
 * It supports 'batched' interators as well, and will output an array of single values
 * (and not an array of arrays).
 *
 * @param iterator
 * @returns an array
 *
 * @category iterator_converters
 */
function itr8ToArray<T>(iterator: Iterator<T> | AsyncIterator<T>): Array<T | any> | Promise<Array<T | any>> {
  const isBatch = iterator['itr8Batch'] === true;
  let n = iterator.next();
  if (isPromise(n)) {
    return (async () => {
      const asyncResult:T[] = [];
      while (!(await n).done) {
        if (isBatch) {
          for (const v of (await n).value as unknown as Iterable<any>) {
            asyncResult.push(v);
          }
        } else {
          asyncResult.push((await n).value);
        }
        n = iterator.next();
      }
      return asyncResult;
    })();
  } else {
    // return Array.from(iterator);
    const result:T[] = [];
    let nSync = (n as IteratorResult<T>);
    while (!nSync.done) {
      if (isBatch) {
        for (const v of nSync.value as unknown as Iterable<any>) {
          result.push(v);
        }
      } else {
        result.push(nSync.value);
      }
      nSync = iterator.next() as IteratorResult<T>;
    }
    return result;
  }
}


/**
 * Utility function that produces an iterator
 * producing integers starting and ending where you want,
 * which is useful for trying out stuff without manually
 * having to create arrays.
 *
 * * 'from' can be higher than 'to', in which case the iterator will count down
 * * 'step' is always a positive number (but we are forgiving if it's not)
 *
 * @param start start index
 * @param end end index
 * @param end step size, default = 1
 *
 * @category iterator_factories
 */
function itr8Range(from: number, to: number, step?:number):TPipeable & IterableIterator<number> {
  const stepValue = step !== undefined ? Math.abs(step) : 1;
  const upwards = from < to;
  return itr8FromIterator(
    (function* () {
      if (upwards) {
        for (let i = from; i <= to; i = i + stepValue) {
          yield i;
        }
      } else {
        for (let i = from; i >= to; i = i - stepValue) {
          yield i;
        }
      }
    })(),
  );
}

/**
 * Utility function that produces an (async) iterator
 * producing integers starting and ending where you want,
 * which is useful for trying out stuff without manually
 * having to create arrays.
 *
 * * 'from' can be higher than 'to', in which case the iterator will count down
 * * 'step' is always a positive number (but we are forgiving if it's not)
 *
 * @param start start index
 * @param end end index
 * @param end step size, default = 1
 *
 * @category iterator_factories
 */
function itr8RangeAsync(from: number, to: number, step?:number):TPipeable & AsyncIterableIterator<number> {
  const stepValue = step !== undefined ? Math.abs(step) : 1;
  const upwards = from < to;
  return itr8FromIterator(
    (async function* () {
      if (upwards) {
        for (let i = from; i <= to; i = i + stepValue) {
          yield i;
        }
      } else {
        for (let i = from; i >= to; i = i - stepValue) {
          yield i;
        }
      }
    })(),
  );
}

/**
 * Returns a (pushable async) iterator that will automatically fire with the Date.now() value
 * of when it fired (= the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC).
 *
 * When you want it to stop, call the done() method of the returned iterator, and the interval
 * will be cleaned up.
 *
 * @param intervalMilliseconds
 * @returns an AsyncIterableIterator
 *
 * @category iterator_factories
 */
function itr8Interval(intervalMilliseconds:number):TPipeable & AsyncIterableIterator<number> & TPushable {
  const it = itr8Pushable<number>(Infinity); // infinite buffer !!!
  const interval = setInterval(() => {
    it.push(Date.now());
  }, intervalMilliseconds);
  const origDone = it.done;
  it.done = () => {
    clearInterval(interval);
    return origDone();
  }
  return it;
}


export {
  itr8FromArray,
  itr8FromArrayAsync,
  itr8FromIterable,
  itr8FromIterator, // used to be called 'itr8FromIterator'
  itr8FromSingleValue,
  itr8FromSingleValueAsync,
  itr8FromString,
  itr8FromStringAsync,
  itr8Interval,
  itr8Pushable,
  itr8Range,
  itr8RangeAsync,
  itr8ToArray,
  itr8ToMultiIterable,
}
