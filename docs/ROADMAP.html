<!DOCTYPE html><html class="default"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>Roadmap | itr8</title><meta name="description" content="Documentation for itr8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script async src="assets/search.js" id="search-script"></script><link rel="stylesheet" href="assets/pages.css"/></head><body><script>document.body.classList.add(localStorage.getItem("tsd-theme") || "os")</script><header><div class="tsd-page-toolbar"><div class="container"><div class="table-wrap"><div class="table-cell" id="tsd-search" data-base="."><div class="field"><label for="tsd-search-field" class="tsd-widget search no-caption">Search</label><input type="text" id="tsd-search-field"/></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">itr8</a></div><div class="table-cell" id="tsd-widgets"><div id="tsd-filter"><a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a><div class="tsd-filter-group"><div class="tsd-select" id="tsd-filter-visibility"><span class="tsd-select-label">All</span><ul class="tsd-select-list"><li data-value="public">Public</li><li data-value="protected">Public/Protected</li><li data-value="private" class="selected">All</li></ul></div> <input type="checkbox" id="tsd-filter-inherited" checked/><label class="tsd-widget" for="tsd-filter-inherited">Inherited</label><input type="checkbox" id="tsd-filter-externals" checked/><label class="tsd-widget" for="tsd-filter-externals">Externals</label></div></div><a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a></div></div></div></div><div class="tsd-page-title"><div class="container"><ul class="tsd-breadcrumb"><li><a href="modules.html">itr8</a></li><li><a href="ROADMAP.html">Roadmap</a></li></ul><h1> Roadmap </h1></div></div></header><div class="container container-main"><div class="row"><div class="col-8 col-content"><div class="tsd-panel tsd-typography">
<a href="#roadmap" id="roadmap" style="color: inherit; text-decoration: none;">
  <h1>ROADMAP</h1>
</a>
<p>This is a bunch of ideas of things to add or change.</p>

<a href="#maybe-we-can-use-asciiflow-to-add-some-schema39s-to-the-documentation" id="maybe-we-can-use-asciiflow-to-add-some-schema39s-to-the-documentation" style="color: inherit; text-decoration: none;">
  <h2>Maybe we can use asciiflow to add some schema&#39;s to the documentation?</h2>
</a>
<p><a href="https://asciiflow.com">https://asciiflow.com</a></p>

<a href="#make-it-usable-both-in-nodejs-and-in-the-browser" id="make-it-usable-both-in-nodejs-and-in-the-browser" style="color: inherit; text-decoration: none;">
  <h2>Make it usable both in NodeJS and in the browser</h2>
</a>
<p>Currently we use modeul: &quot;CommonJS&quot; in tsconfig.json, but ideally it should be ES2015
so that the compiled typescript code can be used unmodified both in NodeJS and in the
browser without forcing users to have build tools like webpack or browserify in between.</p>

<a href="#support-the-39official39-transducertransformer-spec" id="support-the-39official39-transducertransformer-spec" style="color: inherit; text-decoration: none;">
  <h2>Support the &#39;official&#39; transducer/transformer spec?</h2>
</a>
<p>The way transducers have been implemented in Ramda and a few other libraries has always confused
me (as in you really have to dig into it to really understand how they work).</p>
<p>James Long has a great explanation about <strong>separation of concerns</strong> in <a href="https://archive.jlongster.com/Transducers.js--A-JavaScript-Library-for-Transformation-of-Data">his article about Transducers.js</a>.
He argues that <strong>iterate, transform and build</strong> are three separate problems, and that transducers decouple this in such away that the transform can be used on any data structure.
To quote him:</p>
<blockquote>
<p>These are completely separate concerns, and yet most transformations in JavaScript are tightly coupled with specific data structures. Transducers decouples this and you can apply all the available transformations on any data structure.</p>
</blockquote>
<p>Something he also mentions in the final notes of the post that is <a href="https://archive.jlongster.com/Transducers.js--A-JavaScript-Library-for-Transformation-of-Data#Final-Notes">introducing his transducers.js library</a></p>
<blockquote>
<p>Lazy sequences are something I think should be added to transducers.js in the future. (edit: well, this paragraph isn&#39;t exactly true, but we&#39;ll have to explain laziness more in the future)</p>
</blockquote>
<p>I think that itr8 also decouples this, but in a different way: with transducers you&#39;d need to implement another protocol (the most important method being &#39;step&#39;)</p>
<p>The <a href="https://github.com/cognitect-labs/transducers-js#transformer-protocol">transformer protocol</a> requires you to add these methods on any data structure that wants to play along, or to define a transformation:
{
  &#39;@@transducer/init&#39;: () =&gt; &#39;some inital value&#39;;
  &#39;@@transducer/result&#39;: (r) =&gt; r;
  &#39;@@transducer/step&#39;: (acc, cur) =&gt; ...;
}</p>
<p>In itr8, we assume that anything can be made iterable (even push-streams, by buffering). The thing about push-streams is: if a stream is push-based and the receiving end can&#39;t handle the speed, you&#39;d get in trouble eventually, so we can safely assume that any push-based stream, can be buffered and pulled from, because the puller will be fast enough, and the buffer will always be near-empty anyway.</p>
<p>With this assumption in mind, we actually don&#39;t decouple iteration from transformation, but we do decouple iteration from &#39;build&#39;.
First of all: maybe you don&#39;t want to &#39;build something&#39; in the end, but simply perform actions based on each item, and secondly: it feels like everything can easily be made iterable, and I think it&#39;s equally easy to build something from an iterator in most cases. Besides: with transducers it also looks as if you somehow have to make it compatible with some kind of spec to make it iterable, so we might as well agree that that protocol will always be the iterator protocol. The &#39;step&#39; function feels very much like the &#39;next&#39; function of an iterator anyway.</p>
<p>So for me personally, I feel like there is less new things to learn - given you know how the iterator protocol works (it&#39;s simple, well-supported and widely used, so we might as well embrace it).</p>
<p>So instead of trying to be entirely agnostic about the source, I think we end up with something that&#39;s even easier to understand (maybe that&#39;s just me of course) because we assume the source to always be the same thing, an iterator. It gives us one less degree of freedom, which makes for one less thing to explain or worry about in my opinion.</p>
<p>Another post trying to explain transducers: <a href="https://medium.com/@shaadydawood/transducers-functional-transducers-async-transducers-e0ec65964fc2">https://medium.com/@shaadydawood/transducers-functional-transducers-async-transducers-e0ec65964fc2</a>
Check out: <a href="https://www.npmjs.com/package/functional-pipelines">https://www.npmjs.com/package/functional-pipelines</a></p>

<a href="#what-are-the-consequences-for-itr8" id="what-are-the-consequences-for-itr8" style="color: inherit; text-decoration: none;">
  <h3>What are the consequences for itr8?</h3>
</a>
<p>It looks like itr8 has chosen a different path, by composing iterators instead of operators.</p>
<p>Could we think of another protocol that allows us to compose &#39;operators&#39; that looks more like the iterator protocol?
I mean: if the signature would be</p>
<pre><code class="language-typescript"><span class="hl-0">(</span><span class="hl-2">inValue</span><span class="hl-0">:[{ </span><span class="hl-2">done</span><span class="hl-0">: </span><span class="hl-9">boolean</span><span class="hl-0">, </span><span class="hl-2">value</span><span class="hl-0">?: </span><span class="hl-9">any</span><span class="hl-0"> }, </span><span class="hl-9">state</span><span class="hl-0">]) </span><span class="hl-5">=&gt;</span><span class="hl-0"> [{ </span><span class="hl-2">done:</span><span class="hl-0"> </span><span class="hl-2">boolean</span><span class="hl-0">, value?</span><span class="hl-2">:</span><span class="hl-0"> </span><span class="hl-2">any</span><span class="hl-0"> }, </span><span class="hl-2">state</span><span class="hl-0">]</span>
</code></pre>
<p>they could very easily be composed, but unfortunately our output format is more complex
as in: we also allow &#39;iterable&#39;.
Of course we could change that to disallow iterable, and put that responsibility in the hands of
the developer =&gt; he should keep the iterator in the state and return all values as long as there are any?
It could be done, and if we do that, we&#39;d have operators that are as easy to compose as the ones from the transducer protocol, and some people might find that easier to understand than the way transducers are implemented, because both done (or &#39;reduced&#39; in transducer terms) and the value
are returned.
There&#39;s still a problem with &#39;state&#39; being inside the inValue and outValue, because it belongs to a specific operator, so state should be kept &#39;locally&#39; somehow in that case (this.state).</p>

<a href="#some-ideas-to-also-make-our-39transformers39-the-nextfn-we-currently-pass-to-itr8operatorfactory-composable" id="some-ideas-to-also-make-our-39transformers39-the-nextfn-we-currently-pass-to-itr8operatorfactory-composable" style="color: inherit; text-decoration: none;">
  <h3>Some ideas to also make our &#39;transformers&#39; (the nextFn we currently pass to itr8OperatorFactory) composable</h3>
</a>
<p>If we compose the transformations rather than the iterators, we might be able to gain some performance, but I find writing transducers cumbersome, because you have to think about &#39;writing a function that gets another function as input&#39; and how to combine them.
When writing the nextFn for the itr8OperatorFactory, we don&#39;t care about how they will be composed
as that will be done for us, so we only have to think about what an input element produces on the output side, which is quite easy most of the time. Adding that extra complexity of havng to call &quot;the other function&quot; somewhere adds a mental burden that I find too high, which might be part of the reason transducers haven&#39;t really been embraced by the masses.</p>
<p><strong>Why would I try composing the transformers then instead of the iterators?</strong></p>
<p>For performance reasons: once 1 element in the chain is async, every iterator that comes behind it will necessarily become async, causing for a lot of functions being put onto the event loop (This also means that each &#39;transIterator&#39; is running a lot of code to check whether the input iterator is sync or async). I have actually proven (in the &#39;transduce&#39; operator tests) that transducer based version of the same operations (filter, map, repeat, ...) was quite a lot faster (probably because of the single intermediate iterator, and probably also because all the transducers are synchronous, so there are way less isPromise checks, but maybe in general, because the transducers call the next transducer there are less intermediate allocations of new data structures?)
If we combine the transformations into 1 single method, we&#39;d end up with a single &#39;intermediate&#39; iterator that executes a single function - in case  everything is synchronous - for every element in the stream.</p>
<p>So I have been trying to figure out a way to also make our &#39;transformers&#39; composable, without changing how they work. So instead of relying on a theoretical model, I would provide helper functions to make composing possible, while maintaining the easy-to-use interface. So while (or maybe just because) theoretically less advanced than transducers, we might end up with something that is easier to use, which in my view is really important. (if we find a way to compose them, we might also find a way to turn them into actual transformers for a transducer as well, in which case we might also have helped the transducer-loving world forward)</p>
<pre><code class="language-typescript"><span class="hl-4">// Transformer spec defines these methods on an object</span><br/><span class="hl-4">// init:</span><br/><span class="hl-4">// step:</span><br/><span class="hl-4">// result:</span><br/><span class="hl-4">// reduced:</span><br/><span class="hl-4">// value:</span><br/><br/><span class="hl-4">// processing fn:</span><br/><span class="hl-0">  </span><span class="hl-6">step</span><span class="hl-0">(</span><span class="hl-2">prevOut</span><span class="hl-0">, </span><span class="hl-2">curIn</span><span class="hl-0">) </span><span class="hl-5">=&gt;</span><span class="hl-0"> </span><span class="hl-2">newOut</span><br/><br/><span class="hl-4">// map:</span><br/><span class="hl-0">  </span><span class="hl-6">nextFn</span><span class="hl-0">(</span><span class="hl-2">nextIn</span><span class="hl-0">, </span><span class="hl-2">state</span><span class="hl-0">) </span><span class="hl-5">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-1">return</span><span class="hl-0"> { </span><span class="hl-2">done:</span><span class="hl-0"> </span><span class="hl-5">false</span><span class="hl-0">, </span><span class="hl-2">value:</span><span class="hl-0"> </span><span class="hl-2">state</span><span class="hl-0">.</span><span class="hl-6">mapFn</span><span class="hl-0">(</span><span class="hl-2">nextIn</span><span class="hl-0">.</span><span class="hl-2">value</span><span class="hl-0">) }</span><br/><span class="hl-0">  }</span><br/><span class="hl-4">// filter</span><br/><span class="hl-0">  </span><span class="hl-6">nextFn</span><span class="hl-0">(</span><span class="hl-2">nextIn</span><span class="hl-0">, </span><span class="hl-2">state</span><span class="hl-0">) </span><span class="hl-5">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-1">return</span><span class="hl-0"> </span><span class="hl-2">state</span><span class="hl-0">.</span><span class="hl-6">filterFn</span><span class="hl-0">(</span><span class="hl-2">nextIn</span><span class="hl-0">.</span><span class="hl-2">value</span><span class="hl-0">) ? </span><span class="hl-2">nextIn</span><span class="hl-0"> : { </span><span class="hl-2">done:</span><span class="hl-0"> </span><span class="hl-5">false</span><span class="hl-0"> }</span><br/><span class="hl-0">  }</span><br/><br/><span class="hl-4">// nextFn returns a nextIn and to compose we&#39;d need a function</span><br/><span class="hl-4">// that takes a nextFn and produces another nextFn</span><br/><br/><span class="hl-4">// composing a map, then filter would be written manually as</span><br/><span class="hl-5">const</span><span class="hl-0"> </span><span class="hl-8">result1</span><span class="hl-0"> = </span><span class="hl-4">/* await is some cases */</span><span class="hl-0"> </span><span class="hl-6">nextFnMap</span><span class="hl-0">(</span><span class="hl-2">nextIn</span><span class="hl-0">, </span><span class="hl-2">stateOfMap</span><span class="hl-0">)</span><br/><span class="hl-1">return</span><span class="hl-0"> </span><span class="hl-6">nextFnFilter</span><span class="hl-0">(</span><span class="hl-2">result1</span><span class="hl-0">, </span><span class="hl-2">stateOfFilter</span><span class="hl-0">)</span><br/><br/><span class="hl-6">itr8OperDefFactory</span><span class="hl-0">(</span><span class="hl-2">nextFn</span><span class="hl-0">, </span><span class="hl-2">initFn</span><span class="hl-0">) </span><span class="hl-5">=&gt;</span><span class="hl-0"> </span><span class="hl-4">// we could produce a &#39;stateful&#39; nextFn()?</span><br/><span class="hl-4">// or a nextFn, that already has state applied? and thus only takes 1 argument</span><br/><span class="hl-4">// which is an input next?</span><br/><span class="hl-4">// and if input and output would be compatible,</span><br/><span class="hl-4">// this would create functions that can be composed/piped</span><br/><span class="hl-4">// unfortunately they are not 100% compatible right currently because the output</span><br/><span class="hl-4">// 1. can contain iterable instead of value and  2. can be a promise</span><br/><span class="hl-4">// which means that we&#39;d need tooling to link them together</span><br/><span class="hl-4">// 1. could be replaced by always returning an iterator or by adding a boolean</span><br/><span class="hl-4">//    to the state (which we &#39;internalized&#39;) informing the &#39;engine&#39; whether</span><br/><span class="hl-4">//    a new next is needed already</span><br/><span class="hl-4">// so if we want to &#39;compose&#39; the nextFns (turning the &#39;pull&#39; into a &#39;push&#39; to the next nextFn)</span><br/><span class="hl-4">// so that we can create a single transIterator from multiple &#39;transformers&#39; combined,</span><br/><span class="hl-4">// we&#39;d need a composer function to do that for us so it can interpret for example the iterable field</span><br/><span class="hl-4">// and as a result call the next one multiple times?</span><br/><span class="hl-4">// all this should produce another nextFn that is the combination of all the others</span><br/><span class="hl-4">// so then we could have a method called transIt(nextFn, nextFn, nextFn) that turns that list into</span><br/><span class="hl-4">// a single transIterator, instead of a chain of many</span><br/><span class="hl-4">// OH AND I GUESS MAYBE WE CAN USE SOMETHING LIKE MONADS TO TURN NEXTFN INTO A FUNCTION THAT CAN BE COMPOSED???</span><br/><span class="hl-4">// (instead of writing a manual function to do it?) state will always be a problem when it&#39;s an argument I guess</span><br/><span class="hl-0">(...</span><span class="hl-2">args</span><span class="hl-0">) </span><span class="hl-5">=&gt;</span><span class="hl-0"> { </span><span class="hl-4">// each arg is a &#39;transform&#39; function (nextFn)</span><br/><span class="hl-0">  </span><span class="hl-4">// return another nextFn function that is the combination of all the arguments</span><br/><span class="hl-0">  </span><span class="hl-1">return</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-6">nextFn</span><span class="hl-2">:</span><span class="hl-0"> (</span><span class="hl-2">nextIn</span><span class="hl-0">, </span><span class="hl-2">state</span><span class="hl-0">) </span><span class="hl-5">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">      </span><span class="hl-5">let</span><span class="hl-0"> </span><span class="hl-2">curPrevOut</span><span class="hl-0"> = </span><span class="hl-2">nextIn</span><span class="hl-0">; </span><span class="hl-4">// a &#39;normal&#39; IteratorResult is compatible with a nextOut value</span><br/><span class="hl-0">      </span><span class="hl-5">let</span><span class="hl-0"> </span><span class="hl-2">result</span><span class="hl-0">;</span><br/><span class="hl-0">      </span><span class="hl-1">for</span><span class="hl-0"> (</span><span class="hl-5">const</span><span class="hl-0"> </span><span class="hl-8">aFn</span><span class="hl-0"> </span><span class="hl-5">of</span><span class="hl-0"> </span><span class="hl-2">args</span><span class="hl-0">) {</span><br/><span class="hl-0">        </span><span class="hl-1">if</span><span class="hl-0"> (</span><span class="hl-2">curPrevOut</span><span class="hl-0">.</span><span class="hl-2">iterable</span><span class="hl-0">) {</span><br/><span class="hl-0">          </span><span class="hl-2">result</span><span class="hl-0"> = { </span><span class="hl-2">done:</span><span class="hl-0"> </span><span class="hl-5">false</span><span class="hl-0">, </span><span class="hl-2">iterable:</span><span class="hl-0"> [] };</span><br/><span class="hl-0">          </span><span class="hl-5">let</span><span class="hl-0"> </span><span class="hl-2">count</span><span class="hl-0"> = </span><span class="hl-7">0</span><span class="hl-0">;</span><br/><span class="hl-0">          </span><span class="hl-1">for</span><span class="hl-0"> (</span><span class="hl-5">const</span><span class="hl-0"> </span><span class="hl-8">c</span><span class="hl-0"> </span><span class="hl-5">of</span><span class="hl-0"> </span><span class="hl-2">curPrevOut</span><span class="hl-0">.</span><span class="hl-2">iterable</span><span class="hl-0">) {</span><br/><span class="hl-0">            </span><span class="hl-5">const</span><span class="hl-0"> </span><span class="hl-8">r</span><span class="hl-0"> =  </span><span class="hl-6">aFn</span><span class="hl-0">(</span><span class="hl-2">c</span><span class="hl-0">, </span><span class="hl-2">state</span><span class="hl-0">[</span><span class="hl-2">aFn</span><span class="hl-0">.</span><span class="hl-2">id</span><span class="hl-0">]);</span><br/><span class="hl-0">            </span><span class="hl-1">if</span><span class="hl-0"> (</span><span class="hl-2">r</span><span class="hl-0">.</span><span class="hl-2">done</span><span class="hl-0">) </span><span class="hl-1">break</span><span class="hl-0">;</span><br/><span class="hl-0">            </span><span class="hl-2">result</span><span class="hl-0">.</span><span class="hl-2">iterable</span><span class="hl-0">.</span><span class="hl-6">push</span><span class="hl-0">(</span><span class="hl-2">r</span><span class="hl-0">.</span><span class="hl-2">value</span><span class="hl-0">); </span><span class="hl-4">// iterable should be created with a generator function</span><br/><span class="hl-0">            </span><span class="hl-2">count</span><span class="hl-0"> += </span><span class="hl-7">1</span><span class="hl-0">;</span><br/><span class="hl-0">          }</span><br/><span class="hl-0">          </span><span class="hl-1">if</span><span class="hl-0"> ( </span><span class="hl-2">count</span><span class="hl-0"> &lt;= </span><span class="hl-7">0</span><span class="hl-0"> ) {</span><br/><span class="hl-0">            </span><span class="hl-2">result</span><span class="hl-0"> = { </span><span class="hl-2">done:</span><span class="hl-0"> </span><span class="hl-5">true</span><span class="hl-0">, </span><span class="hl-2">iterable:</span><span class="hl-0"> [] };</span><br/><span class="hl-0">          }</span><br/><span class="hl-0">        } </span><span class="hl-1">else</span><span class="hl-0"> {</span><br/><span class="hl-0">          </span><span class="hl-2">result</span><span class="hl-0"> = </span><span class="hl-6">aFn</span><span class="hl-0">(</span><span class="hl-2">curPrevOut</span><span class="hl-0">, </span><span class="hl-2">state</span><span class="hl-0">[</span><span class="hl-2">aFn</span><span class="hl-0">.</span><span class="hl-2">id</span><span class="hl-0">]) </span><span class="hl-4">// state thing is pseudo code to get the idea across</span><br/><span class="hl-0">        }</span><br/><span class="hl-0">        </span><span class="hl-1">if</span><span class="hl-0"> (</span><span class="hl-2">result</span><span class="hl-0">.</span><span class="hl-2">done</span><span class="hl-0">) {</span><br/><span class="hl-0">          </span><span class="hl-1">return</span><span class="hl-0"> </span><span class="hl-2">result</span><span class="hl-0">;</span><br/><span class="hl-0">        }</span><br/><span class="hl-0">        </span><span class="hl-2">curPrevOut</span><span class="hl-0"> = </span><span class="hl-2">result</span><span class="hl-0">;</span><br/><span class="hl-0">      }</span><br/><span class="hl-0">      </span><span class="hl-1">return</span><span class="hl-0"> </span><span class="hl-2">result</span><span class="hl-0">;</span><br/><span class="hl-0">    },</span><br/><span class="hl-0">    </span><span class="hl-6">initStateFn</span><span class="hl-2">:</span><span class="hl-0"> () </span><span class="hl-5">=&gt;</span><span class="hl-0"> {} </span><span class="hl-4">// combine all the init-states of all the args?</span><br/><span class="hl-0">  }</span><br/><span class="hl-0">}</span><br/><br/><span class="hl-4">/**</span><br/><span class="hl-4"> * the &quot;monad-inspired&quot; version would have a &quot;bind&quot; function to turn</span><br/><span class="hl-4"> * ```(nextIn:IteratorResult, state) =&gt; nextFnResult```</span><br/><span class="hl-4"> * into an ```(nextFnResult) =&gt; nextFnResult``` version</span><br/><span class="hl-4"> * state from the output is kept for next time</span><br/><span class="hl-4"> * (the &#39;state&#39; will be &#39;against pure functional programming&#39;, but I see no way around it</span><br/><span class="hl-4"> * in order to create some truly useful operations)</span><br/><span class="hl-4"> *</span><br/><span class="hl-4"> * The &#39;unity&#39; function and the &#39;lift&#39; function - lift(f, x) = unit(f(x)) - to</span><br/><span class="hl-4"> * the &quot;lift&quot; function should make sure the right part of the input is handed over</span><br/><span class="hl-4"> * to the original function.</span><br/><span class="hl-4"> * So in short (ignoring the iterable property) unit should be like IteratorResult =&gt; NextFnOutputResult</span><br/><span class="hl-4"> */</span><br/><span class="hl-5">const</span><span class="hl-0"> </span><span class="hl-6">unity</span><span class="hl-0"> = (</span><span class="hl-2">nextIn</span><span class="hl-0">) </span><span class="hl-5">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">  </span><span class="hl-5">let</span><span class="hl-0"> </span><span class="hl-2">state</span><span class="hl-0">;</span><br/><span class="hl-0">  </span><span class="hl-5">let</span><span class="hl-0"> </span><span class="hl-2">done</span><span class="hl-0"> = </span><span class="hl-5">false</span><span class="hl-0">;</span><br/><span class="hl-0">  </span><span class="hl-1">return</span><span class="hl-0"> (</span><span class="hl-2">nextFnFormattedNextIn</span><span class="hl-0">) </span><span class="hl-5">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-1">if</span><span class="hl-0"> (</span><span class="hl-2">nextFnFormattedNextIn</span><span class="hl-0">.</span><span class="hl-2">iterable</span><span class="hl-0">) {</span><br/><span class="hl-0">      </span><span class="hl-4">// call nextIn on every element from the iterable, and return</span><br/><span class="hl-0">      </span><span class="hl-4">// a response also containing an iterable with all the results</span><br/><span class="hl-0">      </span><span class="hl-4">// from calling</span><br/><span class="hl-0">      </span><span class="hl-4">// watch out: when it returns done: true on one, we&#39;d need to keep some state</span><br/><span class="hl-0">      </span><span class="hl-4">// so we can tell we are &#39;done&#39; the next time</span><br/><span class="hl-0">    } </span><span class="hl-1">else</span><span class="hl-0"> {</span><br/><span class="hl-0">      </span><span class="hl-1">return</span><span class="hl-0"> </span><span class="hl-6">nextIn</span><span class="hl-0">(</span><span class="hl-2">nextFnFormattedNextIn</span><span class="hl-0"> </span><span class="hl-4">/* without the state */</span><span class="hl-0">, </span><span class="hl-2">state</span><span class="hl-0">)</span><br/><span class="hl-0">    }</span><br/><span class="hl-0">  }</span><br/><span class="hl-0">}</span>
</code></pre>

<a href="#how-to-handle-failures" id="how-to-handle-failures" style="color: inherit; text-decoration: none;">
  <h2>How to handle failures?</h2>
</a>
<p>Some of our operators (for example &#39;map&#39;) allow async methods to be run, so they can be used for things that
are prone to failure (I am not considering the synchronous case because that can be controlled entirely by the user).</p>
<p>The question is: if we know that things can potentially fail, are we going to add a specific
protocol to handle these failures? Right now: if something fails that means that the next call
will reject its promise, and the entire processing chain will break.</p>
<p>We could say: it&#39;s up to the user to make sure that his function always resolves, and so it&#39;s up
to him to invent a data format that can express failures, so that they can be handled further
down the line.</p>
<p>But I recently viewed this youtube video about the <a href="https://www.youtube.com/watch?v=xDuwrtwYHu8">Saga pattern</a> which essentially means: on failure take compensating measures for every action
that already happened (kind of like &#39;rollback&#39; if possible, but in some cases - like sending an email - things cannot be undone and you have to send another message explaining that the previous
email should be ignored).</p>
<p>It could be that we can agree on a way to enforce (or at least support) people to implement this
kind of pattern, which also helps in being aware of whatever can go wrong, in order to build more
robust systems.</p>

<a href="#piping-should-have-better-typing" id="piping-should-have-better-typing" style="color: inherit; text-decoration: none;">
  <h2>Piping should have better typing</h2>
</a>
<p>Piping should have better typing (like RxJS does it?) to make sure you get hints if you are trying to pipe functions together whose output and input types do not match.</p>

<a href="#general-code-cleanup" id="general-code-cleanup" style="color: inherit; text-decoration: none;">
  <h2>General code cleanup</h2>
</a>
<ul>
<li>Should we create &#39;categories&#39; of operators so people do not have to include the entire library?
  (for example delay, throttle, debounce under operators/timeBased and maybe max, min, average, pctl(...), total, ... under operators/numeric)</li>
<li>This is done in the jsdoc by adding @category, but all the operators currently atre still in the same file. Maybe one file per operator would make sense, and maybe also one file per category, and one file exposing all operators. This way, people who don&#39;t need to worry about bundle size can simply import
itr8/operators, and people with a strict bundle size can import /itr8/operators/general/map</li>
</ul>

<a href="#writing-more-and-better-documentation-and-examples-to-show-what-can-be-done" id="writing-more-and-better-documentation-and-examples-to-show-what-can-be-done" style="color: inherit; text-decoration: none;">
  <h2>Writing more and better documentation and examples to show what can be done.</h2>
</a>
<ul>
<li>Show how an &#39;The Elm Architecture&#39;-like or appRun-like app engine could be implemented<ul>
<li>1 way is to use something similar to CSP, where multiple processes push messages to each other by using itr8Pushables.<ul>
<li>a zip operation would zip the event and the current state together</li>
<li>push the new state to the state iterator</li>
<li>push the new state also to the view-iterator that transforms state into html</li>
<li>push the generated html to the render-iterator that will update the screen</li>
</ul>
</li>
<li>another way is to view the entire application as 1 single transIterator where the input is &#39;events&#39; and the output is html (or lit-html templateresult).<ul>
<li>a zip operation would zip that event and the current state together</li>
<li>a tap operation would send the newState back into the pushable state iterator</li>
<li>A for each at the end would take the html and use it to update the DOM</li>
</ul>
</li>
</ul>
</li>
<li>Explain how an ASYNC iterator is actually an extremely simple 2-way protocol:<ul>
<li>every next() call informs the sender that we&#39;re ready to receive another value</li>
<li>every resolved promise hands the new message to the receiver</li>
<li>despite its simplicity, there is a fair amount of problems that can be solved with it.
Imagine for example a round-robin scheme: each handler will indicate when it&#39;s ready to process
another message by a next() call. The round robin engine will send every new message
to the first of the round robin circle that is ready to receive that new message
(it would be a waste of time to send it to the next regardless whether it&#39;s ready or not)</li>
</ul>
</li>
</ul>

<a href="#add-some-more-useful-operators" id="add-some-more-useful-operators" style="color: inherit; text-decoration: none;">
  <h2>Add some more useful operators</h2>
</a>
<ul>
<li>gzip/gunzip?</li>
<li>we&#39;ll probably find some inspiration in the RxJS library and also in <a href="https://hexdocs.pm/elixir/Stream.html">Elxir&#39;s Streams</a></li>
<li>implement the equivalent of json-stream that works on a single-character or string iterator<ul>
<li>first I was looking at jsonstream which is built upon jsonparse which is really old</li>
<li>then I came across streamparser-json, which is an OO-style library that defines a separate
&#39;tokenizer&#39; and &#39;tokenParser&#39;, which when combined would produce a jsonParser.<ul>
<li>The write() method of the tokenizer feels &#39;wrong&#39; because it does 3 things: add the incoming data
to the internal buffer, go through the buffer to produce new tokens, on every token found, call
a callback function with that token.</li>
<li>I think we should be able to extract the main algorithm (parsing into a token) into the operatorFactory (using the &#39;state&#39; to hold the part of the buffer that didn&#39;t produce an
entire new token yet and other state needed by a tokenizer). That would be the first &#39;operator&#39;,
the second operator would take
a stream of tokens, and produce objects (only selecting the ones we&#39;re interested in).</li>
<li>The tokenizer holds the entire parent object in memory which is a problem for large arrays
and the way to &#39;fix&#39; this (from the examples on their website) is to manipulate that object!</li>
<li>The alternative would be to just build a transIterator that wraps this other library,
and although it would require less code changes, I feel that the library would benefit
from a better seperation of concerns.</li>
</ul>
</li>
</ul>
</li>
<li>Use <a href="https://nodejs.org/docs/latest-v16.x/api/cluster.html">cluster</a> and/or <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Web Workers</a> to allow CSP style
programming and make communicating from one process to another (at least from master to slaves and the other way around) easy. If we do it properly (detect or by passing in a flag to choose whether we are in node or in the browser), the user only needs to pass a single parameter, which is the file containing the transIterator that will translate input messages to output messages, and then the same code could be used on the server as well as in the browser.
A <a href="https://github.com/hunterloftis/throng">throng</a> feature that I like is that it respawns a worker if one dies, and ideally the new one would get the same channel so the master can keep sending commands to it, maybe without even realising that one has crashed and has been restarted. (Maybe we need to create a new transIterator that has an &#39;ack&#39; channel (another iterator) sa input to confirm that processing has been finished, so it can retry on failure, could maybe be written by using the &#39;mostRecent&#39; operator combined with a pushable iterator somehow?)<ul>
<li>For CLUSTER: a worker.send method exists that allows to send messages from worker to parent and the other way around. Maybe we can wrap these into an itr8Pushable, in such a way that people can write exactly the same CSP-style code, and easily have it running on multiple cores when they wish to. So the &#39;worker&#39; could be defined as &#39;a function that takes an iterator as input (the incoming messages) and produces an iterator (the responses to master)&#39;. Sounds familiar? Yes, because it&#39;s a simple transIterator!
  And the code around it (which is always the same) should make sure that these results are being pushed back using worker.send, inside a forEach that actively drains the iterator...</li>
<li>For WEB WORKERS: we can use the postMessage interface to send messages back and forth.</li>
<li>There are some examples online to allow for ts files to be loaded (by using ts-node, which would make it a runtime dependency rather than a dev dependency)</li>
</ul>
</li>
</ul>

<a href="#other-39generators39" id="other-39generators39" style="color: inherit; text-decoration: none;">
  <h2>Other &#39;generators&#39;</h2>
</a>
<ul>
<li><p>for typical cases like file input, db paga-per-page processing, ...</p>
</li>
<li><p>how about an &#39;itr8ToMultiIterable&#39; to handle the case where you want to &#39;split&#39; the stream into multiple streams for separate further processing?</p>
<ul>
<li>because it is pull based, you&#39;d need state to know about the &#39;subscribed&#39; iterators, so we can keep track of what their next element would be</li>
<li>it should buffer when 1 child-iterator gets the next, so the same element can be given to all the other subscribers on their next call</li>
<li>the buffer should be kept as long as one subscriber didn&#39;t ask for that next()</li>
<li>there should be a way to &#39;disconnect&#39;, tell the iterable that we are not interested in more, so it won&#39;t keep buffering for no reason because we stop asking for next stuff.</li>
<li>we could add a timeout to automatically clean up the buffer if a subscriber didn&#39;t ask for a next element within a certain time (1 minute default?)</li>
</ul>
</li>
</ul>

<a href="#use-iterators-everywhere" id="use-iterators-everywhere" style="color: inherit; text-decoration: none;">
  <h2>use iterators everywhere</h2>
</a>
<p>Think about how to make it easy to use operator parameters that are iterators themselves.</p>
<ul>
<li>Would make it easier to implement the zip operator (less boilerplate)</li>
<li>Would in general allow for operator parameters that &#39;change over time&#39;.</li>
<li>Can we make this generic in such away that <em>any</em> parameter of type T could be replaced
by an (Async)Iterator<T>?<ul>
<li>The most powerful would be if the writer of the operator is in charge of calling next()
on the parameter, BUT it would also make writing operators more complex, because then
the authors would also need to use thenable in order to handle sync and async iterators
properly, which adds a lot of complexity.</li>
<li>So we could also do as we already do for the nextIn param: call next on it ourselves
and passing the response into the function, but that way we loose the freedom to not call
next on every next call to the incoming iterator.</li>
<li>It might make things so complex that nobody knows how to write an operator anymore.</li>
<li>Of course: if we do it implicitly, all operators would be able to change their paramaters
  over time without any code changes for existing operators!</li>
<li>Maybe we could have an advanced operator factory where the responsibility lies with the user</li>
</ul>
</li>
<li>Can we abstract the handling of sync versus async iterators away in an elegant manner?
That means that if the input iterator is sync, all handling stays sychronous and will only
become asynchronous when the iterator is asynchronous. But all this without the user having
to alter the code...</li>
</ul>
<p>I created 2 helper functions called thenable and forLoop for this.
Thenable will make any value thenable, to make sure we can use the same code regardless whether the input is a promise or not, and guaranteeing that the handling will also be synchronous if the input
is not a promise.
forLoop is like a for loop that will be synchronous if the input is synchronous and synchronous otherwise.</p>

<a href="#batch-support" id="batch-support" style="color: inherit; text-decoration: none;">
  <h2>batch support</h2>
</a>
<p>Currently I don&#39;t see a lot of performance benefits of the batch support, so it could be that we might as well remove the support for that, because it complicates building new operators.</p>
<p>1 thing is important: <strong>&#39;itr8batch&#39; should not be a property (literally a JS property now) of the iterator, nor should it make the itr8OperatorFactory more complex (as it currently does). That code should be removed ASAP</strong>.
If we would still want to support it, it should be done as an operator that has a transIterator as its argument (or maybe support multiple arguments in order to avoid needing another itr8Pipe)</p>
<p>Example:</p>
<pre><code class="language-typescript"><span class="hl-4">// Instead of</span><br/><span class="hl-2">myIt</span><span class="hl-0">.</span><span class="hl-6">pipe</span><span class="hl-0">(</span><br/><span class="hl-0">  </span><span class="hl-6">asBatch</span><span class="hl-0">(),</span><br/><span class="hl-0">  </span><span class="hl-6">someOp</span><span class="hl-0">(),</span><br/><span class="hl-0">  </span><span class="hl-6">someOtherOp</span><span class="hl-0">(),</span><br/><span class="hl-0">  </span><span class="hl-6">asNoBatch</span><span class="hl-0">(),</span><br/><span class="hl-0">)</span><br/><br/><span class="hl-4">// it would become something like below (so the asBatch operator would make sure all its</span><br/><span class="hl-4">// transIt arguments would be applied to each array element separately)</span><br/><span class="hl-2">myIt</span><span class="hl-0">.</span><span class="hl-6">pipe</span><span class="hl-0">(</span><br/><span class="hl-0">  </span><span class="hl-6">asBatch</span><span class="hl-0">(,</span><br/><span class="hl-0">    </span><span class="hl-6">someOp</span><span class="hl-0">(),</span><br/><span class="hl-0">    </span><span class="hl-6">someOtherOp</span><span class="hl-0">(),</span><br/><span class="hl-0">  ),</span><br/><span class="hl-0">)</span><br/><br/><span class="hl-4">// or if the batch operator would only support a single argument it would become a bit less</span><br/><span class="hl-4">// elegant as we&#39;d need &#39;itr8Pipe&#39; to compose the transIterators.</span><br/><span class="hl-2">myIt</span><span class="hl-0">.</span><span class="hl-6">pipe</span><span class="hl-0">(</span><br/><span class="hl-0">  </span><span class="hl-6">asBatch</span><span class="hl-0">(,</span><br/><span class="hl-0">    </span><span class="hl-6">itr8Pipe</span><span class="hl-0">(</span><br/><span class="hl-0">      </span><span class="hl-6">someOp</span><span class="hl-0">(),</span><br/><span class="hl-0">      </span><span class="hl-6">someOtherOp</span><span class="hl-0">(),</span><br/><span class="hl-0">    ),</span><br/><span class="hl-0">  ),</span><br/><span class="hl-0">)</span>
</code></pre>
<p>Other questions about how the batch things should work:
Improve batch support: current implementation will grow and shrink batch size depending on the operation (filter could shrink batches significantly for example, but batches with only a few elements don&#39;t have a very big advantage performance wise). Of course you could always <code>unBatch |&gt; batch(size)</code> to force a new batch size, but it could be more efficient if the itr8OperatorFactory handles the batch size and keeps it constant throughtout the chain???</p>
</div></div><div class="col-4 col-menu menu-sticky-wrap menu-highlight"><nav class="tsd-navigation primary"><ul><li class=""><a href="modules.html">Modules</a></li><li class="current pages-entry pages-entry-page pages-entry-depth-0"><a href="ROADMAP.html">Roadmap</a></li><li class=" tsd-kind-module"><a href="modules/index.html">index</a></li><li class=" tsd-kind-module"><a href="modules/interface.html">interface</a></li><li class=" tsd-kind-module"><a href="modules/operators.html">operators</a></li><li class=" tsd-kind-module"><a href="modules/peer.html">peer</a></li><li class=" tsd-kind-module"><a href="modules/util.html">util</a></li></ul></nav><nav class="tsd-navigation secondary menu-sticky"><ul></ul></nav></div></div></div><footer class="with-border-bottom"><div class="container"><h2>Legend</h2><div class="tsd-legend-group"><ul class="tsd-legend"><li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li><li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li></ul></div><h2>Settings</h2><p>Theme <select id="theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></p></div></footer><div class="container tsd-generator"><p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></div><div class="overlay"></div><script src="assets/main.js"></script></body></html>