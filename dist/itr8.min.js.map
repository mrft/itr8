{
  "version": 3,
  "sources": ["../src/util/index.ts", "../src/interface/forEach.ts", "../src/interface/itr8FromIterator.ts", "../src/interface/itr8FromArray.ts", "../src/interface/itr8FromArrayAsync.ts", "../src/interface/itr8FromIterable.ts", "../src/interface/itr8FromSingleValue.ts", "../src/interface/itr8FromSingleValueAsync.ts", "../src/interface/itr8FromString.ts", "../src/interface/itr8FromStringAsync.ts", "../src/interface/itr8Pushable.ts", "../src/interface/itr8Interval.ts", "../src/interface/itr8Range.ts", "../src/interface/itr8RangeAsync.ts", "../src/interface/itr8ToArray.ts", "../src/interface/itr8ToObject.ts", "../src/interface/itr8ToString.ts", "../src/operators/general/powerMap.ts", "../src/operators/general/takeWhile.ts", "../src/interface/itr8ToMultiIterable.ts", "../src/operators/async/mostRecent.ts", "../src/operators/async/prefetch.ts", "../src/operators/async/parallel.ts", "../src/operators/boolean/every.ts", "../src/operators/boolean/some.ts", "../src/operators/general/dedup.ts", "../src/operators/general/filter.ts", "../src/operators/general/flatten.ts", "../src/operators/general/groupPer.ts", "../src/operators/general/intersperse.ts", "../src/operators/general/peek.ts", "../src/operators/general/map.ts", "../src/operators/general/reduce.ts", "../src/operators/general/repeat.ts", "../src/operators/general/repeatEach.ts", "../src/operators/general/runningReduce.ts", "../src/operators/general/skip.ts", "../src/operators/general/sort.ts", "../src/operators/general/split.ts", "../src/operators/general/take.ts", "../src/operators/general/tap.ts", "../src/operators/general/uniq.ts", "../src/operators/general/uniqBy.ts", "../src/operators/general/zip.ts", "../src/operators/numeric/average.ts", "../src/operators/numeric/max.ts", "../src/operators/numeric/min.ts", "../src/operators/numeric/percentile.ts", "../src/operators/numeric/runningAverage.ts", "../src/operators/numeric/runningPercentile.ts", "../src/operators/numeric/runningTotal.ts", "../src/operators/numeric/total.ts", "../src/operators/strings/lineByLine.ts", "../src/operators/strings/stringToChar.ts", "../src/operators/timeBased/debounce.ts", "../src/operators/timeBased/delay.ts", "../src/operators/timeBased/throttle.ts"],
  "sourcesContent": ["/**\n * Utility functions that are used internally, but that can be used by anyone to\n * help create operators that support both synchronous and asynchronous parameters\n * (by using thenable, forLoop or isPromise).\n *\n * @module\n */\n\n// https://www.typescriptlang.org/play?#code/MYewdgzgLgBAhgLjAVwLYCMCmAnA2gXRgF4ZcBGAGhgCYqBmKgFnwG4AoUSWdBabASzABzAsVIBycJnFVxUAO4gZcgBbZM02QDMQybONZs2W5GGBR+4GFBABJKDjg3sAHgAqAPgAUiAILZsOABPdw8ASgR7R2dQmABvNhgkmHUoPTB4XABlIIwQABsAOn4HQOd8LzD2AF8jEzMLKxLokGw3EH9AkM8vZrLWyNKnVtCIzuDYhOSYfMxYdQhkfNgSAnZp2dgwdeT5FX5ZmC8AQi8Mkj7h7EKwTAAPKEqwwoATKTD4xOnkhaWoQoADsgICozoUAG5wfLITBVL5JWrTVLpFKYRbLGpGYymcyWMAAKhScGEmC80Dg2CgSDQWGwVEwYBe1IwOA+U2S-C0R3JlJgLhgDJebPh3x02COmxg-DEPKgLClfJIgvl-AA1Krhd8tTAgvxMPkXlKdlrEclqgL8hBMJ9tTAxRK5gqSLKVTAPErGSqALRezW25K6-WG-jG76mhFsWpsAD00ZgnAgBUwhXyICEXlwhSzgRJXgYAHYwvg4bH4+BE7MU2mM1nCjmhKSAKwUahFuFGUsJpNV9OXZztcZBLw2KL9bA+MKT9gccuwPpieukhgATnbUCCAOtbjcOYgL2QwBw7lsYAobgA8sgoB4xL0hs5Bi1XG4Tx4qLWARS4KgIAh4GAgg+Igb1HK53Eva9pwTWBUDgAEEG3Xd90PVxiSCCg0JvEh6lxcBCTvR8xxcFAWWwN87TABAvDuBA0KAm86JtZJJVuB4TzEEobnuR44WmPYDlJY5WKgE9XneJitUDA0KLObjRMhaFYVDaZhPYi5-mEypQ1qKNoJgWCAWoBCd2JPcDyPNCMIArCjhKQiwJI2lyK0SjqNogD6P-QDiBvdkkmRbAMj875hL-SofIk-09NU84pQ07itJFW09OweznAAJTRP5iJpHAbOC-1kgUmE-xc2S2LACEoRhMIKCSwqYDeW4-xisTbjqhqYHDf0AoybBlLNEVzTgCAYFAmJHLyyMjD0rQDlKYykPM1CAKsoIbJwxoCVsqlxpGTCqBcqiaMY4CYHQEAk2JP0khYuTYs4zTeN2fZZhOVqmthSLpk5I4yta4rYRu-0pMNAHqswAaI1tGKOPih5EumHSZtnGAQC0LQrSpRDTOQizVswsRNrxfC7L2lb1qob9dDAKlJuwYG7oquGuIR57bsdUBTFKMQAAZQ34t6hPutqvoK5IudpnAxElnnVRgMgoalLkvFl6WGNQGmoGB21QZgcHFKV7qVPulmnu06aZy4GZ+FQOyccgPGKbWjacS20ndvvfbrKpzXueZWlGcdWH1NZnjQ0lNXxRIfmRUFwSPvE8WkijmWtel+XFfqpJftV9PxRcEhqe5nXtT1g2YSN7P9dN0PzaGy2YzjYm8JgAF+E3Lxa1wEB4IdsyUKp7AhDQBkoF-GBCDCFHrbgagifmnAvAM4c7C98c4Fqo4aPpzy7hgTOt7c3eIv3m9Wyg8tu1TXt14HAJgh8Vt2y7Ssb7vJ9766Lx0cxuZV-Jl4dAW9n4vyvm-asfZWhf0fvkW2JQAHryASAycVQgA\n\nimport { TThenable } from \"../types.js\";\n\n// THIS MIGHT BE AN ALTERNATIVE TO REMOVE THE DEPENDENCY to Node's uil/types\n////////////////////////////////////////////////////////////////////////////\n/**\n * Check whether the parameter is a promise.\n *\n * @param p\n * @returns true if p is a promise\n *\n * @category util\n */\nconst isPromise = function isPromise(p: unknown): p is Promise<unknown> {\n  return (\n    p !== undefined &&\n    p !== null &&\n    Object.prototype.toString.call(p) === \"[object Promise]\"\n  );\n};\n\n// import { isPromise } from 'util/types'\n\n// try {\n//   // eslint-disable-next-line @typescript-eslint/no-var-requires\n//   isPromise = require('util/types').isPromise;\n// } catch {\n//   // ignore\n// }\n\n/**\n * Shim for allowing async function creation similar to new Function.\n *\n * Found here: https://davidwalsh.name/async-function-class\n *\n * @example\n * ```javascript\n * const fetchPage = new AsyncFunction(\"url\", \"return await fetch(url);\");\n * ```\n */\nconst AsyncFunction = Object.getPrototypeOf(async function () {\n  /* empty */\n}).constructor;\n\n/**\n * (Word play on then-able an th-enable)\n *\n * This utility function makes sure that any value (Promise or otherwise)\n * will be turned into an object with a then property, so that we can write the same code\n * regardless of whether the input is sync or async, but guaranteeing that\n * if the input is sync, all operations will also be called synchronously.\n *\n * The original input object is available under the thenable(...).src property.\n *\n * After the then callback has finished, the Object's 'value' property will be set\n * to the 'resolved' value.\n *\n * @example\n * ```typescript\n * // the same code can be applied without changes to a promise or a non promise\n * // by doing it all in the then-callback\n * thenable(123)\n *  .then(\n *    (v) => {\n *      console.log(v);\n *      return getSomeOtherSyncOrAsyncVal(v);\n *    }\n *  )\n *  .then(\n *    (otherVal) => {\n *      console.log(otherVal);\n *      return getYetAnotherVal(v);\n *    }\n *  )\n * ```\n *\n * ???\n * MAYBE a better solution would be to have a function called ```doAfter(value, (value) => { your code })```\n * that checks whether it is a promise or not, and returns the result of the handler?\n * But without the pipe operator it would be a pain to chain them, unless it will return an object\n * with some properties like ```{ result, doAfter:... }```\n * or maybe thenable should always return a new object with poerties ```{ src, then, finally, ... }``` so\n * that the interface resembles a promise, but if we need the actual promise or value\n * we should simply call src?\n *\n * @param x a Promise or a regular value\n * @returns an object that has a then function and a src property pointing to the original input\n *          regardless whether it is a Promise or not\n *\n * @category util\n */\nconst thenable = <T>(x: T): TThenable<T> => {\n  if (isPromise(x)) {\n    const newX = {\n      src: x,\n      then: (...args) => thenable(x.then(...args)),\n    };\n    // make sure the value gets added to this object after the promise resolves\n    x.then((value) => (newX[\"value\"] = value));\n    return newX;\n  } else {\n    if (typeof (x as any)?.then === \"function\") {\n      return x as unknown as TThenable;\n    } else {\n      // needed, because in strict mode it is impossble to set a property\n      // on a string primitive (and in non-strict mode the set value cannot be read again)\n      const newX = {\n        src: (x as any)?.src !== undefined ? (x as any).src : x,\n        then: (okHandler: (v: unknown, isSync?: boolean) => unknown) => {\n          const retVal = thenable(okHandler(x, true));\n          retVal[\"value\"] = retVal.src;\n          return retVal;\n        },\n        value: x,\n      };\n      return newX;\n    }\n  }\n};\n\n/**\n * This utility function will do a for loop, synchronously if all the parts are synchronous,\n * and asynchronously otherwise.\n * This should help us to use the same code yet supporting both possible scenarios.\n *\n * @param initialStateFactory\n * @param testBeforeEach\n * @param afterEach\n * @param codeToExecute\n * @returns void | Promise<void>\n *\n * @category util\n */\nconst forLoop = <State>(\n  initialStateFactory: () => State | Promise<State>,\n  testBeforeEach: (a: State) => boolean | Promise<boolean>,\n  afterEach: (a: State) => State | Promise<State>,\n  codeToExecute: (a: State) => void | Promise<void>\n) => {\n  // if we assume that thenable will return true as the second argument of the callbacks\n  // when we are still synchronous, we can write this with thenable I think\n  return thenable(initialStateFactory()).then((initialState, isSyncInit) => {\n    return thenable(testBeforeEach(initialState)).then(\n      (testResult, isSyncTest) => {\n        // this should work, both for sync and async stuff, so that we don't get the indentation-of-hell issue?\n        if (testResult) {\n          return thenable(codeToExecute(initialState)).then((_, isSyncBody) => {\n            return thenable(afterEach(initialState)).then(\n              (firstStateAfterEach, isSyncAfterBody) => {\n                if (isSyncInit && isSyncTest && isSyncBody && isSyncAfterBody) {\n                  // everything is synchronous so we can do a synchronous for loop\n                  let state = firstStateAfterEach;\n                  while (testBeforeEach(state)) {\n                    codeToExecute(state);\n                    state = afterEach(state);\n                  }\n                  return state;\n                } else {\n                  // naive implementation: something is asynchronous so we can to do an asychronous for loop\n                  // return (async () => {\n                  //   let state = firstStateAfterEach;\n                  //   while (await testBeforeEach(state)) {\n                  //     await codeToExecute(state);\n                  //     state = await afterEach(state);\n                  //   }\n                  //   return state;\n                  // })();\n\n                  // await on a non-promise will still break execution and turns\n                  // the value into Promise.resolve(...))\n                  // SO can we only await if it's necessary?\n                  // 2^3 = 8 possible (ignoring the generation of initial state) combinations\n                  // with and without await\n                  // Luckily new Function('a', 'b', 'return a + b;'); will produce a function\n                  // from a string and some clever guy found a way to create an AsyncFunction\n                  // equivalent of that!\n                  // So using isSyncInit, isSyncTest, isSyncBody, isSyncAfterBody to decide\n                  // whether a value shouldbe awaited, we can solve it like this\n                  return new AsyncFunction(\n                    \"firstStateAfterEach\",\n                    \"testBeforeEach\",\n                    \"codeToExecute\",\n                    \"afterEach\",\n                    `\n                    let state = firstStateAfterEach;\n                    while (${isSyncTest ? \"\" : \"await \"}testBeforeEach(state)) {\n                      ${isSyncBody ? \"\" : \"await \"}codeToExecute(state);\n                      state = ${\n                        isSyncAfterBody ? \"\" : \"await \"\n                      }afterEach(state);\n                    }\n                    return state;\n                  `\n                  )(\n                    firstStateAfterEach,\n                    testBeforeEach,\n                    codeToExecute,\n                    afterEach\n                  );\n                }\n              }\n            );\n          });\n        } else {\n          return initialState;\n        }\n      }\n    );\n  });\n};\n\n/**\n * Produce a new (parameterless) itr8 that is the combination of all the itr8 params\n *\n * Maybe We could allow the first element to either be a TTransIterator or just an iterator?\n * As long as the final output is an iterator?\n *\n * @param params a list of transIterators\n *\n * @category util\n */\n// function compose<TIn=any,TOut=any>(\n//   first:TTransIteratorSyncOrAsync,\n//   ...params:Array<TTransIteratorSyncOrAsync>\n// ):TTransIteratorSyncOrAsync<TIn, TOut> {\n//   const [second, ...rest] = params;\n//   return second\n//     ? compose((it:Iterator<any>) => itr8FromIterator(second(first(it))), ...rest)\n//     : (it:Iterator<any>) => itr8FromIterator(first(it));\n//   ;\n// }\n\n/**\n * A more generic pipe function that takes multiple functions as input\n * and outputs a single function where input = input of the first function\n * and output = output where every funtion has been applied to the output of the previous on.\n *\n * So itr8Pipe(f1:(x:A)=>B, f2:(x:B)=>C, f3:(x:C)=>D) returns (a:A):D => f3(f2(f1(a)))\n *\n * @param first\n * @param params\n * @returns\n *\n * @deprecated see compose (and pipe)\n */\nfunction itr8Pipe<A, B>(fn1: (x: A) => B): (x: A) => B;\nfunction itr8Pipe<A, B, C>(fn1: (x: A) => B, fn2: (x: B) => C): (x: A) => C;\nfunction itr8Pipe<A, B, C, D>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D\n): (x: A) => D;\nfunction itr8Pipe<A, B, C, D, E>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E\n): (x: A) => E;\n/*export*/ function itr8Pipe<A = any, B = any>(\n  first: (x: A) => B,\n  ...params: Array<(any) => any>\n): any {\n  if (params.length === 0) {\n    return first;\n  } else {\n    return params.reduce<(any) => any>((acc, cur) => {\n      return (arg) => cur(acc(arg));\n    }, first);\n  }\n}\n\n/**\n * A generic compose function that takes multiple functions as input\n * and outputs a single function where input = input of the first function\n * and output = output where every funtion has been applied to the output of the previous one.\n *\n * So\n * ```typescript\n * compose(f1:(x:A)=>B, f2:(x:B)=>C, f3:(x:C)=>D)\n * ```\n * will return a single unary function\n * ```typescript\n * (a:A):D => f3(f2(f1(a)))\n * ```\n *\n * @param first\n * @param params\n * @returns\n */\nfunction compose<A, B>(fn1: (x: A) => B): (x: A) => B;\nfunction compose<A, B, C>(fn1: (x: A) => B, fn2: (x: B) => C): (x: A) => C;\nfunction compose<A, B, C, D>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D\n): (x: A) => D;\nfunction compose<A, B, C, D, E>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E\n): (x: A) => E;\nfunction compose<A, B, C, D, E, F>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F\n): (x: A) => F;\nfunction compose<A, B, C, D, E, F, G>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F,\n  fn6: (x: F) => G\n): (x: A) => G;\nfunction compose<A, B, C, D, E, F, G, H>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F,\n  fn6: (x: F) => G,\n  fn7: (x: G) => H\n): (x: A) => H;\nfunction compose<A, B, C, D, E, F, G, H, I>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F,\n  fn6: (x: F) => G,\n  fn8: (x: G) => H,\n  fn7: (x: H) => I\n): (x: A) => I;\nfunction compose<A, B, C, D, E, F, G, H, I, J>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F,\n  fn6: (x: F) => G,\n  fn7: (x: G) => H,\n  fn8: (x: H) => I,\n  fn9: (x: I) => J\n): (x: A) => J;\nfunction compose<A, B, C, D, E, F, G, H, I, J, K>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F,\n  fn6: (x: F) => G,\n  fn7: (x: G) => H,\n  fn8: (x: H) => I,\n  fn9: (x: I) => J,\n  fn10: (x: J) => K\n): (x: A) => K;\nfunction compose<A, B, C, D, E, F, G, H, I, J, K>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F,\n  fn6: (x: F) => G,\n  fn7: (x: G) => H,\n  fn8: (x: H) => I,\n  fn9: (x: I) => J,\n  fn10: (x: J) => K,\n  ...moreFns: Array<(x: unknown) => unknown>\n): (x: A) => unknown;\nfunction compose<A, B>(\n  first: (x: A) => B,\n  ...params: Array<(unknown) => unknown>\n): unknown {\n  if (params.length === 0) {\n    return first;\n  } else {\n    return params.reduce<(unknown) => unknown>((acc, cur) => {\n      return (arg) => cur(acc(arg));\n    }, first);\n  }\n}\n\n/**\n * A pipe function applies the multiple functions to the first parameter\n *\n * So\n * ```typescript\n * pipe(x: A, f1:(x:A)=>B, f2:(x:B)=>C, f3:(x:C)=>D)\n * ```\n * returns the result of (a:A):D => f3(f2(f1(a)))\n *\n * @param first\n * @param params\n * @returns\n */\nfunction pipe<IN, A>(input: IN, fn1: (x: IN) => A): A;\nfunction pipe<IN, A, B>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B): B;\nfunction pipe<IN, A, B, C>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C\n): C;\nfunction pipe<IN, A, B, C, D>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D\n): D;\nfunction pipe<IN, A, B, C, D, E>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E\n): E;\nfunction pipe<IN, A, B, C, D, E, F>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F\n): F;\nfunction pipe<IN, A, B, C, D, E, F, G>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G\n): G;\nfunction pipe<IN, A, B, C, D, E, F, G, H>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G,\n  fn8: (x: G) => H\n): H;\nfunction pipe<IN, A, B, C, D, E, F, G, H, I>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G,\n  fn8: (x: G) => H,\n  fn9: (x: H) => I\n): I;\nfunction pipe<IN, A, B, C, D, E, F, G, H, I, J>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G,\n  fn8: (x: G) => H,\n  fn9: (x: H) => I,\n  fn10: (x: I) => J\n): J;\nfunction pipe<IN, A, B, C, D, E, F, G, H, I, J>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G,\n  fn8: (x: G) => H,\n  fn9: (x: H) => I,\n  fn10: (x: I) => J,\n  ...moreFns: Array<(x: unknown) => unknown>\n): unknown;\nfunction pipe<IN, A>(\n  input: IN,\n  fn1: (x: IN) => A,\n  ...functionsToApply: Array<(unknown) => unknown>\n): unknown {\n  if (functionsToApply.length === 0) {\n    return fn1(input);\n  } else {\n    const composedFn = functionsToApply.reduce<(unknown) => unknown>(\n      (acc, cur) => {\n        return (arg) => cur(acc(arg));\n      },\n      fn1\n    );\n    return composedFn(input);\n  }\n}\n\nexport {\n  /**\n   * @deprecated Use compose(...) instead!\n   */\n  compose as itr8Pipe,\n  compose,\n  pipe,\n  isPromise,\n  AsyncFunction,\n  thenable,\n  forLoop,\n  // itr8OperatorFactory,\n};\n", "/**\n * forEach is the one that will actually start 'draining' the iterator.\n * (itr8ToArray and most other itr8To... methods as well)\n *\n * @module\n */\n\nimport { isPromise } from \"../util/index.js\";\n\n/**\n * produces a function that can be applied to an iterator and that will execute\n * the handler on each value.\n *\n * The handler can be asynchronous!\n * By default the next will only be handled when the current handler has finished.\n * If you set options.concurrency to a higher value, you are allowing multiple handlers\n * to run in parallel.\n * But the next() will already be called while the (async) handler is still handling the current\n * result, which optimizes things by not waiting for the processing to finish, before asking for\n * the next one. Instead we'll first be asking for the next one, and then start processing of the\n * current one. This will waste less time than using 'for await (... of ...)' while still\n * processing things in the expected order!\n *\n * @param handler\n * @param options: ```{ concurrency: number }``` will control how many async handler are allowed to run in parallel. Default: 1\n * @returns\n *\n * @category interface/standard\n */\nconst forEach = function <T = any>(\n  handler: (T) => void | Promise<void>,\n  options?: { concurrency?: number }\n): (it: Iterator<T> | AsyncIterator<T>) => void | Promise<void> {\n  return (it: Iterator<T>) => {\n    let throwCount = 0;\n    const maxRunningHandlers = options?.concurrency || 1;\n    const runningHandlers: Set<Promise<void>> = new Set();\n    const waitForOpenSpot = async () => {\n      // wait for an open spot if the max amount of running handlers is reached\n      if (runningHandlers.size >= maxRunningHandlers) {\n        await Promise.race(runningHandlers);\n      }\n    };\n    const addToRunningHandlersList = (\n      handlerPossiblePromise: Promise<void>\n    ) => {\n      // add it to the running handlers list\n      runningHandlers.add(handlerPossiblePromise);\n      handlerPossiblePromise.finally(() => {\n        runningHandlers.delete(handlerPossiblePromise);\n      });\n    };\n    /** Make sure the handler is wrapped in try/catch in order to send the right signals to the\n     * input iterator in case something goes wrong!\n     */\n    const tryHandler = (v: T) => {\n      try {\n        const handlerPossiblePromise = handler(v);\n        if (isPromise(handlerPossiblePromise)) {\n          handlerPossiblePromise.catch((e) => {\n            if (throwCount< 1) {\n              try {\n                it.throw?.(e);\n              } catch (throwErr) { // native implementation crashes?\n                // console.log(v, 'ERROR WHILE THROWING', throwErr);\n              }\n              throwCount += 1;\n            }\n          });\n        }\n        return handlerPossiblePromise;\n      } catch (e) {\n        if (throwCount< 1) {\n          try {\n            it.throw?.(e);\n          } catch (throwErr) { // native implementation crashes?\n            // console.log(v, 'ERROR WHILE THROWING', throwErr);\n          }\n          throwCount += 1;\n        }\n        throw e;\n      }\n    };\n\n    const nextPromiseOrValue = it.next();\n    if (isPromise(nextPromiseOrValue)) {\n      const nextPromise = nextPromiseOrValue;\n\n      const handleNext = async (nextValue) => {\n        await waitForOpenSpot();\n\n        const handlerPossiblePromise = tryHandler(nextValue);\n\n        if (isPromise(handlerPossiblePromise)) {\n          addToRunningHandlersList(handlerPossiblePromise);\n        }\n      };\n      return (async () => {\n        let next = (await nextPromise) as IteratorResult<any>;\n        while (!next.done) {\n          await handleNext(next.value);\n          next = await it.next();\n        }\n        // wait until all remaining handlers are done before resolving the current promise!\n        await Promise.all(runningHandlers);\n        it.return?.(next.value);\n      })();\n    } else {\n      let next = nextPromiseOrValue;\n      if (next.done) {\n        it.return?.(next.value);\n      } else {\n        const handlerPossiblePromise: Promise<void> | void = tryHandler(\n          next.value\n        );\n        if (isPromise(handlerPossiblePromise)) {\n          return (async () => {\n            let handlerPossiblePromiseIn: Promise<void> | undefined =\n              handlerPossiblePromise;\n            while (!next.done) {\n              const handlerPromise =\n                handlerPossiblePromiseIn /* only the very first time */ ||\n                (tryHandler(next.value) as Promise<void>);\n              handlerPossiblePromiseIn = undefined;\n\n              addToRunningHandlersList(handlerPromise);\n\n              next = it.next();\n              await waitForOpenSpot();\n            }\n            // wait until all remaining handlers are done before resolving the current promise!\n            await Promise.all(runningHandlers);\n            it.return?.(next.value);\n          })();\n        } else {\n          next = it.next();\n          while (!next.done) {\n            tryHandler(next.value);\n            next = it.next();\n            // console.log('[forEach] next', next);\n          }\n          it.return?.(next.value);\n        }\n      }\n    }\n  };\n};\n\nexport { forEach };\n", "import { TPipeable } from \"../types.js\";\n\n/**\n * @deprecated Use the pipe(...) and compose(...) functions, so we can leave the\n * iterators alone. No need to 'wrap' anything just to make it work with this library!\n *\n * = DEPRECATED (will be removed in a future version !!!) =\n * This will wrap the sync or async iterator and adds:\n *  * a pipe(operator) function to allow for easy composition of transIt operators\n *    to an iterable\n *\n * We often need to read backwards (first filter, then map) due to the current lack of\n * a |> operator in Javascript/Typescript.\n * ```typescript\n *    map(mapFn)(\n *      filter(filterFn)(\n *        iterator\n *      )\n *    )\n * ```\n * but due to the pipe function this would become\n * ```typescript\n *    itr8FromIterator(iterator).pipe(\n *      filter(filterFn),\n *      map(mapFn),\n *    )\n * ```\n * which is closer to the even more readable (future?) syntax:\n * ```typescript\n *    iterator\n *      |> filter(filterFn)`\n *      |> map(mapFn)\n * ```\n *\n * @param iterator\n * @returns an iterator augmented with a useful pipe function\n *\n * @category interface/standard\n */\nfunction itr8FromIterator<\n  PTIterator extends Iterator<any> | AsyncIterator<any>\n>(iterator: PTIterator): TPipeable & PTIterator {\n  const retVal = iterator as TPipeable & PTIterator;\n  /**\n   * @deprecated Use the simple pipe(...) and compose(...) functions instead !!!\n   *\n   * @param fn1\n   * @param moreFns\n   * @returns\n   */\n  retVal.pipe = <A = any, B = any>(\n    fn1: (a: Iterator<A> | AsyncIterator<A>) => B,\n    ...moreFns: Array<(unknown) => unknown>\n  ) => {\n    // return compose(fn1, ...moreFns)(iterator);\n    // return pipe(iterator, fn1, moreFns);\n    return moreFns.reduce((prev, cur) => cur(prev), fn1(iterator));\n  };\n  return retVal;\n}\n\nexport {\n  itr8FromIterator, // used to be called 'itr8Proxy'\n};\n", "import { TPipeable } from \"../types.js\";\nimport { itr8FromIterator } from \"./itr8FromIterator.js\";\n\n/**\n * Turns an array into an Iterator\n * (itr8FromIterable is more generic, this one is mainly useful for writing tests together\n * with its async brother itr8FromArrayAsync).\n *\n * @param a an array\n * @returns an iterator\n *\n * @category interface/standard\n */\nfunction itr8FromArray<T>(a: Array<T>): TPipeable & IterableIterator<T> {\n  return itr8FromIterator(a[Symbol.iterator]());\n}\n\nexport { itr8FromArray };\n", "import { TPipeable } from \"../types.js\";\nimport { itr8FromIterator } from \"./itr8FromIterator.js\";\n\n/**\n * Turns an array into an (async) Iterator. Mainly useful for testing.\n *\n * @param a an array\n * @returns an async iterator\n *\n * @category interface/standard\n */\nfunction itr8FromArrayAsync<T>(\n  a: Array<T>\n): TPipeable & AsyncIterableIterator<T> {\n  return itr8FromIterator(\n    (async function* () {\n      for (const x of a) {\n        yield x;\n      }\n    })()\n  );\n}\n\nexport { itr8FromArrayAsync };\n", "import { TPipeable } from \"../types.js\";\nimport { itr8FromIterator } from \"./itr8FromIterator.js\";\n\n/**\n * Gets a wrapped instance of the iterator OR the async iterator from any iterable (including arrays)\n * so that we can easily pipe it into the operators.\n *\n * @example\n * ```typescript\n * pipe(\n *    itr8FromIterable([1,2,3]),\n *    map((x) => x + 100),\n *  )\n * ```\n *\n * @category interface/standard\n */\nfunction itr8FromIterable<T>(\n  it: Iterable<T> | AsyncIterable<T>\n): TPipeable & (IterableIterator<T> | AsyncIterableIterator<T>) {\n  if (it[Symbol.iterator]) {\n    return itr8FromIterator(it[Symbol.iterator]());\n  } else {\n    return itr8FromIterator(it[Symbol.asyncIterator]());\n  }\n}\n\nexport { itr8FromIterable };\n", "import { TPipeable } from \"../types.js\";\nimport { itr8FromIterator } from \"./itr8FromIterator.js\";\n\n/**\n * Turns a single value into an Iterator that will produce 1 result.\n * Should work for boolean, number, string, object, ...\n *\n * @param a anything like object, string, number, ...\n * @returns an iterator\n *\n * @category interface/standard\n */\nfunction itr8FromSingleValue<T>(v: any): TPipeable & IterableIterator<T> {\n  return itr8FromIterator(\n    (function* () {\n      yield v;\n    })()\n  );\n}\n\nexport { itr8FromSingleValue };\n", "import { TPipeable } from \"../types.js\";\nimport { itr8FromIterator } from \"./itr8FromIterator.js\";\n\n/**\n * Turns a single value into an (async) Iterator that will produce 1 result.\n * Should work for boolean, number, string, object, ...\n *\n * @param a anything like object, string, number, ...\n * @returns an iterator\n *\n * @category interface/standard\n */\nfunction itr8FromSingleValueAsync<T>(\n  v: any\n): TPipeable & AsyncIterableIterator<T> {\n  return itr8FromIterator(\n    (async function* () {\n      yield v;\n    })()\n  );\n}\n\nexport { itr8FromSingleValueAsync };\n", "import { TPipeable } from \"../types.js\";\nimport { itr8FromIterable } from \"./itr8FromIterable.js\";\n\n/**\n * Turns a string into an Iterator that outputs every character of the string separately.\n *\n * (but since a string is an Iterable, you can use itr8FromIterable on strings as well!)\n *\n * @param s string\n * @returns an iterator\n *\n * @category interface/standard\n */\nfunction itr8FromString(s: string): TPipeable & IterableIterator<string> {\n  return itr8FromIterable(s) as TPipeable & IterableIterator<string>;\n}\n\nexport { itr8FromString };\n", "import { TPipeable } from \"../types.js\";\nimport { itr8FromIterator } from \"./itr8FromIterator.js\";\n\n/**\n * Turns a string into an (async) Iterator that outputs every character of\n * the string separately.\n *\n * @param s a string\n * @returns an iterator\n *\n * @category interface/standard\n */\nfunction itr8FromStringAsync(\n  s: string\n): TPipeable & AsyncIterableIterator<string> {\n  return itr8FromIterator(\n    (async function* () {\n      for (const x of s) {\n        yield x;\n      }\n    })()\n  );\n}\n\nexport { itr8FromStringAsync };\n", "import { TPipeable, TPushable } from \"../types.js\";\nimport { itr8FromIterator } from \"./itr8FromIterator.js\";\n\n/**\n * Creates an AsyncIterableIterator, that also exposes\n * * a push(...) method that can be used to push values into it (for example based on events).\n * * a done() method that can be used to indicate that no more values will follow.\n *\n * The optional bufferSize parameter defines how large the buffer is that will hold the\n * messages until they are pulled by a next() call. The oldest messages will be\n * dropped if no one is consuming the iterator fast enough.\n *\n * If no bufferSize is specified, the buffer will keep growing indefinitely.\n *\n * @param observable\n * @returns\n *\n * @category interface/standard\n */\nfunction itr8Pushable<T>(\n  bufferSize?: number\n): TPipeable & AsyncIterableIterator<T> & TPushable {\n  const buffer: any[] = [];\n\n  let currentResolve;\n  // let currentReject;\n  let currentDataPromise;\n  // let done = false;\n\n  const createNewCurrentDataPromise = () => {\n    currentDataPromise = new Promise((resolve /*, reject */) => {\n      currentResolve = resolve;\n      // currentReject = reject;\n    });\n    buffer.push(currentDataPromise);\n    while (bufferSize !== undefined && buffer.length > bufferSize + 1) {\n      // remove the oldest one from the buffer\n      buffer.shift();\n    }\n  };\n\n  createNewCurrentDataPromise();\n\n  const retVal = {\n    [Symbol.asyncIterator]: () => retVal,\n    next: async () => {\n      // if (done) {\n      //   return { done: true };\n      // }\n      if (buffer.length > 0) {\n        // const [firstOfBufferPromise, ...restOfBuffer] = buffer;\n        // buffer = restOfBuffer;\n        const firstOfBufferPromise = buffer.shift();\n        const asyncNext = await firstOfBufferPromise;\n        return asyncNext;\n      } else {\n        throw new Error(\"[itr8FromObservable] No elements in the buffer?\");\n      }\n    },\n    push: (value: T) => {\n      currentResolve({ value });\n      createNewCurrentDataPromise();\n    },\n    done: () => {\n      currentResolve({ done: true });\n      createNewCurrentDataPromise();\n      // done = true;\n    },\n  };\n\n  return itr8FromIterator(retVal as AsyncIterableIterator<T>) as TPipeable &\n    AsyncIterableIterator<T> & { push: (T) => void; done: () => void };\n}\n\nexport { itr8Pushable };\n", "import { TPipeable, TPushable } from \"../types.js\";\nimport { itr8Pushable } from \"./itr8Pushable.js\";\n\n/**\n * Returns a (pushable async) iterator that will automatically fire with the Date.now() value\n * of when it fired (= the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC).\n *\n * When you want it to stop, call the done() method of the returned iterator, and the interval\n * will be cleaned up.\n *\n * @param intervalMilliseconds\n * @returns an AsyncIterableIterator\n *\n * @category interface/standard\n */\nfunction itr8Interval(\n  intervalMilliseconds: number\n): TPipeable & AsyncIterableIterator<number> & TPushable {\n  const it = itr8Pushable<number>(Infinity); // infinite buffer !!!\n  const interval = setInterval(() => {\n    it.push(Date.now());\n  }, intervalMilliseconds);\n  const origDone = it.done;\n  it.done = () => {\n    clearInterval(interval);\n    return origDone();\n  };\n  return it;\n}\n\nexport { itr8Interval };\n", "import { TPipeable } from \"../types.js\";\nimport { itr8FromIterator } from \"./itr8FromIterator.js\";\n\n/**\n * Utility function that produces an iterator producing numbers (not only integers)\n * starting and ending where you want, which is useful for trying out stuff\n * without manually having to create arrays.\n *\n * * 'from' can be higher than 'to', in which case the iterator will count down\n * * 'step' is always a positive number (but we are forgiving if it's not)\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8Range(0, 3)\n *      itr8ToArray,\n *    ) // => [0, 1, 2, 3]\n *\n *    pipe(\n *      itr8Range(0, 10, 3)\n *      itr8ToArray,\n *    ) // => [0, 3, 6, 9]\n *\n *    pipe(\n *      itr8Range(5, 1, 2)\n *      itr8ToArray,\n *    ) // => [5, 3, 1]\n * ```\n *\n * @param start start index\n * @param end end index\n * @param end step size, default = 1\n *\n * @category interface/standard\n */\nfunction itr8Range(\n  from: number,\n  to: number,\n  step?: number\n): TPipeable & IterableIterator<number> {\n  const stepValue = step !== undefined ? Math.abs(step) : 1;\n  const upwards = from < to;\n  return itr8FromIterator(\n    (function* () {\n      if (upwards) {\n        for (let i = from; i <= to; i = i + stepValue) {\n          yield i;\n        }\n      } else {\n        for (let i = from; i >= to; i = i - stepValue) {\n          yield i;\n        }\n      }\n    })()\n  );\n}\n\nexport { itr8Range };\n", "import { TPipeable } from \"../types.js\";\nimport { itr8FromIterator } from \"./itr8FromIterator.js\";\n\n/**\n * Utility function that produces an (async) iterator\n * producing integers starting and ending where you want,\n * which is useful for trying out stuff without manually\n * having to create arrays.\n *\n * * 'from' can be higher than 'to', in which case the iterator will count down\n * * 'step' is always a positive number (but we are forgiving if it's not)\n *\n * @param start start index\n * @param end end index\n * @param end step size, default = 1\n *\n * @category interface/standard\n */\nfunction itr8RangeAsync(\n  from: number,\n  to: number,\n  step?: number\n): TPipeable & AsyncIterableIterator<number> {\n  const stepValue = step !== undefined ? Math.abs(step) : 1;\n  const upwards = from < to;\n  return itr8FromIterator(\n    (async function* () {\n      if (upwards) {\n        for (let i = from; i <= to; i = i + stepValue) {\n          yield i;\n        }\n      } else {\n        for (let i = from; i >= to; i = i - stepValue) {\n          yield i;\n        }\n      }\n    })()\n  );\n}\n\nexport { itr8RangeAsync };\n", "import { isPromise } from \"../util/index.js\";\n\n/**\n * Turns an itr8 into an array.\n *\n * @param iterator\n * @returns an array\n *\n * @category interface/standard\n */\nfunction itr8ToArray<T>(\n  iterator: Iterator<T> | AsyncIterator<T>\n): Array<T | any> | Promise<Array<T | any>> {\n  let n = iterator.next();\n  if (isPromise(n)) {\n    return (async () => {\n      const asyncResult: T[] = [];\n      while (!(await n).done) {\n        asyncResult.push((await n).value);\n        n = iterator.next();\n      }\n      return asyncResult;\n    })();\n  } else {\n    // return Array.from(iterator);\n    const result: T[] = [];\n    let nSync = n as IteratorResult<T>;\n    while (!nSync.done) {\n      result.push(nSync.value);\n      nSync = iterator.next() as IteratorResult<T>;\n    }\n    return result;\n  }\n}\n\nexport { itr8ToArray };\n", "import { isPromise } from \"../util/index.js\";\n\n/**\n * Turns an itr8 into an object. It is like Object.fromEntries,\n * but it will work both for synchronous and asynchronous iterators\n *\n * @example\n * ```typescript\n *  // synchronous, same as Object.fromEntries(...)\n *  const myObj = pipe(\n *      itr8FromIterable([['a', 'value of A'], ['b', 'value of B'], ['c', 'value of C']]),\n *      itr8ToObject,\n *    ) // => {\n *      //      a: 'value of A',\n *      //      b: 'value of B',\n *      //      c: 'value of C',\n *      // }\n *\n *  // asynchronous\n *  await myObj2 = pipe(\n *      itr8FromIterable([['a', 'value of A'], ['b', 'value of B'], ['c', 'value of C']]),\n *      delay(100),     // delay every element by 100 milliseconds\n *      itr8ToObject,\n *    ) // => {\n *      //      a: 'value of A',\n *      //      b: 'value of B',\n *      //      c: 'value of C',\n *      // }\n * ```\n *\n * @param iterator\n * @returns an array\n *\n * @category interface/standard\n */\nfunction itr8ToObject<TK extends string | number | symbol, TV>(\n  iterator:\n    | Iterator<[TK: string | number | symbol, TV: unknown]>\n    | AsyncIterator<[TK: string | number | symbol, TV: any]>\n): Record<TK, TV> | Promise<Record<TK, TV>> {\n  let n = iterator.next();\n  if (isPromise(n)) {\n    return (async () => {\n      const asyncResult: Record<TK, TV> = {} as Record<TK, TV>;\n      while (!(await n).done) {\n        const [k, v] = (await n).value;\n        asyncResult[k] = v;\n        n = iterator.next();\n      }\n      return asyncResult;\n    })();\n  } else {\n    // return Array.from(iterator);\n    const result: Record<TK, TV> = {} as Record<TK, TV>;\n    let nSync = n as IteratorResult<[TK, TV]>;\n    while (!nSync.done) {\n      const [k, v] = nSync.value;\n      result[k] = v;\n      nSync = iterator.next() as IteratorResult<[TK, TV]>;\n    }\n    return result;\n  }\n}\n\nexport { itr8ToObject };\n", "import { isPromise } from \"../util/index.js\";\nimport { forEach } from \"./forEach.js\";\n\n/**\n * Turns an iterator into a single string.\n * The strings will simply be 'glued' together, so if you need a separator,\n * use interperse first.\n *\n * It is the equivalent of Array.join('').\n *\n * @example\n * ```typescript\n *  pipe(\n *    itr8FromArray(['Hello', 'Goodbye']),\n *    intersperse(' / '), // adds | between every 2 elements\n *    itr8ToString,\n *  ) // => 'Hello / Goodbye'\n *\n *  const alphabet = pipe(\n *    itr8Range(0, 25),\n *    map((i: number) => String.fromCharCode(\"A\".charCodeAt(0) + i)),\n *    itr8ToString\n *  ); // => 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n * ```\n *\n * @param iterator\n * @returns a string\n *\n * @category interface/standard\n */\nfunction itr8ToString<T>(\n  iterator: Iterator<T> | AsyncIterator<T>\n): string | Promise<string> {\n  let n = iterator.next();\n  if (isPromise(n)) {\n    return (async () => {\n      let asyncResult = \"\";\n      while (!(await n).done) {\n        asyncResult = asyncResult + (await n).value;\n        n = iterator.next();\n      }\n      return asyncResult;\n    })();\n  } else {\n    // return Array.from(iterator);\n    let result = \"\";\n    let nSync = n as IteratorResult<T>;\n    while (!nSync.done) {\n      result = result + nSync.value;\n      nSync = iterator.next() as IteratorResult<T>;\n    }\n    return result;\n  }\n}\n\nexport { itr8ToString };\n", "import { itr8FromIterable, itr8FromIterator } from \"../../interface/index.js\";\nimport {\n  TNextFnResult,\n  TPipeable,\n  TTransIteratorSyncOrAsync,\n} from \"../../types.js\";\nimport { forLoop, isPromise, thenable } from \"../../util/index.js\";\n\n/**\n * The powerMap can be used as the base for many many other operators.\n *\n * An operator is 'a function that generates a transIterator'.\n * So for example filter(...) is an operator, because when called with an argument\n * (the filter function) the result of that will be another function which is the transIterator.\n *\n * A transIterator is simply a function with an iterator as single argument which will return\n * another iterator. This way we can easily 'build a chain of mulitple transIterators'.\n * So it transforms iterators, which is why I have called it transIterator (~transducers).\n *\n * powerMap is an operator that generates a transIterator that\n * will work both on synchronous and asynchronous iterators.\n * The powerMap needs to be provided with a single function of the form:\n *\n * ```typescript\n * (nextOfPreviousIteratorInTheChain, state) => TNextFnResult | Promise<[TNextFnResult]>\n * ```\n * and another function generating an initial 'state' (not every operator needs state)\n *\n * * *nextIn* is the (resolved if async) result of a next call of the input iterator.\n *   This means it will be of the form ```{ done: true }``` or ```{ done: false, value: <...> }```.\n * * The *state* parameter is used to allow operators to have state, but not all operators need this.\n *   For example: a 'map' operator doesn't need state, but the 'skip' operator would need to keep\n *   track of how many records have passed.\n *\n * Check the readme for some examples on how to write your own operators using 'powerMap'\n * (or check the source code as all the available operators have been built using this function).\n *\n * BEWARE: NEVER MODIFY THE STATE OBJECT (or any of its children!), ALWAYS RETURN A NEW VALUE!\n *\n * Why is the initial state not a simple value, but a function that produces the state?\n *  This way, even if nextFn would modify the state, it wouldn't mess with other instances\n *  of the same operator? Because if we'd like to deep clone the initial state ourselves, we might\n *  end up with some complex cases when classes are involved (I hope no one who's interested in\n *  this library will want to use classes as their state, because the library is more 'functional\n *  programming' oriented)\n *\n * @typeParam TIn the type of values that the input iterator must produce\n * @typeParam TOut the type of values that the output iterator will produce\n * @typeParam TState the type of the state that will be passed between all iterations\n *\n * @param nextFn\n * @param initialStateFactory a function that generates the initialSate\n * @returns a fucntion taking an iterator as input and that has an iterator as output\n *\n * @category operators/general\n */\nconst powerMap = function <TIn = unknown, TOut = unknown, TState = void>(\n  nextFn: (\n    nextIn: IteratorResult<TIn>,\n    state: TState\n  ) => TNextFnResult<TOut, TState> | Promise<TNextFnResult<TOut, TState>>,\n  initialStateFactory: () => TState\n): TTransIteratorSyncOrAsync<TIn, TOut> {\n  type TOperatorState = {\n    state: TState;\n    currentOutputIterator: Iterator<TOut> | AsyncIterator<TOut> | undefined;\n    /** Means that we are done after this value or after finishing the currentOutputIterator */\n    isLastOutputIterator: boolean;\n    /** Means that we are done entirely */\n    done: boolean;\n  };\n\n  const operatorFunction = (\n    itIn: Iterator<TIn> | AsyncIterator<TIn>,\n    pState: TState\n  ) => {\n    const operatorState: TOperatorState = {\n      state: pState,\n      currentOutputIterator: undefined,\n      isLastOutputIterator: false,\n      done: false,\n    };\n\n    let nextInPromiseOrValue:\n      | IteratorResult<TIn>\n      | Promise<IteratorResult<TIn>>\n      | undefined = undefined;\n    // let nextIn: IteratorResult<TIn> | undefined = undefined;\n    let isAsyncInput: boolean | undefined = undefined;\n    function updateNextInPromiseOrValue() {\n      nextInPromiseOrValue = itIn.next();\n      if (isAsyncInput === undefined)\n        isAsyncInput = isPromise(nextInPromiseOrValue);\n    }\n    let isAsyncNextFn: boolean | undefined = undefined;\n    // let state = pState;\n\n    // let currentOutputIterator: Iterator<TOut> | AsyncIterator<TOut> | undefined = undefined;\n    let isAsyncCurrentOutputIterator: boolean | undefined = undefined;\n    // let done = false;\n\n    /**\n     * Can/should we make this kind of recursive?\n     * Figure out based on the input params whether we need to:\n     *  * return done because done = true\n     *  * return the next value of the current iterator\n     *    or empty the current iterator if we're at the end and call generateNextReturnVal\n     *  * do a call to nextFn\n     *    * if next = async, call generateNextReturnValAsync to handle this case\n     *    * set done to true if that is what it returns and call generateNextReturnVal\n     *    * return the value if it returns a value\n     *    * set current iterator if it returns an iterable and call generateNextReturnVal\n     * @returns\n     */\n    const generateNextReturnValSync = ():\n      | IteratorResult<TOut>\n      | Promise<IteratorResult<TOut>> => {\n      // while loop instead of calling this function recursively (call stack can become too large)\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if (operatorState.done) {\n          return { value: undefined, done: true };\n        }\n        // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n        if (operatorState.currentOutputIterator) {\n          const possibleNextValueOrPromise =\n            operatorState.currentOutputIterator.next();\n          if (\n            isAsyncCurrentOutputIterator ||\n            isPromise(possibleNextValueOrPromise)\n          ) {\n            isAsyncCurrentOutputIterator = true;\n            return generateNextReturnValAsync(\n              true,\n              undefined,\n              possibleNextValueOrPromise\n            );\n          }\n          const possibleNext =\n            possibleNextValueOrPromise as IteratorResult<TOut>;\n\n          if (possibleNext.done) {\n            operatorState.currentOutputIterator = undefined;\n            if (operatorState.isLastOutputIterator) {\n              operatorState.done = true;\n              return { done: true, value: undefined };\n            }\n          } else {\n            return possibleNext;\n          }\n        }\n\n        // no running iterator, so we need to call nextFn again\n        updateNextInPromiseOrValue();\n        if (isAsyncInput) {\n          return generateNextReturnValAsync(false);\n        }\n        const nextIn = nextInPromiseOrValue as IteratorResult<TIn>;\n        const curNextFnResult = nextFn(\n          nextIn as IteratorResult<TIn>,\n          operatorState.state\n        ) as TNextFnResult<TOut, TState>;\n        if (isAsyncNextFn === undefined)\n          isAsyncNextFn = isPromise(curNextFnResult);\n        if (isAsyncNextFn) {\n          return generateNextReturnValAsync(false, curNextFnResult);\n        }\n        if (\"state\" in curNextFnResult)\n          operatorState.state = curNextFnResult.state as TState;\n\n        if (curNextFnResult.done) {\n          operatorState.done = true;\n          return { done: true, value: undefined };\n        } else if (\"value\" in curNextFnResult) {\n          if (curNextFnResult.isLast) operatorState.done = true;\n          return { done: false, value: curNextFnResult.value };\n        } else if (\"iterable\" in curNextFnResult) {\n          if (operatorState.currentOutputIterator !== undefined)\n            throw new Error(\n              \"currentOutputIterator should be undefined at this point\"\n            );\n          operatorState.currentOutputIterator = itr8FromIterable(\n            curNextFnResult.iterable\n          );\n          operatorState.isLastOutputIterator = !!curNextFnResult.isLast;\n          if (operatorState.currentOutputIterator?.next === undefined) {\n            throw new Error(\n              \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\"\n            );\n          }\n          // goto next round of while loop\n        } else {\n          // we need to call nextIn again\n          // goto next round of while loop\n        }\n      }\n    };\n\n    /**\n     * Almost the same method but in case input or nextFn is async\n     *\n     * @param callUpdateNextInPromiseOrValue\n     * @returns\n     */\n    const generateNextReturnValAsync = async (\n      callUpdateNextInPromiseOrValue = true,\n      nextFnResponse?,\n      currentOutputIteratorNext?\n    ): Promise<IteratorResult<TOut>> => {\n      let doUpdateNextInPromiseOrValue = callUpdateNextInPromiseOrValue;\n      let alreadyKnownNextFnResponse = nextFnResponse;\n      let alreadyKnownCurrentOutputIteratorNext = currentOutputIteratorNext;\n      // while loop instead of calling this function recursively (call stack can become to large)\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if (operatorState.done) {\n          return { value: undefined, done: true };\n        }\n        // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n        if (operatorState.currentOutputIterator) {\n          let possibleNextValueOrPromise;\n          if (alreadyKnownCurrentOutputIteratorNext !== undefined) {\n            possibleNextValueOrPromise = alreadyKnownCurrentOutputIteratorNext;\n            alreadyKnownCurrentOutputIteratorNext = undefined; // only the first time !!!\n          } else {\n            possibleNextValueOrPromise =\n              operatorState.currentOutputIterator.next();\n          }\n          const possibleNext = (\n            isPromise(possibleNextValueOrPromise)\n              ? await possibleNextValueOrPromise\n              : possibleNextValueOrPromise\n          ) as IteratorResult<TOut>;\n\n          if (possibleNext.done) {\n            operatorState.currentOutputIterator = undefined;\n            if (operatorState.isLastOutputIterator) {\n              operatorState.done = true;\n              return { done: true, value: undefined };\n            }\n          } else {\n            return possibleNext;\n          }\n        }\n\n        // no running iterator, so we need to possibly call nextFn again\n        if (doUpdateNextInPromiseOrValue) {\n          updateNextInPromiseOrValue();\n        } else {\n          doUpdateNextInPromiseOrValue = true; // only possibly skip it the first time !!!\n        }\n        const nextIn = await nextInPromiseOrValue;\n        let curNextFnResultPromiseOrValue;\n        if (alreadyKnownNextFnResponse !== undefined) {\n          curNextFnResultPromiseOrValue = alreadyKnownNextFnResponse;\n          alreadyKnownNextFnResponse = undefined; // only use it the first time !!!\n        } else {\n          curNextFnResultPromiseOrValue = nextFn(\n            nextIn as IteratorResult<TIn>,\n            operatorState.state\n          );\n        }\n        if (isAsyncNextFn === undefined)\n          isAsyncNextFn = isPromise(curNextFnResultPromiseOrValue);\n        const curNextFnResult = (\n          isAsyncNextFn\n            ? await curNextFnResultPromiseOrValue\n            : curNextFnResultPromiseOrValue\n        ) as TNextFnResult<TOut, TState>;\n        if (\"state\" in curNextFnResult)\n          operatorState.state = curNextFnResult.state as TState;\n\n        if (curNextFnResult.done) {\n          operatorState.done = true; // make sure we keep returning done\n          return { done: curNextFnResult.done, value: undefined };\n        } else if (\"value\" in curNextFnResult) {\n          if (curNextFnResult.isLast) operatorState.done = true;\n          return { done: false, value: curNextFnResult.value };\n        } else if (\"iterable\" in curNextFnResult) {\n          if (operatorState.currentOutputIterator !== undefined)\n            throw new Error(\n              \"currentOutputIterator should be undefined at this point\"\n            );\n          operatorState.currentOutputIterator = itr8FromIterable(\n            curNextFnResult.iterable\n          );\n          operatorState.isLastOutputIterator = !!curNextFnResult.isLast;\n          if (operatorState.currentOutputIterator?.next === undefined) {\n            throw new Error(\n              \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\"\n            );\n          }\n          // goto next round of while loop\n          // return generateNextReturnValAsync();\n        } else {\n          // we need to call nextIn again\n          // goto next round of while loop\n          // return generateNextReturnValAsync();\n        }\n      }\n    };\n\n    /**\n     * This method will replace itself with the right method once we know\n     * in which case we are (sync, async)\n     *\n     * @returns {IteratorResult<TOut> | Promise<IteratorResult<TOut>>}\n     */\n    let generateNextReturnVal = ():\n      | IteratorResult<TOut>\n      | Promise<IteratorResult<TOut>> => {\n      if (isAsyncInput || isAsyncNextFn) {\n        generateNextReturnVal = generateNextReturnValAsync;\n      } else {\n        generateNextReturnVal = generateNextReturnValSync;\n      }\n\n      return generateNextReturnVal();\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Here is the returned TPipeable & IterableIterator\n    ////////////////////////////////////////////////////////////////////////////////\n    const retVal = {\n      // return the current (async?) iterator to make it an iterable iterator (so we can use for ... of)\n      // since we can only know whether the output will be sync or async after the first next call,\n      // we'll expose both iterator and asynciterator functions...\n      [Symbol.iterator]: () => retVal,\n      [Symbol.asyncIterator]: () => retVal,\n      // pipe: (op:TTransIteratorSyncOrAsync) => op(retVal as Iterator<TOut>),\n      next: ():\n        | IteratorResult<TOut>\n        | Promise<IteratorResult<TOut>>\n        | IteratorResult<TOut[]>\n        | Promise<IteratorResult<TOut[]>> => {\n        return generateNextReturnVal();\n      },\n    };\n\n    return itr8FromIterator(\n      retVal as IterableIterator<TOut> | AsyncIterableIterator<TOut>\n    );\n  };\n\n  const transIt = (\n    itIn: Iterator<TIn> | AsyncIterator<TIn>\n  ): TPipeable<TIn, TOut> &\n    (IterableIterator<TOut> | AsyncIterableIterator<TOut>) =>\n    operatorFunction(itIn, initialStateFactory());\n\n  /**\n   * Experiment: we could expose the \"transNextFn\" which is similar to a transducer:\n   * it is a function that transforms an existing nextFn, and by linking them all together\n   * we'll get a nextFn that combines multiple oeprations meaning we only need one 'intermediate'\n   * iterator. This might be more performant.\n   * But that can only be done if input and output match so they can be composed.\n   *\n   * So instead of getting (nextIn, state, params) as input (without the state) and\n   * TNextFnResult as output (without the state as well) we could create a function that\n   * gets TNextFnResult as input as well (or at least a subset of all the possibilities).\n   *\n   * By subset I mean: maybe only when they have a value or an iterable, and not when they\n   * have no value (meaning the element is skipped).\n   */\n  transIt.transNextFn = (\n    input: TNextFnResult<TIn, undefined>\n  ): TNextFnResult<TOut, undefined> => {\n    const operatorState: TOperatorState = {\n      state: initialStateFactory(),\n      currentOutputIterator: undefined,\n      isLastOutputIterator: false,\n      done: false,\n    };\n\n    if (input.done === true) {\n      return input;\n    } else if (/* input.done === false && */ \"iterable\" in input) {\n      const iterator =\n        input.iterable[Symbol.iterator] || input.iterable[Symbol.asyncIterator];\n      const iterable: TOut[] = [];\n      const f = forLoop(\n        () => iterator.next(),\n        (n) => n.done !== true,\n        (n) => iterator.next(),\n        (nextIn) => {\n          thenable(\n            nextFn(nextIn as IteratorResult<TIn>, operatorState.state)\n          ).then((curNextFnResult) => {\n            // store the new state\n            operatorState.state = curNextFnResult.state;\n\n            // if it contains an iterable => iterate over it, otherwise add the value to the output array\n            if (curNextFnResult.done === false && curNextFnResult.iterable) {\n              // TODO support async iterable !!!\n              iterable.push(...curNextFnResult.iterable);\n            } else {\n              iterable.push(curNextFnResult.value);\n            }\n          }).src;\n        }\n      );\n      return thenable(f).then((_forLoopResult) => {\n        return { done: false, iterable };\n      }).src;\n    } else if (/* input.done === false && */ \"value\" in input) {\n      return thenable(\n        nextFn(input as IteratorResult<TIn>, operatorState.state)\n      ).then((curNextFnResult) => {\n        const { newState, ...retVal } = curNextFnResult;\n        // store the new state\n        operatorState.state = curNextFnResult.state;\n        return retVal;\n\n        // // if it contains an iterable => iterate over it, otherwise add the value to the output array\n        // if (curNextFnResult.done === true) {\n        //   return { done: true };\n        // } else if (/* curNextFnResult.done === false && */ curNextFnResult.iterable) {\n        //   // TODO support async iterable !!!\n        //   return { done: false, iterable: curNextFnResult.iterable };\n        // } else if (curNextFnResult.value) {\n        //   return { done: false, value: curNextFnResult.value };\n        // }\n      }).src;\n    } else {\n      // no value nor iterable in input, meaning this element should be skipped\n      // so don't call any other transformers on this element\n      return input;\n    }\n  };\n\n  return transIt;\n};\n\n/**\n * EXPERIMENTAL VERSION OF THIS FUNCTION written with forLoop and thenable, which might be easier\n * to read or maintain, and could be faster...\n *\n * An operator is 'a function that generates a transIterator'.\n * So for example filter(...) is an operator, because when called with an argument\n * (the filter function) the result of that will be another function which is the transIterator.\n *\n * A transIterator is simply a function with an iterator as single argument which will return\n * another iterator. This way we can easily 'build a chain of mulitple transIterators'.\n * So it transforms iterators, which is why I have called it transIterator (~transducers).\n *\n * powerMap is a function that generates a transIteratorthat\n * will work both on synchronous and asynchronous iterators.\n * The factory needs to be provided with a single function of the form:\n *\n * ```typescript\n * (nextOfPreviousIteratorInTheChain, state) => TNextFnResult | Promise<[TNextFnResult]>\n * ```\n * and an initial state\n *\n * * nextOfPreviousIteratorInTheChain is the (resolved if async) result of a next call of the input\n *   iterator. This means it will be of the form { done: true } or { done: false, value: <...> }.\n * * The state parameter is used to allow operators to have state, but not all operators need this.\n *   For example: a 'map' operator doesn't need state, but the 'skip' operator would need to keep\n * track of how many records have passed.\n * * The operator params are the argument that is given to the operator function, like a number for\n *   a 'take' operator, or the filter function for a 'filter' operator.\n *\n * Check the readme for some examples on how to write your own operators with powerMap\n * (or check the source code as all the available operators have been built using this function).\n *\n * BEWARE: NEVER MODIFY THE STATE OBJECT (or any of its children!), ALWAYS RETURN A NEW VALUE!\n *\n * QUESTION: would it be better to have an initial state producing function instead of an initial\n *  state?\n *  This way, even if nextFn would modify the state, it wouldn't mess with other instances\n *  of the same operator? Because if we'd like to deep clone the initial state ourselves, we might\n *  end up with some complex cases when classes are involved (I hope no one who's interested in\n *  this library will want to use classes in their state, because the library is more 'functional\n *  programming' oriented)\n *\n * @param nextFn\n * @param initialStateFactory a function that generates the initialSate\n * @returns a funtion taking an iterator (and optionally some argument) as input and that has an iterator as output\n *\n * @category util\n */\n// const itr8OperatorFactoryWithForLoop = function <TIn = any, TOut = any, TParams = any, TState = any>(\n//   nextFn: (nextIn: IteratorResult<TIn>, state: any, params: any) =>\n//     TNextFnResult<TOut, TState> | Promise<TNextFnResult<TOut, TState>>,\n//   initialStateFactory: () => TState,\n// ): (params: TParams) => TTransIteratorSyncOrAsync<TIn, TOut> {\n//   return function (params: TParams): TTransIteratorSyncOrAsync<TIn, TOut> {\n//     const operatorFunction = (itIn: Iterator<TIn> | AsyncIterator<TIn>, pState: TState) => {\n//       type TOperatorFactoryState = {\n//         state:TState,\n//         currentOutputIterator:Iterator<TOut> | AsyncIterator<TOut> | undefined,\n//         done:boolean,\n//       };\n\n//       const operatorFactoryState:TOperatorFactoryState = {\n//         state: pState,\n//         currentOutputIterator: undefined,\n//         done: false,\n//       };\n//       // let nextInPromiseOrValue: IteratorResult<TIn> | Promise<IteratorResult<TIn>> | undefined = undefined;\n//       // // let nextIn: IteratorResult<TIn> | undefined = undefined;\n//       // let isAsyncInput: boolean | undefined = undefined;\n//       // function updateNextInPromiseOrValue() {\n//       //   nextInPromiseOrValue = itIn.next();\n//       //   if (isAsyncInput === undefined) isAsyncInput = isPromise(nextInPromiseOrValue);\n//       // }\n//       // let isAsyncNextFn: boolean | undefined = undefined;\n//       // // let state = pState !== undefined ? pState : initialState;\n//       // let state = pState;\n\n//       // let currentOutputIterator: Iterator<TOut> | AsyncIterator<TOut> | undefined = undefined;\n//       // // let isAsyncCurrentOutputIterator:boolean | undefined = undefined;\n//       // let done = false;\n\n//       /**\n//        * Can/should we make this kind of recursive?\n//        * Figure out based on the input params whether we need to:\n//        *  * return done because done = true\n//        *  * return the next value of the current iterator\n//        *    or empty the current iterator if we're at the end and call generateNextReturnVal\n//        *  * do a call to nextFn\n//        *    * if next = async, call generateNextReturnValAsync to handle this case\n//        *    * set done to true if that is what it returns and call generateNextReturnVal\n//        *    * return the value if it returns a value\n//        *    * set current iterator if it returns an iterable and call generateNextReturnVal\n//        * @returns\n//        */\n//       const generateNextReturnVal = () => {\n\n//         forLoop<TOperatorFactoryState & { next?:IteratorResult<TOut>| undefined }>(\n//           () => (operatorFactoryState),\n//           ({next}) => next !== undefined,\n//           (state) => {\n//             if (state.done) {\n//               return { value: undefined, done: true };\n//             }\n//             // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n//             if (state.currentOutputIterator !== undefined) {\n//               return thenable(state.currentOutputIterator.next())\n//               .then((v) => {\n\n//               })\n//               if (isPromise(possibleNextValueOrPromise)) {\n//                 return generateNextReturnValAsync(true, undefined, possibleNextValueOrPromise);\n//               }\n//               const possibleNext = possibleNextValueOrPromise as IteratorResult<TOut>;\n\n//               if (possibleNext.done) {\n//                 currentOutputIterator = undefined;\n//               } else {\n//                 return possibleNext;\n//               }\n//             }\n\n//             return state;\n//           },\n//           () => {}\n//         );\n//         // while loop instead of calling this function recursively (call stack can become too large)\n//         while (true) {\n//           if (done) {\n//             return { value: undefined, done: true };\n//           }\n//           // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n//           if (currentOutputIterator) {\n//             const possibleNextValueOrPromise = currentOutputIterator.next();\n//             if (isPromise(possibleNextValueOrPromise)) {\n//               return generateNextReturnValAsync(true, undefined, possibleNextValueOrPromise);\n//             }\n//             const possibleNext = possibleNextValueOrPromise as IteratorResult<TOut>;\n\n//             if (possibleNext.done) {\n//               currentOutputIterator = undefined;\n//             } else {\n//               return possibleNext;\n//             }\n//           }\n\n//           // no running iterator, so we need to call nextFn again\n//           updateNextInPromiseOrValue();\n//           if (isAsyncInput) {\n//             return generateNextReturnValAsync(false);\n//           }\n//           const nextIn = nextInPromiseOrValue as IteratorResult<any>;\n//           const curNextFnResult = nextFn(nextIn as IteratorResult<TIn>, state, params) as TNextFnResult<TOut, TState>;\n//           if (isAsyncNextFn === undefined) isAsyncNextFn = isPromise(curNextFnResult);\n//           if (isAsyncNextFn) {\n//             return generateNextReturnValAsync(false, curNextFnResult);\n//           }\n//           if ('state' in curNextFnResult) state = curNextFnResult.state as TState;\n\n//           if (curNextFnResult.done) {\n//             done = true;\n//             // return generateNextReturnVal();\n//           } else if ('value' in curNextFnResult) {\n//             return { done: false, value: curNextFnResult.value };\n//           } else if ('iterable' in curNextFnResult) {\n//             if (currentOutputIterator !== undefined) throw new Error('currentOutputIterator should be undefined at this point');\n//             currentOutputIterator = itr8FromIterable(curNextFnResult.iterable);\n//             if (currentOutputIterator?.next === undefined) {\n//               throw new Error('Error while trying to get output iterator, did you specify something that is not an Iterable to the \\'iterable\\' property? (when using a generator function, don\\'t forget to call it in order to return an IterableIterator!)');\n//             }\n//             // goto next round of while loop\n//             // return generateNextReturnVal();\n//           } else {\n//             // we need to call nextIn again\n\n//             // goto next round of while loop\n//             // return generateNextReturnVal();\n//           }\n//         }\n//       };\n\n//       /**\n//        * Almost the same method but in case input or nextFn is async\n//        *\n//        * @param callUpdateNextInPromiseOrValue\n//        * @returns\n//        */\n//       const generateNextReturnValAsync = async (callUpdateNextInPromiseOrValue = true, nextFnResponse?, currentOutputIteratorNext?) => {\n//         let doUpdateNextInPromiseOrValue = callUpdateNextInPromiseOrValue;\n//         let alreadyKnownNextFnResponse = nextFnResponse;\n//         let alreadyKnownCurrentOutputIteratorNext = currentOutputIteratorNext;\n//         // while loop instead of calling this function recursively (call stack can become to large)\n//         while (true) {\n//           if (done) {\n//             return { value: undefined, done: true };\n//           }\n//           // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n//           if (currentOutputIterator) {\n//             let possibleNextValueOrPromise;\n//             if (alreadyKnownCurrentOutputIteratorNext !== undefined) {\n//               possibleNextValueOrPromise = alreadyKnownCurrentOutputIteratorNext;\n//               alreadyKnownCurrentOutputIteratorNext = undefined; // only the first time !!!\n//             } else {\n//               possibleNextValueOrPromise = currentOutputIterator.next() as any;\n//             }\n//             const possibleNext = (\n//               isPromise(possibleNextValueOrPromise)\n//                 ? await possibleNextValueOrPromise\n//                 : possibleNextValueOrPromise\n//             ) as IteratorResult<TOut>;\n\n//             if (possibleNext.done) {\n//               currentOutputIterator = undefined;\n//             } else {\n//               return possibleNext;\n//             }\n//           }\n\n//           // no running iterator, so we need to possibly call nextFn again\n//           if (doUpdateNextInPromiseOrValue) {\n//             updateNextInPromiseOrValue();\n//           } else {\n//             doUpdateNextInPromiseOrValue = true; // only possibly skip it the first time !!!\n//           };\n//           const nextIn = await nextInPromiseOrValue;\n//           let curNextFnResultPromiseOrValue;\n//           if (alreadyKnownNextFnResponse !== undefined) {\n//             curNextFnResultPromiseOrValue = alreadyKnownNextFnResponse;\n//             alreadyKnownNextFnResponse = undefined; // only use it the first time !!!\n//           } else {\n//             curNextFnResultPromiseOrValue = nextFn(nextIn as IteratorResult<TIn>, state, params);\n//           }\n//           if (isAsyncNextFn === undefined) isAsyncNextFn = isPromise(curNextFnResultPromiseOrValue);\n//           const curNextFnResult = (isAsyncNextFn ? await curNextFnResultPromiseOrValue : curNextFnResultPromiseOrValue) as TNextFnResult<TOut, TState>;\n//           if ('state' in curNextFnResult) state = curNextFnResult.state as TState;\n\n//           if (curNextFnResult.done) {\n//             done = true;\n//             // goto next round of while loop\n//             // return generateNextReturnValAsync();\n//           } else if ('value' in curNextFnResult) {\n//             return { done: false, value: curNextFnResult.value };\n//           } else if ('iterable' in curNextFnResult) {\n//             if (currentOutputIterator !== undefined) throw new Error('currentOutputIterator should be undefined at this point');\n//             currentOutputIterator = itr8FromIterable(curNextFnResult.iterable);\n//             if (currentOutputIterator?.next === undefined) {\n//               throw new Error('Error while trying to get output iterator, did you specify something that is not an Iterable to the \\'iterable\\' property? (when using a generator function, don\\'t forget to call it in order to return an IterableIterator!)');\n//             }\n//             // goto next round of while loop\n//             // return generateNextReturnValAsync();\n//           } else {\n//             // we need to call nextIn again\n\n//             // goto next round of while loop\n//             // return generateNextReturnValAsync();\n//           }\n//         }\n//       };\n\n//       ////////////////////////////////////////////////////////////////////////////////\n//       // Here is the returned TPipeable & IterableIterator\n//       ////////////////////////////////////////////////////////////////////////////////\n//       const retVal = {\n//         // return the current (async?) iterator to make it an iterable iterator (so we can use for ... of)\n//         // since we can only know whether the output will be sync or async after the first next call,\n//         // we'll expose both iterator and asynciterator functions...\n//         [Symbol.iterator]: () => retVal,\n//         [Symbol.asyncIterator]: () => retVal,\n//         // pipe: (op:TTransIteratorSyncOrAsync) => op(retVal as Iterator<TOut>),\n//         next: () => {\n//           if (isAsyncInput || isAsyncNextFn) {\n//             return generateNextReturnValAsync();\n//           }\n//           return generateNextReturnVal();\n//         },\n//       };\n\n//       return itr8FromIterator(retVal as any);\n//     };\n\n//     return (itIn: Iterator<TIn> | AsyncIterator<TIn>) => operatorFunction(itIn, initialStateFactory());\n//   }\n// };\n\n/**\n * UNFINISHED (some tests are failing when using this version) !!!\n *\n * EXPERIMENTAL VERSION OF THIS FUNCTION that tries to rewrite the functions\n * after we've established which parts are synchronous (input iterator next, nextFn result, ...)\n * in order to avoid checking this over and over again.\n *\n * An operator is 'a function that generates a transIterator'.\n * So for example filter(...) is an operator, because when called with an argument\n * (the filter function) the result of that will be another function which is the transIterator.\n *\n * A transIterator is simply a function with an iterator as single argument which will return\n * another iterator. This way we can easily 'build a chain of mulitple transIterators'.\n * So it transforms iterators, which is why I have called it transIterator (~transducers).\n *\n * powerMap is a function that generates transIterators that\n * will work both on synchronous and asynchronous iterators.\n * The factory needs to be provided with a single function of the form:\n *\n * ```typescript\n * (nextOfPreviousIteratorInTheChain, state, operatorParams) => TNextFnResult | Promise<[TNextFnResult]>\n * ```\n * and an initial state\n *\n * * nextOfPreviousIteratorInTheChain is the (resolved if async) result of a next call of the input\n *   iterator. This means it will be of the form { done: true } or { done: false, value: <...> }.\n * * The state parameter is used to allow operators to have state, but not all operators need this.\n *   For example: a 'map' operator doesn't need state, but the 'skip' operator would need to keep\n * track of how many records have passed.\n * * The operator params are the argument that is given to the operator function, like a number for\n *   a 'take' operator, or the filter function for a 'filter' operator.\n *\n * Check the readme for some examples on how to write your own operators with powerMap\n * (or check the source code as all the available operators have been built using this function).\n *\n * BEWARE: NEVER MODIFY THE STATE OBJECT (or any of its children!), ALWAYS RETURN A NEW VALUE!\n *\n * QUESTION: would it be better to have an initial state producing function instead of an initial\n *  state?\n *  This way, even if nextFn would modify the state, it wouldn't mess with other instances\n *  of the same operator? Because if we'd like to deep clone the initial state ourselves, we might\n *  end up with some complex cases when classes are involved (I hope no one who's interested in\n *  this library will want to use classes in their state, because the library is more 'functional\n *  programming' oriented)\n *\n * @param nextFn\n * @param initialStateFactory a function that generates the initialSate\n * @returns a funtion taking an iterator (and optionally some argument) as input and that has an iterator as output\n *\n * @category util\n */\nconst itr8OperatorFactoryExperimental = function <\n  TIn = unknown,\n  TOut = unknown,\n  TState = unknown,\n  TParam1 = void,\n  TParam2 = void,\n  TParam3 = void,\n  TParam4 = void\n>(\n  nextFn: (\n    nextIn: IteratorResult<TIn>,\n    state: TState,\n    param1: TParam1,\n    param2: TParam2,\n    param3: TParam3,\n    param4: TParam4,\n    ...otherParams: unknown[]\n  ) => TNextFnResult<TOut, TState> | Promise<TNextFnResult<TOut, TState>>,\n  initialStateFactory: (\n    param1: TParam1,\n    param2: TParam2,\n    param3: TParam3,\n    param4: TParam4,\n    ...otherParams: unknown[]\n  ) => TState\n): (\n  param1: TParam1,\n  param2: TParam2,\n  param3: TParam3,\n  param4: TParam4,\n  ...otherParams: unknown[]\n) => TTransIteratorSyncOrAsync<TIn, TOut> {\n  return function (\n    param1: TParam1,\n    param2: TParam2,\n    param3: TParam3,\n    param4: TParam4,\n    ...otherParams: unknown[]\n  ): TTransIteratorSyncOrAsync<TIn, TOut> {\n    const operatorFunction = (\n      itIn: Iterator<TIn> | AsyncIterator<TIn>,\n      pState: TState\n    ) => {\n      type TOperatorState = {\n        state: TState;\n        currentOutputIterator: Iterator<TOut> | AsyncIterator<TOut> | undefined;\n        done: boolean;\n      };\n\n      const operatorState: TOperatorState = {\n        state: pState,\n        currentOutputIterator: undefined,\n        done: false,\n      };\n\n      let nextInPromiseOrValue:\n        | IteratorResult<TIn>\n        | Promise<IteratorResult<TIn>>\n        | undefined = undefined;\n      // let nextIn: IteratorResult<TIn> | undefined = undefined;\n      let isAsyncInput: boolean | undefined = undefined;\n      function updateNextInPromiseOrValue() {\n        nextInPromiseOrValue = itIn.next();\n        if (isAsyncInput === undefined)\n          isAsyncInput = isPromise(nextInPromiseOrValue);\n      }\n      let isAsyncNextFn: boolean | undefined = undefined;\n      // let state = pState !== undefined ? pState : initialState;\n      // let state = pState;\n\n      // let currentOutputIterator: Iterator<TOut> | AsyncIterator<TOut> | undefined = undefined;\n      // let isAsyncCurrentOutputIterator:boolean | undefined = undefined;\n      // let done = false;\n\n      /**\n       * Can/should we make this kind of recursive?\n       * Figure out based on the input params whether we need to:\n       *  * return done because done = true\n       *  * return the next value of the current iterator\n       *    or empty the current iterator if we're at the end and call generateNextReturnVal\n       *  * do a call to nextFn\n       *    * if next = async, call generateNextReturnValAsync to handle this case\n       *    * set done to true if that is what it returns and call generateNextReturnVal\n       *    * return the value if it returns a value\n       *    * set current iterator if it returns an iterable and call generateNextReturnVal\n       * @returns\n       */\n      let generateNextReturnVal =\n        (): // itIn:Iterator<TIn> | AsyncIterator<TIn>,\n        // nextFn: (nextIn: IteratorResult<TIn>, state: TState, param1: TParam1, param2: TParam2, param3: TParam3, param4: TParam4, ...otherParams:unknown[]) =>\n        //         TNextFnResult<TOut, TState> | Promise<TNextFnResult<TOut, TState>>,\n        // operatorState:TOperatorState\n        IteratorResult<TOut> | Promise<IteratorResult<TOut>> => {\n          const nextReturnVal = thenable(itIn.next()).then(\n            (nextIn, isSyncInput) => {\n              return thenable(\n                nextFn(\n                  nextIn as IteratorResult<TIn>,\n                  operatorState.state,\n                  param1,\n                  param2,\n                  param3,\n                  param4,\n                  ...otherParams\n                )\n              ).then((nextFnResult, isSyncNextFn) => {\n                // nextFnResult as TNextFnResult<TOut, TState>\n                if (\"state\" in nextFnResult)\n                  operatorState.state = nextFnResult.state as TState;\n\n                let retVal;\n                if (nextFnResult.done) {\n                  operatorState.done = true;\n                  // return generateNextReturnVal();\n                  retVal = { done: true };\n                } else if (\"value\" in nextFnResult) {\n                  retVal = { done: false, value: nextFnResult.value };\n                } else if (\"iterable\" in nextFnResult) {\n                  if (operatorState.currentOutputIterator !== undefined)\n                    throw new Error(\n                      \"currentOutputIterator should be undefined at this point\"\n                    );\n                  operatorState.currentOutputIterator = itr8FromIterable(\n                    nextFnResult.iterable\n                  );\n                  if (operatorState.currentOutputIterator?.next === undefined) {\n                    throw new Error(\n                      \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\"\n                    );\n                  }\n                  // goto next round of while loop\n                  // return generateNextReturnVal();\n                } else {\n                  // we need to call nextIn again\n                  // goto next round of while loop\n                  // return generateNextReturnVal();\n                }\n\n                // now we can rewrite the current function in an optimized way because we know\n                // which parts are async (if any) and which not\n                // const newGenerateNextReturnVal = new (isSyncInput && isSyncNextFn ? Function : AsyncFunction)(\n                //   'itIn',\n                //   'nextFn',\n                //   'operatorState',\n                //   `\n                //     // while loop instead of calling this function recursively (call stack can become too large)\n                //     // console.log('operatorState', operatorState);\n                //     while (true) {\n                //       if (operatorState.done) {\n                //         return { value: undefined, done: true };\n                //       }\n                //       // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n                //       if (operatorState.currentOutputIterator) {\n                //         const possibleNextValueOrPromise = operatorState.currentOutputIterator.next();\n                //         // if (isPromise(possibleNextValueOrPromise)) {\n                //         // if (typeof possibleNextValueOrPromise.then === 'Function') {\n                //         //     throw new Error('Async iterables inside nextFn response not supported at this time!!!');\n                //         //   // return { done: true };\n                //         // }\n                //         const possibleNext = possibleNextValueOrPromise;\n\n                //         if (possibleNext.done) {\n                //           operatorState.currentOutputIterator = undefined;\n                //         } else {\n                //           return possibleNext;\n                //         }\n                //       }\n\n                //       // no running iterator, so we need to call nextFn again\n                //       const nextIn = ${isSyncInput ? '' : 'await '}itIn.next();\n                //       const [_itIn, _nextFn, _operatorState, ...otherArgs] = [...arguments];\n                //       const curNextFnResult = ${isSyncNextFn ? '' : 'await '}nextFn(nextIn, operatorState.state, ...otherArgs);\n                //       if ('state' in curNextFnResult) operatorState.state = curNextFnResult.state as TState;\n\n                //       if (curNextFnResult.done) {\n                //         operatorState.done = true;\n                //       } else if ('value' in curNextFnResult) {\n                //         return { done: false, value: curNextFnResult.value };\n                //       } else if ('iterable' in curNextFnResult) {\n                //         if (operatorState.currentOutputIterator !== undefined) throw new Error('currentOutputIterator should be undefined at this point');\n                //         // operatorState.currentOutputIterator = (curNextFnResult.iterable[Symbol.iterator] || curNextFnResult.iterable[Symbol.asyncIterator])(); // itr8FromIterable(curNextFnResult.iterable);\n                //         if (curNextFnResult.iterable[Symbol.iterator]) {\n                //           operatorState.currentOutputIterator = curNextFnResult.iterable[Symbol.iterator]();\n                //         } else if (curNextFnResult.iterable[Symbol.asyncIterator]) {\n                //           operatorState.currentOutputIterator = curNextFnResult.iterable[Symbol.asyncIterator]();\n                //         }\n\n                //         if (!operatorState.currentOutputIterator || operatorState.currentOutputIterator.next === undefined) {\n                //           throw new Error('Error while trying to get output iterator, did you specify something that is not an Iterable to the \\\\'iterable\\\\' property? (when using a generator function, don\\\\'t forget to call it in order to return an IterableIterator!)');\n                //         }\n                //         // goto next round of while loop\n                //       } else {\n                //         // we need to call nextIn again\n                //         // goto next round of while loop\n                //       }\n                //     }\n                //   `,\n                // ) as () => IteratorResult<TOut> | Promise<IteratorResult<TOut>>;\n\n                /**\n                 * Can return a value or undefined\n                 * @param curNextFn\n                 */\n                const handleCurNextFnResult = (\n                  curNextFnResult: TNextFnResult<TOut, TState>\n                ): IteratorResult<TOut> | undefined => {\n                  if (curNextFnResult.done) {\n                    operatorState.done = true;\n                  } else if (\"value\" in curNextFnResult) {\n                    return { done: false, value: curNextFnResult.value };\n                  } else if (\"iterable\" in curNextFnResult) {\n                    if (operatorState.currentOutputIterator !== undefined)\n                      throw new Error(\n                        \"currentOutputIterator should be undefined at this point\"\n                      );\n                    // operatorState.currentOutputIterator = (curNextFnResult.iterable[Symbol.iterator] || curNextFnResult.iterable[Symbol.asyncIterator])(); // itr8FromIterable(curNextFnResult.iterable);\n                    if (curNextFnResult.iterable[Symbol.iterator]) {\n                      operatorState.currentOutputIterator =\n                        curNextFnResult.iterable[Symbol.iterator]();\n                    } else if (curNextFnResult.iterable[Symbol.asyncIterator]) {\n                      operatorState.currentOutputIterator =\n                        curNextFnResult.iterable[Symbol.asyncIterator]();\n                    } else {\n                      // (!operatorState.currentOutputIterator || operatorState.currentOutputIterator.next === undefined) {\n                      throw new Error(\n                        \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\"\n                      );\n                    }\n                    // goto next round of while loop\n                  } else {\n                    // we need to call nextIn again\n                    // goto next round of while loop\n                  }\n                  return undefined;\n                };\n\n                let newGenerateNextReturnVal;\n                if (isSyncInput && isSyncNextFn) {\n                  // sync version\n                  newGenerateNextReturnVal = () => {\n                    // while loop instead of calling this function recursively (call stack can become too large)\n                    // console.log('operatorState', operatorState);\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                      if (operatorState.done) {\n                        return { value: undefined, done: true };\n                      }\n                      // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n                      if (operatorState.currentOutputIterator) {\n                        const possibleNextValueOrPromise =\n                          operatorState.currentOutputIterator.next();\n                        // if (isPromise(possibleNextValueOrPromise)) {\n                        // if (typeof possibleNextValueOrPromise.then === 'Function') {\n                        //     throw new Error('Async iterables inside nextFn response not supported at this time!!!');\n                        //   // return { done: true };\n                        // }\n                        const possibleNext =\n                          possibleNextValueOrPromise as IteratorResult<TOut>;\n\n                        if (possibleNext.done) {\n                          operatorState.currentOutputIterator = undefined;\n                        } else {\n                          return possibleNext;\n                        }\n                      }\n\n                      // no running iterator, so we need to call nextFn again\n                      const nextIn = itIn.next() as IteratorResult<TIn>;\n                      const curNextFnResult = nextFn(\n                        nextIn,\n                        operatorState.state,\n                        param1,\n                        param2,\n                        param3,\n                        param4,\n                        ...otherParams\n                      ) as TNextFnResult<TOut, TState>;\n                      if (\"state\" in curNextFnResult)\n                        operatorState.state = curNextFnResult.state as TState;\n\n                      const r = handleCurNextFnResult(curNextFnResult);\n                      if (r !== undefined) {\n                        return r;\n                      }\n                      // if not returned, continue to the next round of the while loop\n                    }\n                  };\n                } else if (isSyncInput) {\n                  newGenerateNextReturnVal = async () => {\n                    // while loop instead of calling this function recursively (call stack can become too large)\n                    // console.log('operatorState', operatorState);\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                      if (operatorState.done) {\n                        return { value: undefined, done: true };\n                      }\n                      // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n                      if (operatorState.currentOutputIterator) {\n                        const possibleNextValueOrPromise =\n                          operatorState.currentOutputIterator.next();\n                        // if (isPromise(possibleNextValueOrPromise)) {\n                        // if (typeof possibleNextValueOrPromise.then === 'Function') {\n                        //     throw new Error('Async iterables inside nextFn response not supported at this time!!!');\n                        //   // return { done: true };\n                        // }\n                        const possibleNext =\n                          possibleNextValueOrPromise as IteratorResult<TOut>;\n\n                        if (possibleNext.done) {\n                          operatorState.currentOutputIterator = undefined;\n                        } else {\n                          return possibleNext;\n                        }\n                      }\n\n                      // no running iterator, so we need to call nextFn again\n                      const nextIn = itIn.next() as IteratorResult<TIn>;\n                      const curNextFnResult = (await nextFn(\n                        nextIn,\n                        operatorState.state,\n                        param1,\n                        param2,\n                        param3,\n                        param4,\n                        ...otherParams\n                      )) as TNextFnResult<TOut, TState>;\n                      if (\"state\" in curNextFnResult)\n                        operatorState.state = curNextFnResult.state as TState;\n\n                      const r = handleCurNextFnResult(curNextFnResult);\n                      if (r !== undefined) {\n                        return r;\n                      }\n                      // if not returned, continue to the next round of the while loop\n                    }\n                  };\n                } else if (isSyncNextFn) {\n                  newGenerateNextReturnVal = async () => {\n                    // while loop instead of calling this function recursively (call stack can become too large)\n                    // console.log('operatorState', operatorState);\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                      if (operatorState.done) {\n                        return { value: undefined, done: true };\n                      }\n                      // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n                      if (operatorState.currentOutputIterator) {\n                        const possibleNextValueOrPromise =\n                          operatorState.currentOutputIterator.next();\n                        // if (isPromise(possibleNextValueOrPromise)) {\n                        // if (typeof possibleNextValueOrPromise.then === 'Function') {\n                        //     throw new Error('Async iterables inside nextFn response not supported at this time!!!');\n                        //   // return { done: true };\n                        // }\n                        const possibleNext =\n                          possibleNextValueOrPromise as IteratorResult<TOut>;\n\n                        if (possibleNext.done) {\n                          operatorState.currentOutputIterator = undefined;\n                        } else {\n                          return possibleNext;\n                        }\n                      }\n\n                      // no running iterator, so we need to call nextFn again\n                      const nextIn = (await itIn.next()) as IteratorResult<TIn>;\n                      const curNextFnResult = nextFn(\n                        nextIn,\n                        operatorState.state,\n                        param1,\n                        param2,\n                        param3,\n                        param4,\n                        ...otherParams\n                      ) as TNextFnResult<TOut, TState>;\n                      if (\"state\" in curNextFnResult)\n                        operatorState.state = curNextFnResult.state as TState;\n\n                      const r = handleCurNextFnResult(curNextFnResult);\n                      if (r !== undefined) {\n                        return r;\n                      }\n                      // if not returned, continue to the next round of the while loop\n                    }\n                  };\n                } else {\n                  newGenerateNextReturnVal = async () => {\n                    // while loop instead of calling this function recursively (call stack can become too large)\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                      if (operatorState.done) {\n                        return { value: undefined, done: true };\n                      }\n                      // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n                      if (operatorState.currentOutputIterator) {\n                        const possibleNextValueOrPromise =\n                          operatorState.currentOutputIterator.next();\n                        // if (isPromise(possibleNextValueOrPromise)) {\n                        // if (typeof possibleNextValueOrPromise.then === 'Function') {\n                        //     throw new Error('Async iterables inside nextFn response not supported at this time!!!');\n                        //   // return { done: true };\n                        // }\n                        const possibleNext =\n                          possibleNextValueOrPromise as IteratorResult<TOut>;\n\n                        if (possibleNext.done) {\n                          operatorState.currentOutputIterator = undefined;\n                        } else {\n                          return possibleNext;\n                        }\n                      }\n\n                      // no running iterator, so we need to call nextFn again\n                      const nextIn = (await itIn.next()) as IteratorResult<TIn>;\n                      const curNextFnResult = (await nextFn(\n                        nextIn,\n                        operatorState.state,\n                        param1,\n                        param2,\n                        param3,\n                        param4,\n                        ...otherParams\n                      )) as TNextFnResult<TOut, TState>;\n                      if (\"state\" in curNextFnResult)\n                        operatorState.state = curNextFnResult.state as TState;\n\n                      const r = handleCurNextFnResult(curNextFnResult);\n                      if (r !== undefined) {\n                        return r;\n                      }\n                      // if not returned, continue to the next round of the while loop\n                    }\n                  };\n                }\n\n                // now overwrite the function within the same context as the original function\n                generateNextReturnVal = newGenerateNextReturnVal;\n\n                // console.log('           ----> next return val will be', retVal);\n                return retVal || generateNextReturnVal(); // generateNextReturnVal(itIn, nextFn, operatorState, param1, param2, param3, param4, ...otherParams);\n              });\n            }\n          ).src;\n\n          // console.log('         ----> next return val will be', nextReturnVal);\n          return nextReturnVal;\n        };\n\n      ////////////////////////////////////////////////////////////////////////////////\n      // Here is the returned TPipeable & IterableIterator\n      ////////////////////////////////////////////////////////////////////////////////\n      const retVal = {\n        // return the current (async?) iterator to make it an iterable iterator (so we can use for ... of)\n        // since we can only know whether the output will be sync or async after the first next call,\n        // we'll expose both iterator and asynciterator functions...\n        [Symbol.iterator]: () => retVal,\n        [Symbol.asyncIterator]: () => retVal,\n        // pipe: (op:TTransIteratorSyncOrAsync) => op(retVal as Iterator<TOut>),\n        next: ():\n          | IteratorResult<TOut>\n          | Promise<IteratorResult<TOut>>\n          | IteratorResult<TOut[]>\n          | Promise<IteratorResult<TOut[]>> => {\n          return generateNextReturnVal(); // generateNextReturnVal(itIn, nextFn, operatorState, param1, param2, param3, param4, ...otherParams);\n        },\n      };\n\n      return itr8FromIterator(\n        retVal as IterableIterator<TOut> | AsyncIterableIterator<TOut>\n      );\n    };\n\n    return (\n      itIn: Iterator<TIn> | AsyncIterator<TIn>\n    ): TPipeable<TIn, TOut> &\n      (IterableIterator<TOut> | AsyncIterableIterator<TOut>) =>\n      operatorFunction(\n        itIn,\n        initialStateFactory(param1, param2, param3, param4, ...otherParams)\n      );\n  };\n};\n\nexport { powerMap };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * Only take elements as long as the filter function returns true.\n *\n * The filter function can be asynchronous (in which case the resulting iterator will be\n * asynchronous regardless of the input iterator)!\n *\n * @category operators/general\n */\nconst takeWhile = <TIn>(filterFn: (x: TIn) => boolean | Promise<boolean>) =>\n  powerMap<TIn, TIn, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) return { done: true };\n\n      return thenable(filterFn(nextIn.value)).then((filterFnResult) => {\n        if (filterFnResult) return { done: false, value: nextIn.value };\n        return { done: true };\n      }).src;\n    },\n    () => undefined\n  );\n\nexport { takeWhile };\n", "import { takeWhile } from \"../operators/general/takeWhile.js\";\nimport { pipe } from \"../util/index.js\";\nimport { forEach } from \"./forEach.js\";\nimport { itr8FromIterator } from \"./itr8FromIterator.js\";\n\n/**\n * When you want to process the same iterator mutltiple times in different ways\n * (you can think of it as 'splitting the stream'),\n * it would be cool to have a way to 'subscribe' many times to the same iterator.\n * An IterableIterator returns an iterator, but that will always return the current iterator,\n * and not a new one.\n *\n * This function produces an Iterable that returns a new iterator each time [Symbol.asyncIterator]()\n * gets called, so one needs to call next on all output iterators separately to get the next element\n * of the input iterator.\n *\n * This method creates a function that turns the iterator into an Iterable that returns\n * a new iterator on calling [Symbol.asynIterator] that starts from the current element\n * (or the oldest element any of the subscribers is at?) that we are at in the source iterator.\n *\n * In order to support the fact that not all output iterators will be pulled at the same time,\n * we need to keep a cache + the position that each iterator is at.\n *\n * TODO: In order to protect ourselves from 'abandoned' iterators, a timeout could be used\n * to clean them up, so the cache can be emptied up to the oldest 'active' iterator.\n *\n * @category interface/standard\n */\nfunction itr8ToMultiIterable<\n  T\n>(it: Iterator<T> | AsyncIterator<T> /*, abandonedTimeoutMilliseconds = Infinity */): AsyncIterable<T> {\n  const subscriberMap: Map<AsyncIterableIterator<T>, number> = new Map();\n  const buffer: Map<number, IteratorResult<T> | Promise<IteratorResult<T>>> =\n    new Map();\n\n  const retVal: AsyncIterable<T> = {\n    [Symbol.asyncIterator]: () => {\n      /** Helper to remove old elements from buffer that all current subscribers have read */\n      const cleanBuffer = () => {\n        const minIndex = Math.min(...subscriberMap.values());\n        // Maps are iterated in insertion order !\n        // ['IMPERATIVE' VERSION]\n        // for (const i of buffer.keys()) {\n        //   if (i < minIndex) {\n        //     buffer.delete(i);\n        //   } else {\n        //     break;\n        //   }\n        // }\n        // ['DECLARATIVE' VERSION]\n        pipe(\n          buffer.keys(),\n          takeWhile((i) => i < minIndex),\n          forEach((i) => {\n            buffer.delete(i);\n          })\n        );\n      }\n\n      const outIt: AsyncIterableIterator<T> = {\n        [Symbol.asyncIterator]: () => outIt,\n        next: async () => {\n          const index = subscriberMap.get(outIt) as number;\n          if (!buffer.has(index)) {\n            buffer.set(index, it.next());\n          }\n          // remove old stuff in buffer\n          cleanBuffer();\n\n          subscriberMap.set(outIt, index + 1);\n          return buffer.get(index) as Promise<IteratorResult<T>>;\n        },\n        \"return\": async (value?:T) => {\n          subscriberMap.delete(outIt);\n          cleanBuffer();\n          return { done: true, value };\n        },\n        \"throw\": async (error?) => {\n          subscriberMap.delete(outIt);\n          cleanBuffer();\n          return { done: true, value: undefined };\n        },\n      };\n\n      // add the new iterator to the subscriberMap\n      subscriberMap.set(\n        outIt,\n        buffer.size === 0 ? 0 : Math.min(...buffer.keys())\n      );\n      // TODO: set a disconnect timeout (we'll need to store the last get time, or the timeout id)\n      return itr8FromIterator(outIt) as AsyncIterator<T>;\n    },\n  };\n  // subscriberMap.set(outIt, buffer.size > 0 ? buffer.values.next().value : 0);\n  return retVal as AsyncIterableIterator<T>;\n}\n\nexport { itr8ToMultiIterable };\n", "import { isPromise } from \"../../util/index.js\";\nimport { itr8FromIterator } from \"../../index.js\";\n\n/**\n * Probably only useful on async iterators.\n *\n * It will turn an async iterator into an asynchronous iterator that will always return the\n * last known value, while waiting for the promise on the incoming iterator to resolve.\n *\n * Every value on the incoming iterator will be returned at least once in order to keep\n * the operator 'passive'. This operator will not actively drain the incoming iterator.\n *\n * @example\n * ```typescript\n * // input iterator\n * const it = itr8.itr8Pushable<string>();\n * // output iterator that will always return the mostRecent value of the input iterator\n * const itOut = pipe(it, mostRecent('My initial value'));\n *\n * await sleep(1);\n * await itOut.next(); // => { value: 'My initial value' }\n * await itOut.next(); // => { value: 'My initial value' }\n * await sleep(1);\n * await itOut.next(); // => { value: 'My initial value' }\n *\n * it.push('2nd value');\n * await sleep(1);\n * await itOut.next(); // => { value: '2nd value' }\n * await itOut.next(); // => { value: '2nd value' }\n *\n * it.push('third value');\n * // sync so 'third value' promise not resolved yet at this point\n * await itOut.next(); // => { value: '2nd value' }\n * await sleep(1);\n * await itOut.next(); // => { value: 'third value' }\n * await itOut.next(); // => { value: 'third value' }\n * await sleep(1);\n * await itOut.next(); // => { value: 'third value' }\n *\n * // see evey value at least once!!!\n * it.push('fourth value');\n * it.push('fifth value');\n * // sync so 'third value' promise not resolved yet\n * await itOut.next(); // => { value: 'third value' }\n * await sleep(0);\n * await itOut.next(); // => { value: 'fourth value' }\n * await sleep(0);\n * await itOut.next(); // => { value: 'fifth value' }\n *\n * it.done();\n * // sync so 'done' promise not resolved yet\n * await itOut.next(); // => { value: 'fifth value' }\n * await sleep(1);\n * await itOut.next(); // => { done: true }\n * await itOut.next(); // => { done: true }\n * ```\n *\n * @category operators/async\n */\nconst mostRecent = <T>(initalValue: T) => {\n  return (it: Iterator<T> | AsyncIterator<T>): AsyncIterator<T> => {\n    let nextOut: IteratorResult<T> = { value: initalValue };\n    let resolveNextOutRead;\n\n    const handleInputPromise = async () => {\n      let nextOutRead: Promise<boolean> | undefined = undefined;\n      do {\n        if (isPromise(nextOutRead)) {\n          await nextOutRead;\n        }\n        nextOut = await it.next();\n        nextOutRead = new Promise((resolve, reject) => {\n          resolveNextOutRead = resolve;\n        });\n      } while (!nextOut.done);\n    };\n\n    const retVal = {\n      // [Symbol.iterator]: () => retVal as IterableIterator<T>,\n      [Symbol.asyncIterator]: () => retVal as AsyncIterableIterator<T>,\n      next: async () => {\n        if (resolveNextOutRead === undefined) {\n          handleInputPromise();\n        } else {\n          resolveNextOutRead(true);\n        }\n        return nextOut;\n      },\n    };\n\n    return itr8FromIterator(retVal as any);\n  };\n};\n\nexport { mostRecent };\n", "import { isPromise } from \"../../util/index.js\";\nimport { itr8FromIterator } from \"../../index.js\";\n\n/**\n * Probably only useful on async iterators.\n *\n * Instead of only asking for the next value of the incoming iterator when a next call comes in,\n * make sure to do one or more next calls to the incoming iterator up-front, to decrease the\n * waiting time.\n *\n * This can be used to kind of 'parallelize' the processing, while respecting the order.\n * If the order is not important, you might want to take a look a the parallel(...) operator!\n *\n * This one can be useful, when the result needs to do some I/O (for example an API get\n * or a DB fetch), and processing also takes up a certain amount of time due to I/O.\n * In this case, it makes sense to already do the next call on the incoming iterator up-front,\n * so that it will hopefully already have resolved by the time you need it for processing.\n *\n * Nothing will be done before the first next call, but after the first next call the iterator\n * will always try to have a buffer with the given amount of prefetched results (which will be\n * impossible to achieve if processing is generally faster than fetching).\n *\n * forEach actually by default acts like it has a prefetch of 1, but imagine a case where the\n * processing time can vary significantly. Then, when processing takes a long time, by prefetching\n * more than one you can make sure that there is no waiting time for the next (maybe very fast)\n * processing to start because the promises they act upon are already resolved by the time they\n * are needed.\n *\n * @category operators/async\n */\nconst prefetch = (amount: number) => {\n  return <T>(\n    it: Iterator<T> | AsyncIterator<T>\n  ): Iterator<T> | AsyncIterator<T> => {\n    let inputs: Array<Promise<IteratorResult<T>> | IteratorResult<T>> = [];\n    let isAsyncInput: boolean;\n    const addInputIfNeeded = async () => {\n      if (inputs.length < amount) {\n        if (isAsyncInput && inputs.length > 0) await inputs[0];\n        const next = it.next();\n        if (isPromise(next)) {\n          // console.log('     add another (async) input, current nr of inputs = ', inputs.length, ' < ', amount);\n          isAsyncInput = true;\n          next.then((n) => {\n            if (!n.done) {\n              // console.log('  then: call addInputIfNeeded(), current nr of inputs = ', inputs.length, ' < ', amount);\n              addInputIfNeeded();\n            }\n          });\n        }\n        inputs.push(next);\n      }\n    };\n\n    const retVal = {\n      [Symbol.asyncIterator]: () => retVal as AsyncIterableIterator<T>,\n      [Symbol.iterator]: () => retVal as IterableIterator<T>,\n      next: () => {\n        // console.log('  next: call addInputIfNeeded(), current nr of inputs = ', inputs.length, ' < ', amount);\n        addInputIfNeeded();\n        if (inputs.length > 0) {\n          const [firstInput, ...remainingInputs] = inputs;\n          inputs = remainingInputs;\n          // console.log('  next: call 2 to addInputIfNeeded(), current nr of inputs = ', inputs.length, ' < ', amount);\n          addInputIfNeeded();\n          // console.log('  next: return ', firstInput);\n          return firstInput;\n        }\n        return isAsyncInput\n          ? (Promise.resolve({ done: true, value: undefined }) as Promise<\n              IteratorResult<T>\n            >)\n          : ({ done: true, value: undefined } as IteratorResult<T>);\n      },\n    };\n\n    return itr8FromIterator(retVal as any);\n  };\n};\n\nexport { prefetch };\n", "import { pipe } from \"../../util/index.js\";\nimport {\n  forEach,\n  itr8FromIterator,\n  itr8FromSingleValue,\n  itr8Pushable,\n  itr8ToArray,\n} from \"../../interface/index.js\";\nimport { TPipeable, TPushable, TTransIteratorSyncOrAsync } from \"../../types\";\n\n/**\n * This operator should make it easy to run asynchronous transIterators in parallel, in order\n * to speed things up.\n * You can think of it as multiple lanes on a highway, but the output order of the elements\n * is still guaranteed by default! But if the order doesn't matter, you can speed up things\n * even more by allowing elements whose processing goes faster to overtake the slower ones.\n *\n * ```\n * \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n * \u2502input iterator\u2502\n * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *        \u2502\n *        \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *        \u2502             \u2502\n *   \u250C\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2510   \u250C\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2510\n *   \u2502transform\u2502   \u2502transform\u2502\n *   \u2502 lane 1  \u2502   \u2502 lane 2  \u2502   ...\n *   \u2514\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2518\n *        \u2502             \u2502\n *        \u2502             \u2502\n *        \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *        \u2502\n * \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n * \u2502output iterator\u2502\n * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n * ```\n *\n * The first argument specifies the maximum concurrency and whether the order must be respected.\n * All arguments after that are the transIterators that make up the algorithm to be run in parallel.\n *\n * 'keepOrder: false' can be useful in cases where the elements can be processed independently.\n * For example:\n * if you would model a webserver as a transIterator that turns a stream of http requests\n * into a stream of http responses, their processing can be done independently, and it would\n * make sense to respond as quickly as possible, instead of waiting for the previous request to be\n * processed first.\n *\n * This should be an ideal combination with the runInWorker operator so we can easily distribute\n * the work over the wanted amount of worker threads.\n *\n * @example\n * ```typescript\n * // run google searches and transform the result with an online api to produce a map of results\n * // but run maximum 4 api requests in parallel to speed things up\n * await pipe(\n *        itr8FromArray([ 'Garfield', 'H\u00E4gar the Horrible', 'Droopy', 'Calvin and Hobbes', 'Fritz the Cat', 'Popeye' ])\n *        parallel(\n *          { concurrency: 4 },\n *          map(async (term) => ...), // a call to google search to get the search results in html\n *          map(async (html) => ...), // another api call that turns the html into structered json { name: 'Garfield', searchResults: [ ... ] }\n *        ),\n *        map(({name, searchResults}) => [name, searchResults]),\n *        itr8ToObject, // like Object.fromEntries but for both synchronous and asynchronous iterators\n *      )\n * // => {\n * //   'Garfield': [ ...urls ],\n * //   'H\u00E4gar the Horrible': [ ...urls ],\n * //   'Droopy': [ ...urls ],\n * //   'Calvin and Hobbes': [ ...urls ],\n * //   'Fritz the Cat': [ ...urls ],\n * //   'Popeye': [ ...urls ],\n * // }\n * ```\n *\n * @param options\n * @param transIt\n * @param {...(it:Iterator<unknown> | AsyncIterator<unknown>)=>Iterator<unknown> | AsyncIterator<unknown>} moreTransIts\n * @returns\n *\n * @category operators/async\n */\nfunction parallel<A, B>(\n  options: { concurrency: number; keepOrder?: boolean },\n  transIt1: TTransIteratorSyncOrAsync<A, B>\n): TTransIteratorSyncOrAsync<A, B>;\nfunction parallel<A, B, C>(\n  options: { concurrency: number; keepOrder?: boolean },\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>\n): TTransIteratorSyncOrAsync<A, C>;\nfunction parallel<A, B, C, D>(\n  options: { concurrency: number; keepOrder?: boolean },\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n  transIt3: TTransIteratorSyncOrAsync<C, D>\n): TTransIteratorSyncOrAsync<A, D>;\nfunction parallel<A, B, C, D, E>(\n  options: { concurrency: number; keepOrder?: boolean },\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n  transIt3: TTransIteratorSyncOrAsync<C, D>,\n  transIt4: TTransIteratorSyncOrAsync<D, E>\n): TTransIteratorSyncOrAsync<A, E>;\nfunction parallel<A, B, C, D, E, F>(\n  options: { concurrency: number; keepOrder?: boolean },\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n  transIt3: TTransIteratorSyncOrAsync<C, D>,\n  transIt4: TTransIteratorSyncOrAsync<D, E>,\n  transIt5: TTransIteratorSyncOrAsync<E, F>\n): TTransIteratorSyncOrAsync<A, F>;\n// function pipe<IN, A, B, C, D, E>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E): E;\n// function pipe<IN, A, B, C, D, E, F>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E, fn6: (x: E) => F): F;\n// function pipe<IN, A, B, C, D, E, F, G>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E, fn6: (x: E) => F, fn7: (x: F) => G): G;\n// function pipe<IN, A, B, C, D, E, F, G, H>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E, fn6: (x: E) => F, fn7: (x: F) => G, fn8: (x: G) => H): H;\n// function pipe<IN, A, B, C, D, E, F, G, H, I>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E, fn6: (x: E) => F, fn7: (x: F) => G, fn8: (x: G) => H, fn9: (x: H) => I): I;\n// function pipe<IN, A, B, C, D, E, F, G, H, I, J>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E, fn6: (x: E) => F, fn7: (x: F) => G, fn8: (x: G) => H, fn9: (x: H) => I, fn10: (x: I) => J): J;\n// function pipe<IN, A, B, C, D, E, F, G, H, I, J>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E, fn6: (x: E) => F, fn7: (x: F) => G, fn8: (x: G) => H, fn9: (x: H) => I, fn10: (x: I) => J, ...moreFns: Array<(x: unknown) => unknown>): unknown;\n// function parallel<IN, A>(\nfunction parallel(\n  options: { concurrency: number; keepOrder?: boolean },\n  transIt: TTransIteratorSyncOrAsync,\n  ...moreTransIts: Array<TTransIteratorSyncOrAsync>\n): TTransIteratorSyncOrAsync {\n  // combine all parameters into a single transIterator in order to apply it\n  const transItsCombined = moreTransIts.reduce(\n    (acc, cur) => (input) => cur(acc(input)),\n    transIt\n  );\n  // = compose(transIt, ...moreTransIts)\n\n  if (options.keepOrder === undefined || options.keepOrder) {\n    return <T, U>(\n      inIt: Iterator<T> | AsyncIterator<T>\n    ): TPipeable & AsyncIterableIterator<U> => {\n      type TItOfItsElement = {\n        callbackIt: TPushable & AsyncIterableIterator<boolean>;\n        subIt: TPushable & AsyncIterableIterator<T>;\n      };\n\n      async function* iteratorOfIterables() {\n        // create an iterator to push the results of each 'lane' to\n        const outIteratorOfIterators = itr8Pushable<TItOfItsElement>();\n\n        // first setup the (concurrent) forEach on the incoming iterator, so that things will be pushed to the pushable iterator\n        (async () => {\n          // const start = Date.now();\n          // const timePassed = () => Date.now() - start;\n          await pipe(\n            itr8FromIterator(inIt),\n            forEach(\n              async (inElement) => {\n                // console.log(`${JSON.stringify(inElement)}: taking lane (${timePassed()} ms)`);\n                const itOfItsElement: TItOfItsElement = {\n                  callbackIt: itr8Pushable<boolean>(),\n                  subIt: itr8Pushable(),\n                };\n                outIteratorOfIterators.push(itOfItsElement);\n                // actively drain the subIterator to force parallel processing\n                // and push the results onto the subItPushable\n                const subIt = transItsCombined(itr8FromSingleValue(inElement));\n                // await forEach(itOfItsElement.subIt.push)(subIt);\n                await forEach((v) => {\n                  // console.log(`${JSON.stringify(inElement)}: Pushing ${JSON.stringify(v)} to outIterator (${timePassed()} ms)`);\n                  itOfItsElement.subIt.push(v);\n                })(subIt);\n                // console.log(`${JSON.stringify(inElement)}: Pushing DONE to outIterator (${timePassed()} ms)`);\n                itOfItsElement.subIt.done();\n                // now wait until we get a signal that this subIterator has been processed (pulled in)\n                // so this 'lane' can start processing a new record\n                await itr8ToArray(itOfItsElement.callbackIt);\n                // console.log(`${JSON.stringify(inElement)}: clearing lane because outIterator has processed all elemants... (${timePassed()} ms)`);\n              },\n              { concurrency: options.concurrency }\n            )\n          );\n\n          // after the forEach, make sure we indicate that the iterator is done!\n          outIteratorOfIterators.done();\n        })();\n\n        // second we'll loop through the outIteratorOfIterators\n        for await (const subItElement of outIteratorOfIterators) {\n          yield* subItElement.subIt;\n          // send signal back to forEach that the processing has finished for this subIterator\n          subItElement.callbackIt.done();\n        }\n      }\n      return itr8FromIterator(iteratorOfIterables()) as TPipeable &\n        AsyncIterableIterator<U>;\n    };\n  } else {\n    return <T, U>(\n      inIt: Iterator<T> | AsyncIterator<T>\n    ): TPipeable & AsyncIterableIterator<U> => {\n      type TItElement =\n        | { callbackIt: TPushable & AsyncIterableIterator<boolean> }\n        | { value: T };\n\n      async function* iteratorOfValues() {\n        // create an iterator to push calculated values onto\n        const outIterator = itr8Pushable<TItElement>();\n\n        // first setup the (concurrent) forEach on the incoming iterator, so that things will be pushed to the pushable iterator\n        (async () => {\n          await pipe(\n            itr8FromIterator(inIt),\n            forEach(\n              async (inElement) => {\n                // actively drain the subIterator to force parallel processing\n                // and push the results onto the pushable outIterator\n                const subIt = transItsCombined(itr8FromSingleValue(inElement));\n                await forEach((v) => outIterator.push({ value: v }))(subIt);\n                // await forEach((v) => {\n                //   console.log(`${JSON.stringify(inElement)}: Pushing ${JSON.stringify(v)} to outIterator`);\n                //   outIterator.push({ value: v });\n                // })(subIt);\n                const callbackIt = itr8Pushable<boolean>();\n                // console.log(`${JSON.stringify(inElement)}: Pushing DONE to outIterator`);\n                outIterator.push({ callbackIt });\n                // now wait until we get a signal that this subIterator has been processed (pulled in)\n                // so this 'lane' can start processing a new record\n                await itr8ToArray(callbackIt);\n                // console.log(`${JSON.stringify(inElement)}: clearing lane because outIterator has processed all elemants...`);\n              },\n              { concurrency: options.concurrency }\n            )\n          );\n\n          // after the forEach, make sure we indicate that the iterator is done!\n          outIterator.done();\n        })();\n\n        // second we'll loop through the outIterator\n        for await (const subItElement of outIterator) {\n          if ((subItElement as any).callbackIt === undefined) {\n            yield (subItElement as { value: T }).value;\n          } else {\n            // send signal back to forEach that the processing has finished for this subIterator\n            (\n              subItElement as {\n                callbackIt: TPushable & AsyncIterableIterator<boolean>;\n              }\n            ).callbackIt.done();\n          }\n        }\n      }\n      return itr8FromIterator(iteratorOfValues()) as TPipeable &\n        AsyncIterableIterator<U>;\n    };\n  }\n}\n\nexport { parallel };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Return true if every item returns true on the test function.\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4, 5, 6 ]),\n *      every((x) => x > 2), // => [ false ]\n *    );\n * ```\n *\n * The filter function can be asynchronous (in which case the resulting iterator will be\n * asynchronous regardless of the input iterator)!\n *\n * @category operators/boolean\n */\nconst every = <TIn>(filterFn: (TIn) => boolean | Promise<boolean>) =>\n  powerMap<TIn, boolean, { done: boolean }>(\n    (nextIn, state) => {\n      if (state.done) return { done: true };\n      if (nextIn.done)\n        return { done: false, value: true, state: { done: true } };\n\n      return thenable(filterFn(nextIn.value)).then((result) => {\n        if (result) return { done: false, state: { done: false } };\n        return { done: false, value: result, state: { done: true } };\n      }).src;\n    },\n    () => ({ done: false })\n  );\n\nexport { every };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Return true if at least 1 item returns true on the test function.\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4, 5, 6 ]),\n *      some((x) => x > 2), // => [ true ]\n *    );\n * ```\n *\n * The filter function can be asynchronous (in which case the resulting iterator will be\n * asynchronous regardless of the input iterator)!\n *\n * @category operators/boolean\n */\nconst some = <TIn>(filterFn: (TIn) => boolean | Promise<boolean>) =>\n  powerMap<TIn, boolean, { done: boolean }>(\n    (nextIn, state) => {\n      if (state.done) return { done: true };\n      if (nextIn.done)\n        return { done: false, value: false, state: { done: true } };\n\n      return thenable(filterFn(nextIn.value)).then((result) => {\n        if (result)\n          return { done: false, value: result, state: { done: true } };\n        return { done: false, state: { done: false } };\n      }).src;\n    },\n    () => ({ done: false })\n  );\n\nexport { some };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * Removes consecutive doubles.\n * If no argument is provided, standard !== will be used to compare both values.\n * If a mapping fn is provided, the result of the mapping fn will be compared using !==,\n * which means the mapping function should produce a 'simple' types like number or string.\n *\n * (The alternative option would have been to pass 2 arguments to the compare fn and if\n * it returns true, the elements would be considered equal)\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8.itr8FromArrayAsync([ 1, 2, 2, 2, 3, 4, 4, 3 ]),\n *      itr8.dedup(), // => [ 1, 2, 3, 4, 3 ]\n *    );\n * ```\n * @example\n * ```typescript\n *    pipe(\n *      itr8.itr8FromArrayAsync([ { id: 1 }, { id: 2 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 4 }, { id: 3 } ])\n *      itr8.dedup((a:{ id:number }) => id ) // => [ [ { id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 3 } ];\n *    );\n * ```\n *\n * @param mapFn\n *\n * @category operators/general\n */\nconst dedup = <TIn>(mapFn?: (v: TIn) => any) =>\n  powerMap<TIn, boolean, void | TIn>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n\n      // promise if mapFn is async!\n      const valueToCompare = mapFn ? mapFn(nextIn.value) : nextIn.value;\n      return thenable(valueToCompare).then((v) => {\n        return v !== state\n          ? { done: false, value: nextIn.value, state: v }\n          : { done: false, state: v };\n      }).src;\n    },\n    () => undefined\n  );\n\nexport { dedup };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * Only keep elements where the filter function returns true.\n *\n * The filter function can be asynchronous (in which case the resulting iterator will be\n * asynchronous regardless of the input iterator)!\n *\n * @category operators/general\n */\nconst filter = <TIn>(filterFn: (v: TIn) => boolean | Promise<boolean>) =>\n  powerMap<TIn, TIn, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) return { done: true };\n\n      return thenable(filterFn(nextIn.value)).then((result) => {\n        if (result) return { done: false, value: nextIn.value };\n        return { done: false };\n      }).src;\n\n      // const result = filterFn(nextIn.value);\n      // if (isPromise(result)) {\n      //   return (async () => {\n      //     if (await result) return { done: false, value: nextIn.value };\n      //     return { done: false };\n      //   })();\n      // } else {\n      //   if (result) return { done: false, value: nextIn.value };\n      //   return { done: false };\n      // }\n    },\n    () => undefined\n  );\n\nexport { filter };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * The incoming elements are arrays, and send out each element of the array 1 by one.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ [1, 2], [3, 4], [5, 6] ]),\n *      flatten(), // => [ 1, 2, 3, 4, 5, 6 ]\n *    );\n * ```\n *\n * @category operators/general\n */\nconst flatten = <TIn>() =>\n  powerMap<Iterable<TIn>, TIn, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) return { done: true };\n      return { done: false, iterable: nextIn.value };\n    },\n    () => undefined\n  );\nexport { flatten };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Group the incoming elements so the output iterator will return arrays/tuples of a certain size.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4, 5, 6 ]),\n *      groupPer(2), // => [ [1, 2], [3, 4], [5, 6] ]\n *    );\n * ```\n *\n * @category operators/general\n */\nconst groupPer = <TIn>(groupSize: number) =>\n  powerMap<TIn, Array<TIn>, { done: boolean; buffer: Array<TIn> }>(\n    (nextIn, state) => {\n      if (state.done || (nextIn.done && state.buffer.length === 0)) {\n        return { done: true };\n      } else if (nextIn.done) {\n        return {\n          done: false,\n          value: state.buffer,\n          state: { done: true, buffer: [] },\n        };\n      } else if (state.buffer.length + 1 === groupSize) {\n        return {\n          done: false,\n          value: [...state.buffer, nextIn.value],\n          state: { done: false, buffer: [] },\n        };\n      }\n      return {\n        done: false,\n        state: { ...state, buffer: [...state.buffer, nextIn.value] },\n      };\n    },\n    () => ({ done: false, buffer: [] })\n  );\n\nexport { groupPer };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Intersperse the the argument bewteen each element of the iterator.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 'hello', 'world', 'and', 'goodbye' ]),\n *      intersperse('|'), // => [ [ 'hello', '|', 'world', '|', 'and', '|', 'goodbye' ] ]\n *    );\n * ```\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4 ]),\n *      intersperse(true), // => [ 1, true, 2, true, 3, true, 4 ]\n *    );\n * ```\n *\n * @category operators/general\n */\nconst intersperse = (intersperseThing: unknown) =>\n  powerMap<unknown, unknown, boolean>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        return { done: true };\n      } else if (state) {\n        return {\n          done: false,\n          iterable: [intersperseThing, nextIn.value],\n          state,\n        };\n      }\n      // first time, just return the first element\n      return { done: false, iterable: [nextIn.value], state: true };\n    },\n    () => false\n  );\n\nexport { intersperse };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * To solve some problems you need to know what the next element(s) is (are) going\n * to be, or look back at the previous value(s).\n *\n * so instead of returning the simple value of the incoming iterator, an object will be returned\n * that looks like this:\n * ```typescript\n *  {\n *    value: 'the current value',\n *    next: [ 'next value', 'next + 1 value' ],\n *    previous: [ 'previous value', 'previous - 1 value' ],\n *  }\n * ```\n *\n * @example\n * ```typescript\n * // the output of: find src \\( -type d -printf \"%p/\\n\" , ! -type d -print \\)\n * const str = `src/\n * src/interface/\n * src/interface/itr8ToArray.ts\n * src/interface/itr8Pushable.ts\n * src/interface/index.ts\n * src/peer/\n * src/peer/observable.ts\n * src/peer/parseJson.ts\n * src/types.ts\n * src/index.ts\n * src/operators/\n * src/operators/numeric/\n * src/operators/numeric/max.ts\n * src/operators/numeric/min.ts\n * src/operators/numeric/average.ts\n * src/operators/numeric/total.ts\n * src/operators/strings/\n * src/operators/strings/lineByLine.ts\n * src/operators/strings/stringToChar.ts\n * src/operators/general/\n * src/operators/general/uniq.ts\n * src/operators/general/reduce.ts\n * src/operators/general/split.ts\n * src/operators/boolean/\n * src/operators/boolean/every.ts\n * src/operators/boolean/some.ts\n * src/operators/index.ts`;\n *\n * const printableTreeView = pipe(\n *   itr8FromString(str),\n *   lineByLine(),\n *   peek(),\n *   // parse the string into a data structure (peeking to next to fill the isLastInLevel & isVeryLast flags)\n *   map(({value, next, prev}) => {\n *     const valueSplit = value.split('/');\n *     const isDir = value.endsWith('/');\n *     const pathLength = valueSplit.length - (isDir ? 2 : 1);\n *     const nextIsDir = next[0]?.endsWith('/');\n *     const nextPathLength = next[0]?.split('/').length - (nextIsDir ? 2 : 1);\n *     const isLastInLevel = nextPathLength < pathLength;\n *     const isVeryLast = next.length === 0;\n *     return { isDir, name: valueSplit[pathLength], level: pathLength, isLastInLevel, isVeryLast };\n *   }),\n *   // turn the data structure into a new string\n *   map(({ isDir, name, level, isLastInLevel, isVeryLast }) => {\n *     const padding = pipe(\n *       itr8FromSingleValue(' \u2502 ')\n *       repeatEach(level - 1),\n *       itr8ToString,\n *     );\n *\n *     const line = !(isLastInLevel || isVeryLast)\n *                ? ' \u251C\u2500'\n *                : ' \u2514\u2500' // (!isVeryLast ? ' \u2514\u2500' : '\u2500\u2534\u2500')\n *     ;\n *\n *     const filename = `${isDir ? '\uD83D\uDCC1' : '\uD83D\uDCC4'} ${name}`;\n *\n *     return `${padding}${level > 0 ? line : ''}${filename}`;\n *   }),\n *   intersperse('\\n'),\n *   itr8ToString,\n * )\n * // =>\n * // \uD83D\uDCC1 src\n * //  \u251C\u2500\uD83D\uDCC1 interface\n * //  \u2502  \u251C\u2500\uD83D\uDCC4 itr8ToArray.ts\n * //  \u2502  \u251C\u2500\uD83D\uDCC4 itr8Pushable.ts\n * //  \u2502  \u2514\u2500\uD83D\uDCC4 index.ts\n * //  \u251C\u2500\uD83D\uDCC1 peer\n * //  \u2502  \u251C\u2500\uD83D\uDCC4 observable.ts\n * //  \u2502  \u2514\u2500\uD83D\uDCC4 parseJson.ts\n * //  \u251C\u2500\uD83D\uDCC4 types.ts\n * //  \u251C\u2500\uD83D\uDCC4 index.ts\n * //  \u251C\u2500\uD83D\uDCC1 operators\n * //  \u2502  \u251C\u2500\uD83D\uDCC1 numeric\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 max.ts\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 min.ts\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 average.ts\n * //  \u2502  \u2502  \u2514\u2500\uD83D\uDCC4 total.ts\n * //  \u2502  \u251C\u2500\uD83D\uDCC1 strings\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 lineByLine.ts\n * //  \u2502  \u2502  \u2514\u2500\uD83D\uDCC4 stringToChar.ts\n * //  \u2502  \u251C\u2500\uD83D\uDCC1 general\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 uniq.ts\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 reduce.ts\n * //  \u2502  \u2502  \u2514\u2500\uD83D\uDCC4 split.ts\n * //  \u2502  \u251C\u2500\uD83D\uDCC1 boolean\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 every.ts\n * //  \u2502  \u2502  \u2514\u2500\uD83D\uDCC4 some.ts\n * //  \u2502  \u2514\u2500\uD83D\uDCC4 index.ts\n * ```\n *\n * @category operators/general\n */\nconst peek = <TIn>(peekForward = 1, peekBackward = 1) =>\n  powerMap<\n    TIn,\n    { value: TIn; previous: TIn[]; next: TIn[] },\n    { previous: TIn[]; current: TIn; next: TIn[] }\n  >(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        // drain what's left of the next elements\n        if (state.next.length === 0 || peekForward === 0) {\n          return {\n            done: true,\n            state: {\n              current: Symbol[\"ITR8_NO_CURRENT\"],\n              next: [],\n              previous: state.previous,\n            },\n          };\n        } else {\n          const [firstOfNext, ...restOfNext] = state.next;\n\n          const newState = {\n            current: firstOfNext,\n            next: restOfNext || [],\n            previous: [state.current, ...state.previous].slice(\n              0,\n              peekBackward as number\n            ),\n          };\n          return {\n            done: false,\n            value: {\n              value: newState.current,\n              next: newState.next,\n              previous: newState.previous,\n            },\n            state: newState,\n          };\n        }\n      } else {\n        // NOT nextIn.done\n        if (state.next.length < peekForward) {\n          const newState = {\n            current: state.current, // still Symbol['ITR8_NO_CURRENT'] until we have enough next values\n            next: [...state.next, nextIn.value].slice(0, peekForward as number),\n            previous: state.previous,\n          };\n          return { done: false, state: newState };\n        } else {\n          // the 'normal' case in the middle of a flow\n          const [firstOfNext, ...restOfNext] = state.next;\n          const current = peekForward === 0 ? nextIn.value : firstOfNext;\n          const newState = {\n            current,\n            next: [...(restOfNext || []), nextIn.value].slice(\n              0,\n              peekForward as number\n            ),\n            previous: (state.current === Symbol[\"ITR8_NO_CURRENT\"]\n              ? state.previous\n              : [state.current, ...(state.previous || [])]\n            ).slice(0, peekBackward as number),\n          };\n          return {\n            done: false,\n            value: {\n              value: newState.current,\n              next: newState.next,\n              previous: newState.previous,\n            },\n            state: newState,\n          };\n        }\n      }\n    },\n    () => ({\n      // hasPrevious: false,\n      previous: [],\n      current: Symbol[\"ITR8_NO_CURRENT\"],\n      next: [],\n      // hasNext\n    })\n  );\n// const peek = (amountNext: number, amountPrevious: number = 0) => {\n\n//   // return <T>(it: Iterator<T> | AsyncIterator<T>):Iterator<T> | AsyncIterator<T> => {\n//   //   let inputs:Array<Promise<IteratorResult<T>> | IteratorResult<T>> = [];\n//   //   let isAsyncInput:boolean;\n//   //   const addInputIfNeeded = async () => {\n//   //     if (inputs.length < amount) {\n//   //       if (isAsyncInput && inputs.length > 0) await inputs[0];\n//   //       const next = it.next();\n//   //       if (isPromise(next)) {\n//   //         // console.log('     add another (async) input, current nr of inputs = ', inputs.length, ' < ', amount);\n//   //         isAsyncInput = true;\n//   //         next.then((n) => {\n//   //           if (!n.done) {\n//   //             // console.log('  then: call addInputIfNeeded(), current nr of inputs = ', inputs.length, ' < ', amount);\n//   //             addInputIfNeeded();\n//   //           }\n//   //         });\n//   //       }\n//   //       inputs.push(next);\n//   //     }\n//   //   }\n\n//   //   const retVal = {\n//   //     [Symbol.asyncIterator]: () => retVal as AsyncIterableIterator<T>,\n//   //     [Symbol.iterator]: () => retVal as IterableIterator<T>,\n//   //     next: () => {\n//   //       // console.log('  next: call addInputIfNeeded(), current nr of inputs = ', inputs.length, ' < ', amount);\n//   //       addInputIfNeeded();\n//   //       if (inputs.length > 0) {\n//   //         const [firstInput, ...remainingInputs] = inputs;\n//   //         inputs = remainingInputs;\n//   //         // console.log('  next: call 2 to addInputIfNeeded(), current nr of inputs = ', inputs.length, ' < ', amount);\n//   //         addInputIfNeeded();\n//   //         // console.log('  next: return ', firstInput);\n//   //         return firstInput;\n//   //       }\n//   //       return isAsyncInput\n//   //         ? Promise.resolve({ done: true, value: undefined }) as Promise<IteratorResult<T>>\n//   //         : { done: true, value: undefined } as IteratorResult<T>;\n//   //     }\n//   //   };\n\n//   //   return itr8FromIterator(retVal as any);\n//   // }\n// };\n\nexport { peek };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * Translate each element into something else by applying the supplied mapping function\n * to each element.\n *\n * The mapping function can be asynchronous (in which case the resulting iterator will be\n * asynchronous regardless of the input iterator)!\n *\n * @param fn\n *\n * @category operators/general\n */\nconst map = <TIn, TOut>(mapFn: (v: TIn) => TOut | Promise<TOut>) =>\n  powerMap<TIn, TOut, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) {\n        return { done: true };\n      } else {\n        return thenable(mapFn(nextIn.value)).then((value) => ({\n          done: false,\n          value,\n        })).src; // return the 'raw' value or promise, not the 'wrapped' version\n\n        // const nextValOrPromise = mapFn(nextIn.value);\n        // if (isPromise(nextValOrPromise)) {\n        //   return (async () => {\n        //     return {\n        //       done: false,\n        //       value: await nextValOrPromise,\n        //     }\n        //   })();\n        // } else {\n        //   return {\n        //     done: false,\n        //     value: nextValOrPromise,\n        //   }\n        // }\n      }\n    },\n    () => undefined\n  );\n\nexport { map };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * The reduce() method executes a user-supplied \"reducer\" callback function on each element of\n * the iterator, in order, passing in the return value from the calculation on the preceding\n * element. The final result of running the reducer across all elements of the array is a\n * single value, so the ouput iterator will only produce 1 result before finishing.\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4 ]),\n *      reduce((acc, cur) => acc + cur, 0),\n *    );\n *    // => [ 10 ]\n * ```\n *\n * The reduce function can be an asynchronous function (in which case the resulting\n * iterator will be asynchronous regardless of the input iterator)!\n *\n * @param reducer\n * @param initialValue: value passed as 'accumulator' on the very first call to the reducer function\n *\n * @category operators/general\n */\nconst reduce = <TIn, TOut>(\n  reducer: (\n    accumulator: TOut,\n    currentValue: TIn,\n    presentIndex?: number\n  ) => TOut | Promise<TOut>,\n  initialValue: TOut\n) =>\n  powerMap<TIn, TOut, { index: number; accumulator: TOut; done: boolean }>(\n    (nextIn, state) => {\n      if (state.done) {\n        return { done: true };\n      }\n\n      const acc = state.accumulator;\n\n      if (nextIn.done) {\n        return { done: false, value: acc, state: { ...state, done: true } };\n      }\n\n      return thenable(reducer(acc, nextIn.value, state.index)).then(\n        (reduced) => ({\n          done: false,\n          state: {\n            ...state,\n            index: state.index + 1,\n            accumulator: reduced,\n          },\n        })\n      ).src;\n\n      // const reduced = params.reducer(acc, nextIn.value, state.index);\n      // if (isPromise(reduced)) {\n      //   return (async () => ({\n      //     done: false,\n      //     state: {\n      //       ...state,\n      //       index: state.index + 1,\n      //       accumulator: await reduced,\n      //     }\n      //   }))();\n      // }\n\n      // // synchronous\n      // return {\n      //   done: false,\n      //   state: {\n      //     ...state,\n      //     index: state.index + 1,\n      //     accumulator: reduced,\n      //   }\n      // };\n    },\n    () => ({ index: 0, accumulator: initialValue, done: false })\n  );\n\nexport { reduce };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Repeat the entire iterator the given amount.\n * If the amount is zero (or negative), you'll end up with an empty iterator.\n *\n * BEWARE: In order to be able to repeat everything, the entire collection must be kept in memory\n * (as opposed to repeatEach where only a single element needs to be stored).\n *\n * @example\n * ```typescript\n * pipe(\n *     itr8FromArray([ 'hello', 'world' ]),\n *     repeat(2)\n *   ) // => [ 'hello', 'world', 'hello', 'world' ]\n * ```\n * @example\n * ```typescript\n * // creating an indentation function is easy (even if it's 0)\n * function getIndentation(indentationLevel, tabSize = 2) {\n *   const singleTab = pipe(\n *      itr8FromSingleValue(' '),\n *      repeat(tabSize),\n *      itr8ToSTring,\n *   );\n *   return pipe(\n *     itr8FromSingleValue(singleTab)\n *     repeat(indentationLevel),\n *     itr8ToSTring,\n *   );\n * }\n * getIndentation(3); // => '      ' (6 spaces)\n * ```\n *\n * @category operators/general\n */\nconst repeat = <TIn>(count = 2) =>\n  powerMap<TIn, TIn, { list: Array<TIn>; remaining: number }>(\n    (nextIn, { list, remaining }) => {\n      if (remaining <= 0) {\n        return { done: true };\n      }\n\n      if (nextIn.done) {\n        return {\n          done: false,\n          iterable: list,\n          state: { list, remaining: remaining - 1 },\n        };\n      }\n\n      return {\n        done: false,\n        value: nextIn.value,\n        state: { list: list.concat(nextIn.value), remaining },\n      };\n    },\n    () => ({ list: [], remaining: count - 1 })\n  );\n\nexport { repeat };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Repeat each element of the iterator for the given amount.\n * If the amount is zero (or negative), you'll end up with an empty iterator.\n *\n * @example\n * ```typescript\n * pipe(\n *     itr8FromArray([ 'hello', 'world' ]),\n *     repeatEach(2)\n *   ) // => [ 'hello', 'hello', 'world', 'world' ]\n * ```\n * @example\n * ```typescript\n * // creating an indentation function is easy (even if it's 0)\n * function getIndentation(indentationLevel, tabSize = 2) {\n *   const singleTab = pipe(\n *      itr8FromSingleValue(' '),\n *      repeatEach(tabSize),\n *      itr8ToSTring,\n *   );\n *   return pipe(\n *     itr8FromSingleValue(singleTab)\n *     repeatEach(indentationLevel),\n *     itr8ToSTring,\n *   );\n * }\n * getIndentation(3); // => '      ' (6 spaces)\n * ```\n *\n * @category operators/general\n */\nconst repeatEach = <TIn>(count = 2) =>\n  powerMap<TIn, TIn, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n      return {\n        done: false,\n        iterable: (function* () {\n          for (let i = 0; i < count; i++) {\n            yield nextIn.value;\n          }\n        })(),\n      };\n    },\n    () => undefined\n  );\n\nexport { repeatEach };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * The runnigReduce() method executes a user-supplied \"reducer\" callback function on each element of\n * the iterator, in order, passing in the return value from the calculation on the preceding\n * element. Eaxch next call produces the result of running the reducer across all elements so far.\n * (called scan in RxJS)\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4 ]),\n *      reduce((acc, cur) => acc + cur, 0),\n *    );\n *    // => [ 1, 3, 6, 10 ]\n * ```\n *\n * The reduce function can be an asynchronous function (in which case the resulting\n * iterator will be asynchronous regardless of the input iterator)!\n *\n * @param reducer\n * @param initialValue: value passed as 'accumulator' on the very first call to the reducer function\n *\n * @category operators/general\n */\nconst runningReduce = <TIn, TOut>(\n  reducer: (\n    accumulator: TOut,\n    currentValue: TIn,\n    presentIndex?: number\n  ) => TOut | Promise<TOut>,\n  initialValue: TOut\n) =>\n  powerMap<TIn, TOut, { index: number; accumulator: TOut; done?: true }>(\n    (nextIn, state) => {\n      if (state.done) {\n        return { done: true };\n      }\n\n      const acc = state.index === 0 ? initialValue : state.accumulator;\n\n      if (nextIn.done) {\n        return { done: true, value: acc, state };\n      }\n\n      return thenable(reducer(acc, nextIn.value, state.index)).then(\n        (reduced) => ({\n          done: false,\n          value: reduced,\n          state: {\n            ...state,\n            index: state.index + 1,\n            accumulator: reduced,\n          },\n        })\n      ).src;\n    },\n    () => ({ index: 0, accumulator: initialValue })\n  );\n\nexport { runningReduce };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Skip the 'amount' first elements and return all the others unchanged.\n *\n * @param amount\n *\n * @category operators/general\n */\nconst skip = <TIn>(params = 0) =>\n  powerMap<TIn, TIn, number>(\n    (nextIn, state) => {\n      if (nextIn.done) return { done: true };\n      if (state < params) return { done: false, state: state + 1 };\n      return { done: false, value: nextIn.value };\n    },\n    () => 0\n  );\n\nexport { skip };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Sorts the elements (using the given sort function if provided).\n * Beware: all elements need to fit in memory before they can be sorted!\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, -2, 7, 4 ]),\n *      sort(), // => [ -2, 1, 4, 7 ]\n *    );\n * ```\n * @example\n * ```typescript\n *    pipe(\n *      itr8.itr8FromArrayAsync([ { v: 1 }, { v: -4 }, { v: 7 }, { v: 2 } ]),\n *      itr8.sort((a:{ v:number }, b:{ v:number }, => a.v - b.v))\n *    );\n * ```\n *\n * @param amount\n *\n * @category operators/general\n */\nconst sort = <TIn>(sortFn?: (a: TIn, b: TIn) => number) =>\n  powerMap<TIn, TIn, { done: boolean; list: TIn[] }>(\n    (nextIn: IteratorResult<any>, state) => {\n      if (state.done) {\n        return { done: true };\n      } else if (nextIn.done) {\n        // sort function modifes the state, so this is not 'pure'\n        return {\n          done: false,\n          iterable: state.list.sort(sortFn ? sortFn : undefined),\n          state: { ...state, done: true },\n        };\n      }\n      return {\n        done: false,\n        state: { ...state, list: [...state.list, nextIn.value] },\n      };\n      // bad (but more performant?): modifying state.list instead of returning a new state!\n      // state.list.push(nextIn.value);\n      // return { done: false, state: { ...state, list: state.list /* [...state.list, nextIn.value] */ } };\n    },\n    () => ({ done: false, list: [] })\n  );\n\nexport { sort };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * like string.split => output arrays of elements and use the given parameter as a delimiter\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 'hello', '|', 'world' ]),\n *      split('|'), // => [ ['hello'], ['world'] ]\n *    );\n * ```\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, true, 2, 3, true, 4 ]),\n *      split(true), // => [ [1], [2,3], [4] ]\n *    );\n * ```\n *\n * @category operators/general\n */\nconst split = <TIn>(delimiter) =>\n  powerMap<TIn, TIn, TIn[] | null>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        if (state === null) {\n          return { done: true };\n        }\n        return { done: false, value: state, state: null };\n      } else if (nextIn.value === delimiter) {\n        return { done: false, value: state || [], state: [] };\n      }\n      return {\n        done: false,\n        state: [...(state === null ? [] : state), nextIn.value],\n      };\n    },\n    () => null\n  );\n\nexport { split };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Only take 'amount' elements and then stop.\n *\n * (Beware: if the source is an Observable or a stream, it will not know that we stopped,\n * so the buffer will keep building up. The observable or stream should be closed by the user!)\n *\n * @param amount\n *\n * @category operators/general\n */\nconst take = <TIn>(count = Infinity) =>\n  powerMap<TIn, TIn, number>(\n    (nextIn, state) => {\n      if (nextIn.done) return { done: true };\n      if (state < count) {\n        const newState = state + 1;\n        return {\n          done: false,\n          value: nextIn.value,\n          state: newState,\n          isLast: newState == count,\n        };\n      }\n      return { done: true };\n    },\n    () => 0\n  );\n\nexport { take };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Tap will run a function 'on the side' without while passing the iterator\n * unchanged to the next.\n *\n * @param fn\n *\n * @category operators/general\n */\nconst tap = <TIn>(tapFn: (TIn) => void) =>\n  powerMap<TIn, TIn, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) {\n        return { done: true };\n      } else {\n        try {\n          tapFn(nextIn.value);\n        } catch (e) {\n          console.warn(\"Tap function caused an exception\", e, e.stack);\n        }\n        return { done: false, value: nextIn.value };\n      }\n    },\n    () => undefined\n  );\n\nexport { tap };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Only returns unique elements. It works with a simple compare, so ok for simple types like\n * numbers and strings, but for objects it will work on the reference. If you need something\n * more sophisticated, ```uniqBy(...)``` is propably what you need.\n *\n * Beware: all unique elements need to fit in memory to keep track of the ones that we already\n * have seen!\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, -2, 7, 4, -2, -2, 4, 1 ]),\n *      uniq(), // => [ 1, -2, 7, 4 ]\n *    );\n * ```\n *\n * @category operators/general\n */\nconst uniq = <TIn>() =>\n  powerMap<TIn, TIn, Set<TIn>>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        return { done: true };\n      } else if (state.has(nextIn.value)) {\n        return { done: false, state };\n      }\n      const newState = new Set(state);\n      newState.add(nextIn.value);\n      return { done: false, value: nextIn.value, state: newState };\n    },\n    () => new Set([])\n  );\n\nexport { uniq };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Only returns unique elements by comparing the result of the mapping function applied\n * to the element.\n * Beware: all mapped elements need to fit in memory to keep track of the ones that we already\n * have seen!\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8.itr8FromArrayAsync([ { id: 1 }, { id: 2 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 4 }, { id: 3 } ])\n *      itr8.uniqBy((a:{ id:number }) => id ) // => [ [ { id: 1 }, { id: 2 }, { id: 3 }, { id: 4 } ];\n *    );\n * ```\n *\n * @param mapFn\n *\n * @category operators/general\n */\nconst uniqBy = <TIn, TMapFn>(mapFn: (v: TIn) => TMapFn) =>\n  powerMap<TIn, TIn, Set<TMapFn>>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n      const hash = mapFn(nextIn.value);\n      if (state.has(hash)) {\n        return { done: false, state };\n      }\n      const newState = new Set(state);\n      newState.add(hash);\n      return { done: false, value: nextIn.value, state: newState };\n    },\n    () => new Set([])\n  );\n\nexport { uniqBy };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * The zip() operator outputs tuples containing 1 element from the first and\n * one element from the second iterator. The first iterator is leading, so when\n * the first iterator is done, the output iterator is done. When the second iterator\n * is 'shorter', the tuples will contain undefined as the second element.\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4 ]),\n *      zip(itr8FromArray([ 'a', 'b', 'c', 'd' ]), // => [ [1, 'a'], [2, 'b'], [3, 'c'], [4, 'd' ] ]\n *    );\n * ```\n *\n * @param secondIterator\n *\n * @category operators/general\n */\nconst zip = <TIn>(secondIterator: Iterator<any> | AsyncIterator<any>) =>\n  powerMap<TIn, TIn, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n\n      return thenable(secondIterator.next()).then((secondNext) => ({\n        done: false,\n        value: [nextIn.value, (secondNext as IteratorResult<any>).value],\n      })).src;\n\n      // const secondNext = secondIterator.next();\n      // if (isPromise(secondNext)) {\n      //   return (async () => ({\n      //     done: false,\n      //     value: [nextIn.value, (await secondNext as IteratorResult<any>).value],\n      //   }))();\n      // }\n\n      // // synchronous\n      // return {\n      //   done: false,\n      //   value: [nextIn.value, (secondNext as IteratorResult<any>).value],\n      // };\n    },\n    () => undefined\n  );\n\nexport { zip };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Output the average.\n * @example\n * ```typescript\n *    pipe(\n *      itr8Range(1,100),\n *      average(),  // => [ 50 ]\n *    );\n * ```\n *\n * @param it\n * @param amount\n *\n * @category operators/numeric\n */\nconst average = () =>\n  powerMap<number, number, { done: boolean; count: number; sum: number }>(\n    (nextIn, state) => {\n      if (state.done) return { done: true };\n      if (nextIn.done)\n        return {\n          done: false,\n          value: state.sum / state.count,\n          state: { ...state, done: true },\n        };\n      const newCount = state.count + 1;\n      const newSum = state.sum + nextIn.value;\n      return { done: false, state: { ...state, count: newCount, sum: newSum } };\n    },\n    () => ({ done: false, count: 0, sum: 0 })\n  );\n\nexport { average };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Output a single thing which is the highest of all values.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 7, 4 ]),\n *      total(), // => [ 7 ]\n *    );\n * ```\n *\n * @param amount\n *\n * @category operators/numeric\n */\nconst max = () =>\n  powerMap<number, number, { done: boolean; max: number }>(\n    (nextIn, state) => {\n      if (state.done) {\n        return { done: true };\n      } else if (nextIn.done) {\n        return {\n          done: false,\n          value: state.max,\n          state: { ...state, done: true },\n        };\n      }\n      return {\n        done: false,\n        state: { ...state, max: Math.max(state.max, nextIn.value) },\n      };\n    },\n    () => ({ done: false, max: -Infinity })\n  );\n\nexport { max };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Output a single thing which is the lowest of all values.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, -2, 7, 4 ]),\n *      total(), // => [ -2 ]\n *    );\n * ```\n * @param amount\n *\n * @category operators/numeric\n */\nconst min = () =>\n  powerMap<number, number, { done: boolean; min: number }>(\n    (nextIn, state) => {\n      if (state.done) {\n        return { done: true };\n      } else if (nextIn.done) {\n        return {\n          done: false,\n          value: state.min,\n          state: { ...state, done: true },\n        };\n      }\n      return {\n        done: false,\n        state: { ...state, min: Math.min(state.min, nextIn.value) },\n      };\n    },\n    () => ({ done: false, min: Infinity })\n  );\n\nexport { min };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Output the percentile(x)\n * It is simply using the nearest-rank method,\n * cfr. [Wikipedia](https://en.wikipedia.org/wiki/Percentile#Calculation_methods)\n * but it will only keep an ordered list of the n largest elements so far, which means that\n * computing the 90th percentile only needs to keep 10% of all the values seen in memory,\n * but the 50th percentile needs a buffer of 50% of all values.\n *\n * Various 'streaming' implementations exist, but they are more complex, so ... maybe later.\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8Range(1,100),\n *      percentile(95),  // => [ 95 ]\n *    );\n * ```\n *\n * @param amount\n *\n * @category operators/numeric\n */\nconst percentile = (percentage: number) =>\n  powerMap<\n    number,\n    number,\n    { done: boolean; count: number; topArray: number[] }\n  >(\n    (nextIn, state) => {\n      if (state.done) return { done: true };\n      if (nextIn.done)\n        return {\n          done: false,\n          value: state.topArray[0],\n          state: { ...state, done: true },\n        };\n      const newCount = state.count + 1;\n      const newTopArraySize =\n        Math.floor(((100 - percentage) / 100) * newCount) + 1;\n      const newTopArray = [...state.topArray, nextIn.value];\n      newTopArray.sort((a, b) => a - b);\n      while (newTopArraySize < newTopArray.length) {\n        newTopArray.shift();\n      }\n      // console.log('value', nextIn.value, 'percentage', percentage, 'count', state.count, 'newTopArraySize', newTopArraySize, 'state.topArray', state.topArray);\n      return {\n        done: false,\n        state: { ...state, count: newCount, topArray: newTopArray },\n      };\n    },\n    () => ({ done: false, count: 0, topArray: [] })\n  );\n\nexport { percentile };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * On every item, output the average so far\n * @example\n * ```typescript\n *    pipe(\n *      itr8Range(1,10),\n *      runningAverage(),  // => [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5]\n *    );\n * ```\n *\n * @param it\n * @param amount\n *\n * @category operators/numeric\n */\nconst runningAverage = () =>\n  powerMap<number, number, { done: boolean; count: number; sum: number }>(\n    (nextIn, state) => {\n      if (nextIn.done) return { done: true };\n      const newCount = state.count + 1;\n      const newSum = state.sum + nextIn.value;\n      return {\n        done: false,\n        state: { ...state, count: newCount, sum: newSum },\n        value: newSum / newCount,\n      };\n    },\n    () => ({ done: false, count: 0, sum: 0 })\n  );\n\nexport { runningAverage };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * On every item, output the percentile(x) so far\n * @example\n * ```typescript\n *    pipe(\n *      itr8Range(1,10),\n *      percentile(50),  // => [ 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 5 ]\n *    );\n * ```\n *\n * @param amount\n *\n * @category operators/numeric\n */\nconst runningPercentile = (percentage: number) =>\n  powerMap<number, number, { count: number; topArray: number[] }>(\n    (nextIn, state) => {\n      if (nextIn.done) return { done: true };\n      const newCount = state.count + 1;\n      const newTopArraySize =\n        Math.floor(((100 - percentage) / 100) * newCount) + 1;\n      const newTopArray = [...state.topArray, nextIn.value];\n      newTopArray.sort((a, b) => a - b);\n      while (newTopArraySize < newTopArray.length) {\n        newTopArray.shift();\n      }\n      // console.log('value', nextIn.value, 'percentage', percentage, 'count', state.count, 'newTopArraySize', newTopArraySize, 'state.topArray', state.topArray);\n      return {\n        done: false,\n        state: { ...state, count: newCount, topArray: newTopArray },\n        value: newTopArray[0],\n      };\n    },\n    () => ({ count: 0, topArray: [] })\n  );\n\nexport { runningPercentile };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * On every item, output the total so far.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4 ]),\n *      runningTotal(),  // => [ 1, 3, 6, 10 ]\n *    );\n * ```\n *\n * @param amount\n *\n * @category operators/numeric\n */\nconst runningTotal = () =>\n  powerMap<number, number, number>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n      const newTotal = state + nextIn.value;\n      return { done: false, value: newTotal, state: newTotal };\n    },\n    () => 0\n  );\n\nexport { runningTotal };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Output a single thing containing the sum of all values.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4 ]),\n *      total(), // => [ 10 ]\n *    );\n * ```\n *\n * @param amount\n *\n * @category operators/numeric\n */\nconst total = () =>\n  powerMap<number, number, { done: boolean; total: number }>(\n    (nextIn, state) => {\n      if (state.done) {\n        return { done: true };\n      } else if (nextIn.done) {\n        return {\n          done: false,\n          value: state.total,\n          state: { ...state, done: true },\n        };\n      }\n      return {\n        done: false,\n        state: { ...state, total: state.total + nextIn.value },\n      };\n    },\n    () => ({ done: false, total: 0 })\n  );\n\nexport { total };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * The input must be a stream of characters or strings,\n * and the output will be 1 string for each line.\n * \\n is used as the default line separator, but you can pass any string as a parameter\n * to be used as the line separator!\n *\n * @example\n * ```typescript\n *    // simplest case: an iterator of single characters\n *    pipe(\n *      itr8FromArray([ 'h', 'e', 'l', 'l', 'o', '\\n', 'w', 'o', 'r', 'l', 'd' ]),\n *      lineByLine(), // => [ 'hello', 'world' ]\n *    );\n *\n *    // second case: an iterator of string chunks\n *    pipe(\n *      itr8FromArray(['Hel', 'lo\\nWorld\\n\\nGo', 'od', 'by', 'e', '\\nSpace', '!']),\n *      lineByLine(), // => ['Hello', 'World', '', 'Goodbye', 'Space!'];\n *    );\n *\n *    // thrid case: the newline separator is something else than \\n\n *    pipe(\n *      itr8FromArray(['Hel', 'lo<br>>World<br><br>Go', 'od', 'by', 'e', '<br>Space', '!']),\n *      lineByLine(), // => ['Hello', 'World', '', 'Goodbye', 'Space!'];\n *    );\n * ```\n * @param {string} separator: the string that will be considered the newline sequence\n * @category operators/strings\n */\nconst lineByLine = (splitBy = \"\\n\") =>\n  powerMap<string, string, { done: boolean; buffer: string }>(\n    (nextIn, { done, buffer }) => {\n      if (nextIn.done) {\n        if (done) {\n          return { done: true, state: { done: true, buffer: \"\" } };\n        } else {\n          return {\n            done: false,\n            value: buffer,\n            state: { done: true, buffer: \"\" },\n          };\n        }\n      } else {\n        const lines = nextIn.value.split(splitBy as string);\n        if (lines.length === 1) {\n          return {\n            done: false,\n            state: { done: false, buffer: buffer + lines[0] },\n          };\n        } else if (lines.length === 2) {\n          return {\n            done: false,\n            value: buffer + lines[0],\n            state: { done: false, buffer: lines[1] },\n          };\n        } else {\n          return {\n            done: false,\n            iterable: [buffer + lines[0], ...lines.slice(1, -1)],\n            state: { done: false, buffer: lines[lines.length - 1] },\n          };\n        }\n      }\n    },\n    () => ({ done: false, buffer: \"\" })\n  );\n\n// Original implementation by combining other operators\n// const lineByLine = () => compose(\n//   stringToChar(),\n//   split('\\n'),\n//   map(x => x.reduce((acc, cur) => acc + cur, '')),\n// );\n\nexport { lineByLine };\n", "import { itr8FromString } from \"../../interface/itr8FromString.js\";\nimport { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Takes all strings from the input and outputs them as single characters\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 'hello', 'world' ]),\n *      stringToChar(), // => [ 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd' ]\n *    );\n * ```\n *\n * @category operators/strings\n */\nconst stringToChar = () =>\n  powerMap<string, string>(\n    (nextIn, _state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n      return {\n        done: false,\n        iterable: itr8FromString(nextIn.value),\n      };\n    },\n    () => undefined\n  );\n\nexport { stringToChar };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Only useful on async iterators.\n *\n * Wait for x milliseconds of 'no events' before firing one.\n * So an event will either not be handled (busy period),\n * or handled after the calm period (so with a delay of x milliseconds)\n *\n * @category operators/timeBased\n */\nconst debounce = <TIn>(cooldownMilliseconds: number) =>\n  powerMap<TIn, TIn, number>(\n    (nextIn, state) => {\n      if (nextIn.done) return { done: true };\n      const newState = Date.now();\n      const timePassed = newState - state;\n      if (timePassed > cooldownMilliseconds) {\n        return { done: false, value: nextIn.value, state: newState };\n      }\n      return { done: false, state: newState };\n    },\n    () => -Infinity\n  );\n\nexport { debounce };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Simply delay every element by the given nr of milliseconds.\n * (Will always produce an async iterator!).\n *\n * @category operators/timeBased\n */\nconst delay = <TIn>(timeout: number) =>\n  powerMap<TIn, TIn, void>(\n    (nextIn, _state) => {\n      return new Promise<any>((resolve /*, reject*/) => {\n        setTimeout(() => resolve(nextIn), timeout);\n      });\n    },\n    () => undefined\n  );\n\nexport { delay };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Only useful on async iterators.\n *\n * Only throw events at most every x milliseconds.\n *\n * So when a few events happen quickly, only the first one will be handled,\n * and the next ones will be ignored until enough time (x ms) has passed with\n * the previously handled event.\n *\n * @category operators/timeBased\n */\nconst throttle = <TIn>(throttleMilliseconds: number) =>\n  powerMap<TIn, TIn, number>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n      const now = Date.now();\n\n      if (now - state > throttleMilliseconds) {\n        return { done: false, value: nextIn.value, state: now };\n      }\n      return { done: false, state };\n    },\n    () => -Infinity\n  );\n\nexport { throttle };\n"],
  "mappings": "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",
  "names": ["isPromise", "p", "AsyncFunction", "thenable", "x", "newX", "args", "value", "okHandler", "retVal", "forLoop", "initialStateFactory", "testBeforeEach", "afterEach", "codeToExecute", "initialState", "isSyncInit", "testResult", "isSyncTest", "_", "isSyncBody", "firstStateAfterEach", "isSyncAfterBody", "state", "compose", "first", "params", "acc", "cur", "arg", "pipe", "input", "fn1", "functionsToApply", "forEach", "handler", "options", "it", "throwCount", "maxRunningHandlers", "runningHandlers", "waitForOpenSpot", "addToRunningHandlersList", "handlerPossiblePromise", "tryHandler", "v", "isPromise", "e", "nextPromiseOrValue", "nextPromise", "handleNext", "nextValue", "next", "handlerPossiblePromiseIn", "handlerPromise", "itr8FromIterator", "iterator", "retVal", "fn1", "moreFns", "prev", "cur", "itr8FromArray", "a", "itr8FromIterator", "itr8FromArrayAsync", "a", "itr8FromIterator", "x", "itr8FromIterable", "it", "itr8FromIterator", "itr8FromSingleValue", "v", "itr8FromIterator", "itr8FromSingleValueAsync", "v", "itr8FromIterator", "itr8FromString", "s", "itr8FromIterable", "itr8FromStringAsync", "s", "itr8FromIterator", "x", "itr8Pushable", "bufferSize", "buffer", "currentResolve", "currentDataPromise", "createNewCurrentDataPromise", "resolve", "retVal", "value", "itr8FromIterator", "itr8Interval", "intervalMilliseconds", "it", "itr8Pushable", "interval", "origDone", "itr8Range", "from", "to", "step", "stepValue", "upwards", "itr8FromIterator", "i", "itr8RangeAsync", "from", "to", "step", "stepValue", "upwards", "itr8FromIterator", "i", "itr8ToArray", "iterator", "n", "isPromise", "asyncResult", "result", "nSync", "itr8ToObject", "iterator", "n", "isPromise", "asyncResult", "k", "v", "result", "nSync", "itr8ToString", "iterator", "n", "isPromise", "asyncResult", "result", "nSync", "powerMap", "nextFn", "initialStateFactory", "operatorFunction", "itIn", "pState", "operatorState", "nextInPromiseOrValue", "isAsyncInput", "updateNextInPromiseOrValue", "isPromise", "isAsyncNextFn", "isAsyncCurrentOutputIterator", "generateNextReturnValSync", "possibleNextValueOrPromise", "generateNextReturnValAsync", "possibleNext", "curNextFnResult", "itr8FromIterable", "callUpdateNextInPromiseOrValue", "nextFnResponse", "currentOutputIteratorNext", "doUpdateNextInPromiseOrValue", "alreadyKnownNextFnResponse", "alreadyKnownCurrentOutputIteratorNext", "nextIn", "curNextFnResultPromiseOrValue", "generateNextReturnVal", "retVal", "itr8FromIterator", "transIt", "input", "iterator", "iterable", "f", "forLoop", "n", "thenable", "_forLoopResult", "newState", "takeWhile", "filterFn", "powerMap", "nextIn", "_state", "thenable", "filterFnResult", "itr8ToMultiIterable", "it", "subscriberMap", "buffer", "cleanBuffer", "minIndex", "pipe", "takeWhile", "forEach", "outIt", "index", "value", "error", "itr8FromIterator", "mostRecent", "initalValue", "it", "nextOut", "resolveNextOutRead", "handleInputPromise", "nextOutRead", "isPromise", "resolve", "reject", "retVal", "itr8FromIterator", "prefetch", "amount", "it", "inputs", "isAsyncInput", "addInputIfNeeded", "next", "isPromise", "n", "retVal", "firstInput", "remainingInputs", "itr8FromIterator", "parallel", "options", "transIt", "moreTransIts", "transItsCombined", "acc", "cur", "input", "inIt", "iteratorOfIterables", "outIteratorOfIterators", "itr8Pushable", "pipe", "itr8FromIterator", "forEach", "inElement", "itOfItsElement", "subIt", "itr8FromSingleValue", "v", "itr8ToArray", "subItElement", "iteratorOfValues", "outIterator", "callbackIt", "every", "filterFn", "powerMap", "nextIn", "state", "thenable", "result", "some", "filterFn", "powerMap", "nextIn", "state", "thenable", "result", "dedup", "mapFn", "powerMap", "nextIn", "state", "valueToCompare", "thenable", "v", "filter", "filterFn", "powerMap", "nextIn", "_state", "thenable", "result", "flatten", "powerMap", "nextIn", "_state", "groupPer", "groupSize", "powerMap", "nextIn", "state", "intersperse", "intersperseThing", "powerMap", "nextIn", "state", "peek", "peekForward", "peekBackward", "powerMap", "nextIn", "state", "firstOfNext", "restOfNext", "newState", "map", "mapFn", "powerMap", "nextIn", "_state", "thenable", "value", "reduce", "reducer", "initialValue", "powerMap", "nextIn", "state", "acc", "thenable", "reduced", "repeat", "count", "powerMap", "nextIn", "list", "remaining", "repeatEach", "count", "powerMap", "nextIn", "_state", "i", "runningReduce", "reducer", "initialValue", "powerMap", "nextIn", "state", "acc", "thenable", "reduced", "skip", "params", "powerMap", "nextIn", "state", "sort", "sortFn", "powerMap", "nextIn", "state", "split", "delimiter", "powerMap", "nextIn", "state", "take", "count", "powerMap", "nextIn", "state", "newState", "tap", "tapFn", "powerMap", "nextIn", "_state", "e", "uniq", "powerMap", "nextIn", "state", "newState", "uniqBy", "mapFn", "powerMap", "nextIn", "state", "hash", "newState", "zip", "secondIterator", "powerMap", "nextIn", "_state", "thenable", "secondNext", "average", "powerMap", "nextIn", "state", "newCount", "newSum", "max", "powerMap", "nextIn", "state", "min", "powerMap", "nextIn", "state", "percentile", "percentage", "powerMap", "nextIn", "state", "newCount", "newTopArraySize", "newTopArray", "a", "b", "runningAverage", "powerMap", "nextIn", "state", "newCount", "newSum", "runningPercentile", "percentage", "powerMap", "nextIn", "state", "newCount", "newTopArraySize", "newTopArray", "a", "b", "runningTotal", "powerMap", "nextIn", "state", "newTotal", "total", "powerMap", "nextIn", "state", "lineByLine", "splitBy", "powerMap", "nextIn", "done", "buffer", "lines", "stringToChar", "powerMap", "nextIn", "_state", "itr8FromString", "debounce", "cooldownMilliseconds", "powerMap", "nextIn", "state", "newState", "delay", "timeout", "powerMap", "nextIn", "_state", "resolve", "throttle", "throttleMilliseconds", "powerMap", "nextIn", "state", "now"]
}
