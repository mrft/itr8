{
  "version": 3,
  "sources": ["../src/util/index.ts", "../src/interface/forEach.ts", "../src/interface/itr8FromArray.ts", "../src/interface/itr8FromArrayAsync.ts", "../src/interface/itr8FromImpureFunction.ts", "../src/interface/itr8FromIterable.ts", "../src/interface/itr8FromSingleValue.ts", "../src/interface/itr8FromSingleValueAsync.ts", "../src/interface/itr8FromString.ts", "../src/interface/itr8FromStringAsync.ts", "../src/interface/itr8Pushable.ts", "../src/interface/itr8Interval.ts", "../src/interface/itr8Range.ts", "../src/interface/itr8RangeAsync.ts", "../src/interface/itr8ToArray.ts", "../src/interface/itr8ToObject.ts", "../src/interface/itr8ToString.ts", "../src/operators/general/powerMap.ts", "../src/operators/general/takeWhile.ts", "../src/interface/itr8ToMultiIterable.ts", "../src/operators/async/mostRecent.ts", "../src/operators/async/prefetch.ts", "../src/operators/async/parallel.ts", "../src/operators/boolean/every.ts", "../src/operators/boolean/some.ts", "../src/operators/general/map.ts", "../src/operators/general/branchAndMerge.ts", "../src/operators/general/dedup.ts", "../src/operators/general/distribute.ts", "../src/operators/general/filter.ts", "../src/operators/general/flatMap.ts", "../src/operators/general/flatten.ts", "../src/operators/general/groupPer.ts", "../src/operators/general/identity.ts", "../src/operators/general/intersperse.ts", "../src/operators/general/peek.ts", "../src/operators/general/reduce.ts", "../src/operators/general/repeat.ts", "../src/operators/general/repeatEach.ts", "../src/operators/general/runningReduce.ts", "../src/operators/general/skip.ts", "../src/operators/general/skipWhile.ts", "../src/operators/general/sort.ts", "../src/operators/general/split.ts", "../src/operators/general/take.ts", "../src/operators/general/tap.ts", "../src/operators/general/uniq.ts", "../src/operators/general/uniqBy.ts", "../src/operators/general/zip.ts", "../src/operators/numeric/average.ts", "../src/operators/numeric/max.ts", "../src/operators/numeric/min.ts", "../src/operators/numeric/percentile.ts", "../src/operators/numeric/runningAverage.ts", "../src/operators/numeric/runningPercentile.ts", "../src/operators/numeric/runningTotal.ts", "../src/operators/numeric/total.ts", "../src/operators/strings/lineByLine.ts", "../src/operators/strings/stringToChar.ts", "../src/operators/timeBased/debounce.ts", "../src/operators/timeBased/delay.ts", "../src/operators/timeBased/throttle.ts"],
  "sourcesContent": ["/**\n * Utility functions that are used internally, but that can be used by anyone to\n * help create operators that support both synchronous and asynchronous parameters\n * (by using thenable, forLoop or isPromise).\n *\n * @module\n */\n\n// https://www.typescriptlang.org/play?#code/MYewdgzgLgBAhgLjAVwLYCMCmAnA2gXRgF4ZcBGAGhgCYqBmKgFnwG4AoUSWdBabASzABzAsVIBycJnFVxUAO4gZcgBbZM02QDMQybONZs2W5GGBR+4GFBABJKDjg3sAHgAqAPgAUiAILZsOABPdw8ASgR7R2dQmABvNhgkmHUoPTB4XABlIIwQABsAOn4HQOd8LzD2AF8jEzMLKxLokGw3EH9AkM8vZrLWyNKnVtCIzuDYhOSYfMxYdQhkfNgSAnZp2dgwdeT5FX5ZmC8AQi8Mkj7h7EKwTAAPKEqwwoATKTD4xOnkhaWoQoADsgICozoUAG5wfLITBVL5JWrTVLpFKYRbLGpGYymcyWMAAKhScGEmC80Dg2CgSDQWGwVEwYBe1IwOA+U2S-C0R3JlJgLhgDJebPh3x02COmxg-DEPKgLClfJIgvl-AA1Krhd8tTAgvxMPkXlKdlrEclqgL8hBMJ9tTAxRK5gqSLKVTAPErGSqALRezW25K6-WG-jG76mhFsWpsAD00ZgnAgBUwhXyICEXlwhSzgRJXgYAHYwvg4bH4+BE7MU2mM1nCjmhKSAKwUahFuFGUsJpNV9OXZztcZBLw2KL9bA+MKT9gccuwPpieukhgATnbUCCAOtbjcOYgL2QwBw7lsYAobgA8sgoB4xL0hs5Bi1XG4Tx4qLWARS4KgIAh4GAgg+Igb1HK53Eva9pwTWBUDgAEEG3Xd90PVxiSCCg0JvEh6lxcBCTvR8xxcFAWWwN87TABAvDuBA0KAm86JtZJJVuB4TzEEobnuR44WmPYDlJY5WKgE9XneJitUDA0KLObjRMhaFYVDaZhPYi5-mEypQ1qKNoJgWCAWoBCd2JPcDyPNCMIArCjhKQiwJI2lyK0SjqNogD6P-QDiBvdkkmRbAMj875hL-SofIk-09NU84pQ07itJFW09OweznAAJTRP5iJpHAbOC-1kgUmE-xc2S2LACEoRhMIKCSwqYDeW4-xisTbjqhqYHDf0AoybBlLNEVzTgCAYFAmJHLyyMjD0rQDlKYykPM1CAKsoIbJwxoCVsqlxpGTCqBcqiaMY4CYHQEAk2JP0khYuTYs4zTeN2fZZhOVqmthSLpk5I4yta4rYRu-0pMNAHqswAaI1tGKOPih5EumHSZtnGAQC0LQrSpRDTOQizVswsRNrxfC7L2lb1qob9dDAKlJuwYG7oquGuIR57bsdUBTFKMQAAZQ34t6hPutqvoK5IudpnAxElnnVRgMgoalLkvFl6WGNQGmoGB21QZgcHFKV7qVPulmnu06aZy4GZ+FQOyccgPGKbWjacS20ndvvfbrKpzXueZWlGcdWH1NZnjQ0lNXxRIfmRUFwSPvE8WkijmWtel+XFfqpJftV9PxRcEhqe5nXtT1g2YSN7P9dN0PzaGy2YzjYm8JgAF+E3Lxa1wEB4IdsyUKp7AhDQBkoF-GBCDCFHrbgagifmnAvAM4c7C98c4Fqo4aPpzy7hgTOt7c3eIv3m9Wyg8tu1TXt14HAJgh8Vt2y7Ssb7vJ9766Lx0cxuZV-Jl4dAW9n4vyvm-asfZWhf0fvkW2JQAHryASAycVQgA\n\nimport { TThenable } from \"../types.js\";\n\n// THIS MIGHT BE AN ALTERNATIVE TO REMOVE THE DEPENDENCY to Node's uil/types\n////////////////////////////////////////////////////////////////////////////\n/**\n * Check whether the parameter is a promise.\n *\n * @param p\n * @returns true if p is a promise\n *\n * @category util\n */\nconst isPromise = function isPromise(p: unknown): p is Promise<unknown> {\n  return (\n    p !== undefined &&\n    p !== null &&\n    Object.prototype.toString.call(p) === \"[object Promise]\"\n  );\n};\n\n// import { isPromise } from 'util/types'\n\n// try {\n//   // eslint-disable-next-line @typescript-eslint/no-var-requires\n//   isPromise = require('util/types').isPromise;\n// } catch {\n//   // ignore\n// }\n\n/**\n * Shim for allowing async function creation similar to new Function.\n *\n * Found here: https://davidwalsh.name/async-function-class\n *\n * @example\n * ```javascript\n * const fetchPage = new AsyncFunction(\"url\", \"return await fetch(url);\");\n * ```\n */\nconst AsyncFunction = Object.getPrototypeOf(async function () {\n  /* empty */\n}).constructor;\n\n/**\n * (Word play on then-able an th-enable)\n *\n * This utility function makes sure that any value (Promise or otherwise)\n * will be turned into an object with a then property, so that we can write the same code\n * regardless of whether the input is sync or async, but guaranteeing that\n * if the input is sync, all operations will also be called synchronously.\n *\n * The original input object is available under the thenable(...).src property.\n *\n * After the then callback has finished, the Object's 'value' property will be set\n * to the 'resolved' value.\n *\n * @example\n * ```typescript\n * // the same code can be applied without changes to a promise or a non promise\n * // by doing it all in the then-callback\n * thenable(123)\n *  .then(\n *    (v) => {\n *      console.log(v);\n *      return getSomeOtherSyncOrAsyncVal(v);\n *    }\n *  )\n *  .then(\n *    (otherVal) => {\n *      console.log(otherVal);\n *      return getYetAnotherVal(v);\n *    }\n *  )\n * ```\n *\n * ???\n * MAYBE a better solution would be to have a function called ```doAfter(value, (value) => { your code })```\n * that checks whether it is a promise or not, and returns the result of the handler?\n * But without the pipe operator it would be a pain to chain them, unless it will return an object\n * with some properties like ```{ result, doAfter:... }```\n * or maybe thenable should always return a new object with properties ```{ src, then, finally, ... }``` so\n * that the interface resembles a promise, but if we need the actual promise or value\n * we should simply call src?\n *\n * @param x a Promise or a regular value\n * @returns an object that has a then function and a src property pointing to the original input\n *          regardless whether it is a Promise or not\n *\n * @category util\n */\nconst thenable = <T>(x: T): TThenable<T> => {\n  if (isPromise(x)) {\n    // console.log(`[thenable] ASYNC: ${x}`);\n    const newX = {\n      src: x,\n      then: (...args) => thenable(x.then(...args)),\n    };\n    // make sure the value gets added to this object after the promise resolves\n    x.then((value) => (newX[\"value\"] = value));\n    return newX;\n  } else {\n    // console.log(`[thenable] SYNC: ${x}`);\n    if (typeof (x as any)?.then === \"function\") {\n      return x as unknown as TThenable;\n    } else {\n      // needed, because in strict mode it is impossble to set a property\n      // on a string primitive (and in non-strict mode the set value cannot be read again)\n      const newX = {\n        src: (x as any)?.src !== undefined ? (x as any).src : x,\n        then: (okHandler: (v: unknown, isSync?: boolean) => unknown) => {\n          const retVal = thenable(okHandler(x, true));\n          retVal[\"value\"] = retVal.src;\n          return retVal;\n        },\n        value: x,\n      };\n      return newX;\n    }\n  }\n};\n\n/**\n * After I created the thenable function, my code became easier, because I could write\n * the same code regardless whether the input was synchronous or asynchronous.\n * But by wrapping something with thenable, the check whether it was a Promise or not\n * was done on every invocation.\n *\n * In a library that is about iterators, we expect this to be called many times.\n * So it feels like it could make sense to create a version that 'remembers'\n * the conclusions from the first run, and that will use that knowledge in the second run\n * (assuming that every next element in an iterator will be a promise if the first was a promise\n * and vice versa)\n *\n * A few tests seemed to indicate that calling isPromise often if about 10x slower than\n * checking if a variable is true or false (or is a specific symbol), so there should be\n * gain to be made with this.\n *\n * @example\n * ```typescript\n * // instead of\n * for (x of [1, 2, 3]) {\n *   thenable(x).then((v) => console.log(v));\n * }\n * // do something like\n * const cachedThenable = thenableFactory(1);\n * for (x of [1, 2, 3]) {\n *   cachedThenable(x).then((v) => console.log(v))\n * }\n * ```\n *\n * @param x a simple value or a promise, for which you need to execute some code\n * @returns a thenable(...)-like function that has assumptions built-in based on the first x\n */\nconst thenableFactory = <T>(\n  y: T | Promise<T>,\n): ((x: T | Promise<T>) => TThenable<T>) => {\n  let cachedThenable;\n  let firstRun = true;\n  if (isPromise(y)) {\n    // console.log(`[thenableFactory] ASYNC: ${y}`);\n    // let genericThenAsync = (x: Promise<T>, ...args) => {\n    //   const thenResult = x.then(...args);\n    //   if (firstRun) {\n    //     firstRun = false;\n    //     cachedThenable = thenableFactory(thenResult);\n    //     genericThenAsync = (x2: Promise<T>, ...args) => cachedThenable(x2.then(...args));\n    //   }\n    //   return cachedThenable(thenResult);\n    // };\n\n    return function asyncThenable(x: Promise<T>) {\n      const newX = {\n        src: x,\n        then: (...args) => {\n          if (firstRun) {\n            firstRun = false;\n            const thenResult = x.then(...args);\n            cachedThenable = thenableFactory(thenResult);\n            return cachedThenable(thenResult);\n          }\n          return cachedThenable(x.then(...args));\n        },\n      };\n      // make sure the value gets added to this object after the promise resolves\n      x.then((value) => (newX[\"value\"] = value));\n      return newX;\n    };\n    // .bind({}); // needed for 'this' to work\n  } else {\n    // console.log(`[thenableFactory] SYNC: ${y}`);\n    // let genericThenSync = (x: T, okHandler: (v: unknown, isSync?: boolean) => unknown) => {\n    //   if (firstRun) {\n    //     firstRun = false;\n    //     // console.log(`[thenableFactory] set cached thenable = ${okHandlerResult}`);\n    //     cachedThenable = thenableFactory(okHandlerResult);\n    //     // overwrite genericThenSync with a version that does not need to check anymore\n    //     genericThenSync = (x2: T, okHandler2: (v: unknown, isSync?: boolean) => unknown) => {\n    //       const retVal2 = cachedThenable(okHandler2(x2, true));\n    //       // console.log(`genericThenSync ${x2} -> ${retVal2.value}`);\n    //       retVal2[\"value\"] = retVal2.src;\n    //       return retVal2;\n    //     };\n    //   }\n    //   const retVal = cachedThenable(okHandlerResult);\n    //   retVal[\"value\"] = retVal.src;\n    //   return retVal;\n    // };\n\n    return function syncThenable(x: T) {\n      firstRun = true;\n\n      if (typeof (x as any)?.then === \"function\") {\n        return x as unknown as TThenable;\n      } else {\n        // needed, because in strict mode it is impossble to set a property\n        // on a string primitive (and in non-strict mode the set value cannot be read again)\n        const newX = {\n          src: (x as any)?.src !== undefined ? (x as any).src : x,\n          then: (okHandler: (v: unknown, isSync?: boolean) => unknown) => {\n            if (firstRun) {\n              firstRun = false;\n              // console.log(`[thenableFactory] set cached thenable = ${okHandlerResult}`);\n              const okHandlerResult = okHandler(x, true);\n              cachedThenable = thenableFactory(okHandlerResult);\n              const retVal = cachedThenable(okHandlerResult);\n              retVal[\"value\"] = retVal.src;\n              return retVal;\n            }\n            const retVal = cachedThenable(okHandler(x, true));\n            retVal[\"value\"] = retVal.src;\n            return retVal;\n          },\n          value: x,\n        };\n        return newX;\n      }\n    };\n    // .bind({}); // needed for 'this' to work\n  }\n};\n\n/**\n * doAfter() will create another function that expects a singoe argument which could either be\n * a simple value or a promise, and doAfter will make sure that the given function is executed\n * synchronously if it's a simple value, or asynchronously after the promise resolves.\n *\n * Like thenable, but trying to avoid the creation of all the intermediate objects.\n * With our pipe function, it should be easy to use.\n *\n * @example\n * ```\n *  pipe(\n *    promiseOrValue,\n *    doAfter((v) => { do sync or async stuff with v and return the result }),\n *    doAfter((w) => { do sync or async stuff and return the result }),\n *  )\n * ```\n */\nconst doAfter = <TIn, TOut>(\n  f: (v: TIn) => TOut | Promise<TOut>,\n): ((x: TIn | Promise<TIn>) => TOut | Promise<TOut>) => {\n  return (valueOrPromise: TIn | Promise<TIn>) => {\n    return isPromise(valueOrPromise)\n      ? (valueOrPromise.then(f) as Promise<TOut>)\n      : (f(valueOrPromise) as TOut);\n  };\n};\n\n/**\n * Like doAfter, but remembers whether the sync or the async route should be chosen\n * based on the first call.\n * This could speed up things by avoiding repeated isPromise calls.\n * @example\n * ```typescript\n *  const incrementAfter = doAfterFactory((n) => n + 1);\n *  const doubleAfter = doAfterFactory((n) => n * 2);\n *\n * for (let i = 1; i <= 1_000_000; i++) {\n *  pipe(\n *    i,\n *    incrementAfter,\n *    doubleAfter,\n *    toArray,\n *  );\n * }\n * ```\n * @param f\n * @returns\n */\nconst doAfterFactory = <TIn, TOut>(\n  f: (v: TIn) => TOut | Promise<TOut>,\n): {\n  doAfter: (x: TIn | Promise<TIn>) => TOut | Promise<TOut>;\n  asyncDoAfter: (promise: Promise<TIn>) => Promise<TOut>;\n  syncDoAfter: (value: TIn) => TOut | Promise<TOut>;\n} => {\n  // let first = true;\n  // let isAsync;\n  const doAfterObj = {\n    asyncDoAfter: async (valueOrPromise: Promise<TIn>) =>\n      f(await valueOrPromise),\n    syncDoAfter: f,\n    doAfter: (valueOrPromise: TIn | Promise<TIn>) => {\n      if (isPromise(valueOrPromise)) {\n        doAfterObj.doAfter = doAfterObj.asyncDoAfter;\n      } else {\n        doAfterObj.doAfter = doAfterObj.syncDoAfter;\n      }\n      return doAfterObj.doAfter(valueOrPromise);\n    },\n  };\n  return doAfterObj;\n  // return (valueOrPromise: TIn | Promise<TIn>) => {\n  //   if (first) {\n  //     isAsync = isPromise(valueOrPromise);\n  //   }\n  //   return isAsync ? (valueOrPromise as Promise<TIn>).then(f) : f(valueOrPromise as TIn);\n  // };\n};\n\n/**\n * This utility function will do a for loop, synchronously if all the parts are synchronous,\n * and asynchronously otherwise.\n * This should help us to use the same code yet supporting both possible scenarios.\n *\n * @param initialStateFactory\n * @param testBeforeEach\n * @param afterEach\n * @param codeToExecute\n * @returns void | Promise<void>\n *\n * @category util\n */\nconst forLoop = <State>(\n  initialStateFactory: () => State | Promise<State>,\n  testBeforeEach: (a: State) => boolean | Promise<boolean>,\n  afterEach: (a: State) => State | Promise<State>,\n  codeToExecute: (a: State) => void | Promise<void>,\n) => {\n  // if we assume that thenable will return true as the second argument of the callbacks\n  // when we are still synchronous, we can write this with thenable I think\n  return thenable(initialStateFactory()).then((initialState, isSyncInit) => {\n    return thenable(testBeforeEach(initialState)).then(\n      (testResult, isSyncTest) => {\n        // this should work, both for sync and async stuff, so that we don't get the indentation-of-hell issue?\n        if (testResult) {\n          return thenable(codeToExecute(initialState)).then((_, isSyncBody) => {\n            return thenable(afterEach(initialState)).then(\n              (firstStateAfterEach, isSyncAfterBody) => {\n                if (isSyncInit && isSyncTest && isSyncBody && isSyncAfterBody) {\n                  // everything is synchronous so we can do a synchronous for loop\n                  let state = firstStateAfterEach;\n                  while (testBeforeEach(state)) {\n                    codeToExecute(state);\n                    state = afterEach(state);\n                  }\n                  return state;\n                } else {\n                  // naive implementation: something is asynchronous so we can to do an asychronous for loop\n                  // return (async () => {\n                  //   let state = firstStateAfterEach;\n                  //   while (await testBeforeEach(state)) {\n                  //     await codeToExecute(state);\n                  //     state = await afterEach(state);\n                  //   }\n                  //   return state;\n                  // })();\n\n                  // await on a non-promise will still break execution and turns\n                  // the value into Promise.resolve(...))\n                  // SO can we only await if it's necessary?\n                  // 2^3 = 8 possible (ignoring the generation of initial state) combinations\n                  // with and without await\n                  // Luckily new Function('a', 'b', 'return a + b;'); will produce a function\n                  // from a string and some clever guy found a way to create an AsyncFunction\n                  // equivalent of that!\n                  // So using isSyncInit, isSyncTest, isSyncBody, isSyncAfterBody to decide\n                  // whether a value shouldbe awaited, we can solve it like this\n                  return new AsyncFunction(\n                    \"firstStateAfterEach\",\n                    \"testBeforeEach\",\n                    \"codeToExecute\",\n                    \"afterEach\",\n                    `\n                    let state = firstStateAfterEach;\n                    while (${isSyncTest ? \"\" : \"await \"}testBeforeEach(state)) {\n                      ${isSyncBody ? \"\" : \"await \"}codeToExecute(state);\n                      state = ${\n                        isSyncAfterBody ? \"\" : \"await \"\n                      }afterEach(state);\n                    }\n                    return state;\n                  `,\n                  )(\n                    firstStateAfterEach,\n                    testBeforeEach,\n                    codeToExecute,\n                    afterEach,\n                  );\n                }\n              },\n            );\n          });\n        } else {\n          return initialState;\n        }\n      },\n    );\n  });\n};\n\n// /**\n//  * A more generic pipe function that takes multiple functions as input\n//  * and outputs a single function where input = input of the first function\n//  * and output = output where every funtion has been applied to the output of the previous on.\n//  *\n//  * So itr8Pipe(f1:(x:A)=>B, f2:(x:B)=>C, f3:(x:C)=>D) returns (a:A):D => f3(f2(f1(a)))\n//  *\n//  * @param first\n//  * @param params\n//  * @returns\n//  *\n//  * @deprecated see compose (and pipe)\n//  */\n// function itr8Pipe<A, B>(fn1: (x: A) => B): (x: A) => B;\n// function itr8Pipe<A, B, C>(fn1: (x: A) => B, fn2: (x: B) => C): (x: A) => C;\n// function itr8Pipe<A, B, C, D>(\n//   fn1: (x: A) => B,\n//   fn2: (x: B) => C,\n//   fn3: (x: C) => D\n// ): (x: A) => D;\n// function itr8Pipe<A, B, C, D, E>(\n//   fn1: (x: A) => B,\n//   fn2: (x: B) => C,\n//   fn3: (x: C) => D,\n//   fn4: (x: D) => E\n// ): (x: A) => E;\n// /*export*/ function itr8Pipe<A = any, B = any>(\n//   first: (x: A) => B,\n//   ...params: Array<(any) => any>\n// ): any {\n//   if (params.length === 0) {\n//     return first;\n//   } else {\n//     return params.reduce<(any) => any>((acc, cur) => {\n//       return (arg) => cur(acc(arg));\n//     }, first);\n//   }\n// }\n\n/**\n * A generic compose function that takes multiple functions as input\n * and outputs a single function where input = input of the first function\n * and output = output where every funtion has been applied to the output of the previous one.\n *\n * So\n * ```typescript\n * compose(f1:(x:A)=>B, f2:(x:B)=>C, f3:(x:C)=>D)\n * ```\n * will return a single unary function\n * ```typescript\n * (a:A):D => f3(f2(f1(a)))\n * ```\n *\n * @param first\n * @param params\n * @returns\n */\nfunction compose<A, B>(fn1: (x: A) => B): (x: A) => B;\nfunction compose<A, B, C>(fn1: (x: A) => B, fn2: (x: B) => C): (x: A) => C;\nfunction compose<A, B, C, D>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n): (x: A) => D;\nfunction compose<A, B, C, D, E>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n): (x: A) => E;\nfunction compose<A, B, C, D, E, F>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F,\n): (x: A) => F;\nfunction compose<A, B, C, D, E, F, G>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F,\n  fn6: (x: F) => G,\n): (x: A) => G;\nfunction compose<A, B, C, D, E, F, G, H>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F,\n  fn6: (x: F) => G,\n  fn7: (x: G) => H,\n): (x: A) => H;\nfunction compose<A, B, C, D, E, F, G, H, I>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F,\n  fn6: (x: F) => G,\n  fn8: (x: G) => H,\n  fn7: (x: H) => I,\n): (x: A) => I;\nfunction compose<A, B, C, D, E, F, G, H, I, J>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F,\n  fn6: (x: F) => G,\n  fn7: (x: G) => H,\n  fn8: (x: H) => I,\n  fn9: (x: I) => J,\n): (x: A) => J;\nfunction compose<A, B, C, D, E, F, G, H, I, J, K>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F,\n  fn6: (x: F) => G,\n  fn7: (x: G) => H,\n  fn8: (x: H) => I,\n  fn9: (x: I) => J,\n  fn10: (x: J) => K,\n): (x: A) => K;\nfunction compose<A, B, C, D, E, F, G, H, I, J, K>(\n  fn1: (x: A) => B,\n  fn2: (x: B) => C,\n  fn3: (x: C) => D,\n  fn4: (x: D) => E,\n  fn5: (x: E) => F,\n  fn6: (x: F) => G,\n  fn7: (x: G) => H,\n  fn8: (x: H) => I,\n  fn9: (x: I) => J,\n  fn10: (x: J) => K,\n  ...moreFns: Array<(x: unknown) => unknown>\n): (x: A) => unknown;\nfunction compose<A, B>(\n  first: (x: A) => B,\n  ...params: Array<(unknown) => unknown>\n): unknown {\n  if (params.length === 0) {\n    return first;\n  } else {\n    return params.reduce<(unknown) => unknown>((acc, cur) => {\n      return (arg) => cur(acc(arg));\n    }, first);\n  }\n}\n\n/**\n * A pipe function applies the multiple functions to the first parameter\n *\n * So\n * ```typescript\n * pipe(x: A, f1:(x:A)=>B, f2:(x:B)=>C, f3:(x:C)=>D)\n * ```\n * returns the result of (a:A):D => f3(f2(f1(a)))\n *\n * @param first\n * @param params\n * @returns\n */\nfunction pipe<IN, A>(input: IN, fn1: (x: IN) => A): A;\nfunction pipe<IN, A, B>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B): B;\nfunction pipe<IN, A, B, C>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n): C;\nfunction pipe<IN, A, B, C, D>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n): D;\nfunction pipe<IN, A, B, C, D, E>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n): E;\nfunction pipe<IN, A, B, C, D, E, F>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n): F;\nfunction pipe<IN, A, B, C, D, E, F, G>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G,\n): G;\nfunction pipe<IN, A, B, C, D, E, F, G, H>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G,\n  fn8: (x: G) => H,\n): H;\nfunction pipe<IN, A, B, C, D, E, F, G, H, I>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G,\n  fn8: (x: G) => H,\n  fn9: (x: H) => I,\n): I;\nfunction pipe<IN, A, B, C, D, E, F, G, H, I, J>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G,\n  fn8: (x: G) => H,\n  fn9: (x: H) => I,\n  fn10: (x: I) => J,\n): J;\nfunction pipe<IN, A, B, C, D, E, F, G, H, I, J>(\n  input: IN,\n  fn1: (x: IN) => A,\n  fn2: (x: A) => B,\n  fn3: (x: B) => C,\n  fn4: (x: C) => D,\n  fn5: (x: D) => E,\n  fn6: (x: E) => F,\n  fn7: (x: F) => G,\n  fn8: (x: G) => H,\n  fn9: (x: H) => I,\n  fn10: (x: I) => J,\n  ...moreFns: Array<(x: unknown) => unknown>\n): unknown;\nfunction pipe<IN, A>(\n  input: IN,\n  fn1: (x: IN) => A,\n  ...functionsToApply: Array<(unknown) => unknown>\n): unknown {\n  if (functionsToApply.length === 0) {\n    return fn1(input);\n  } else {\n    const composedFn = functionsToApply.reduce<(unknown) => unknown>(\n      (acc, cur) => {\n        return (arg) => cur(acc(arg));\n      },\n      fn1,\n    );\n    return composedFn(input);\n  }\n}\n\nexport {\n  compose,\n  /**\n   * @deprecated Use compose(...) instead!\n   */\n  compose as itr8Pipe,\n  pipe,\n  isPromise,\n  AsyncFunction,\n  thenable,\n  thenableFactory,\n  doAfter,\n  doAfterFactory,\n  forLoop,\n  // itr8OperatorFactory,\n};\n", "/**\n * forEach is the one that will actually start 'draining' the iterator.\n * (itr8ToArray and most other itr8To... methods as well)\n *\n * @module\n */\n\nimport { isPromise } from \"../util/index.js\";\n\n/**\n * produces a function that can be applied to an iterator and that will execute\n * the handler on each value.\n *\n * The handler can be asynchronous!\n * By default the next will only be handled when the current handler has finished.\n * If you set options.concurrency to a higher value, you are allowing multiple handlers\n * to run in parallel.\n * But the next() will already be called while the (async) handler is still handling the current\n * result, which optimizes things by not waiting for the processing to finish, before asking for\n * the next one. Instead we'll first be asking for the next one, and then start processing of the\n * current one. This will waste less time than using 'for await (... of ...)' while still\n * processing things in the expected order!\n *\n * @param handler\n * @param options: ```{ concurrency: number }``` will control how many async handler are allowed to run in parallel. Default: 1\n * @returns\n *\n * @category interface/standard\n */\nconst forEach = function <T = any>(\n  handler: (T) => void | Promise<void>,\n  options?: { concurrency?: number },\n): (it: Iterator<T> | AsyncIterator<T>) => void | Promise<void> {\n  return (it: Iterator<T>) => {\n    let throwCount = 0;\n    const maxRunningHandlers = options?.concurrency || 1;\n    const runningHandlers: Set<Promise<void>> = new Set();\n    const waitForOpenSpot = async () => {\n      // wait for an open spot if the max amount of running handlers is reached\n      if (runningHandlers.size >= maxRunningHandlers) {\n        await Promise.race(runningHandlers);\n      }\n    };\n    const addToRunningHandlersList = (handlerPromise: Promise<void>) => {\n      // add it to the running handlers list\n      runningHandlers.add(handlerPromise);\n      handlerPromise.finally(() => {\n        runningHandlers.delete(handlerPromise);\n      });\n    };\n    /** Make sure the handler is wrapped in try/catch in order to send the right signals to the\n     * input iterator in case something goes wrong!\n     *\n     * Self-replacing function, depending on the very first call, if the first call returns\n     * a promise, the function wil replace itself with an async version, and with a sync\n     * version otherwise\n     */\n    let tryHandler = (v: T): void | Promise<void> => {\n      const errorCatcher = (e) => {\n        if (throwCount < 1) {\n          try {\n            it.throw?.(e);\n          } catch (throwErr) {\n            // native implementation crashes?\n            // console.log(v, 'ERROR WHILE THROWING', throwErr);\n          }\n          throwCount += 1;\n        }\n      };\n\n      try {\n        const handlerPossiblePromise = handler(v);\n        if (isPromise(handlerPossiblePromise)) {\n          tryHandler = (v: T) => {\n            // async tryHandler\n            return (handler(v) as Promise<void>).catch(errorCatcher);\n          };\n          handlerPossiblePromise.catch(errorCatcher);\n          return handlerPossiblePromise;\n        } else {\n          tryHandler = (v: T) => {\n            try {\n              // sync tryHandler\n              handler(v) as void;\n            } catch (e) {\n              errorCatcher(e);\n              throw e;\n            }\n          };\n        }\n      } catch (e) {\n        errorCatcher(e);\n        throw e;\n      }\n    };\n\n    const nextPromiseOrValue = it.next();\n    if (isPromise(nextPromiseOrValue)) {\n      const nextPromise = nextPromiseOrValue;\n\n      const handleNext = async (nextValue) => {\n        await waitForOpenSpot();\n\n        const handlerPossiblePromise = tryHandler(nextValue);\n\n        if (isPromise(handlerPossiblePromise)) {\n          addToRunningHandlersList(handlerPossiblePromise);\n        }\n      };\n      return (async () => {\n        let next = (await nextPromise) as IteratorResult<any>;\n        while (!next.done) {\n          await handleNext(next.value);\n          next = await it.next();\n        }\n        // wait until all remaining handlers are done before resolving the current promise!\n        await Promise.all(runningHandlers);\n        it.return?.(next.value);\n      })();\n    } else {\n      let next = nextPromiseOrValue;\n      if (next.done) {\n        it.return?.(next.value);\n      } else {\n        const handlerPossiblePromise: Promise<void> | void = tryHandler(\n          next.value,\n        );\n        if (isPromise(handlerPossiblePromise)) {\n          return (async () => {\n            let handlerPossiblePromiseIn: Promise<void> | undefined =\n              handlerPossiblePromise;\n            while (!next.done) {\n              const handlerPromise =\n                handlerPossiblePromiseIn /* only the very first time */ ||\n                (tryHandler(next.value) as Promise<void>);\n              handlerPossiblePromiseIn = undefined;\n\n              addToRunningHandlersList(handlerPromise);\n\n              next = it.next();\n              await waitForOpenSpot();\n            }\n            // wait until all remaining handlers are done before resolving the current promise!\n            await Promise.all(runningHandlers);\n            it.return?.(next.value);\n          })();\n        } else {\n          for (next = it.next(); !next.done; next = it.next()) {\n            tryHandler(next.value);\n          }\n          // next = it.next();\n          // while (!next.done) {\n          //   tryHandler(next.value);\n          //   next = it.next();\n          //   // console.log('[forEach] next', next);\n          // }\n          it.return?.(next.value);\n        }\n      }\n    }\n  };\n};\n\nexport { forEach };\n", "/**\n * Turns an array into an Iterator\n * (itr8FromIterable is more generic, this one is mainly useful for writing tests together\n * with its async brother itr8FromArrayAsync).\n *\n * @param a an array\n * @returns an iterator\n *\n * @category interface/standard\n */\nfunction itr8FromArray<T>(a: Array<T>): IterableIterator<T> {\n  return a[Symbol.iterator]();\n}\n\nexport { itr8FromArray };\n", "/**\n * Turns an array into an (async) Iterator. Mainly useful for testing.\n *\n * @param a an array\n * @returns an async iterator\n *\n * @category interface/standard\n */\nfunction itr8FromArrayAsync<T>(a: Array<T>): AsyncIterableIterator<T> {\n  return (async function* () {\n    for (const x of a) {\n      yield x;\n    }\n  })();\n}\n\nexport { itr8FromArrayAsync };\n", "import { nextTick } from \"process\";\nimport { thenable } from \"../util/index.js\";\n\n/**\n * Turns a parameterless function into an Iterator that will produce results using\n * the input function's return value. In case the function returns a promise, the result will be\n * an AsyncIterator.\n * Useful for 'impure' stuff like Math.random, or Date.now etc.\n *\n * @example\n * ```typescript\n * pipe(\n *  itr8FromImpureFunction(Math.random),\n *  take(3),\n *  itr8ToArray\n * ); // => [0.2511072995514807, 0.04918679946517224, 0.48479881173432826]\n * ```\n * @param a anything like object, string, number, ...\n * @returns an iterator\n *\n * @category interface/standard\n */\nfunction itr8FromImpureFunction<T>(\n  f: () => T | Promise<T>,\n): IterableIterator<T> | AsyncIterableIterator<T> {\n  const retVal = {\n    [Symbol.iterator]: () => retVal,\n    [Symbol.asyncIterator]: () => retVal,\n    next: () => thenable(f()).then((value) => ({ done: false, value })).src,\n  };\n  return retVal;\n}\n\nexport { itr8FromImpureFunction };\n", "/**\n * Gets a wrapped instance of the iterator OR the async iterator from any iterable (including arrays)\n * so that we can easily pipe it into the operators.\n *\n * @example\n * ```typescript\n * pipe(\n *    itr8FromIterable([1,2,3]),\n *    map((x) => x + 100),\n *  )\n * ```\n *\n * @category interface/standard\n */\nfunction itr8FromIterable<T>(\n  it: Iterable<T> | AsyncIterable<T>,\n): IterableIterator<T> | AsyncIterableIterator<T> {\n  if (it[Symbol.iterator]) {\n    return it[Symbol.iterator]();\n  } else {\n    return it[Symbol.asyncIterator]();\n  }\n}\n\nexport { itr8FromIterable };\n", "/**\n * Turns a single value into an Iterator that will produce 1 result.\n * Should work for boolean, number, string, object, ...\n *\n * @param a anything like object, string, number, ...\n * @returns an iterator\n *\n * @category interface/standard\n */\nfunction itr8FromSingleValue<T>(v: any): IterableIterator<T> {\n  return (function* () {\n    yield v;\n  })();\n}\n\nexport { itr8FromSingleValue };\n", "/**\n * Turns a single value into an (async) Iterator that will produce 1 result.\n * Should work for boolean, number, string, object, ...\n *\n * @param a anything like object, string, number, ...\n * @returns an iterator\n *\n * @category interface/standard\n */\nfunction itr8FromSingleValueAsync<T>(v: any): AsyncIterableIterator<T> {\n  return (async function* () {\n    yield v;\n  })();\n}\n\nexport { itr8FromSingleValueAsync };\n", "import { itr8FromIterable } from \"./itr8FromIterable.js\";\n\n/**\n * Turns a string into an Iterator that outputs every character of the string separately.\n *\n * (but since a string is an Iterable, you can use itr8FromIterable on strings as well!)\n *\n * @param s string\n * @returns an iterator\n *\n * @category interface/standard\n */\nfunction itr8FromString(s: string): IterableIterator<string> {\n  return itr8FromIterable(s) as IterableIterator<string>;\n}\n\nexport { itr8FromString };\n", "/**\n * Turns a string into an (async) Iterator that outputs every character of\n * the string separately.\n *\n * @param s a string\n * @returns an iterator\n *\n * @category interface/standard\n */\nfunction itr8FromStringAsync(s: string): AsyncIterableIterator<string> {\n  return (async function* () {\n    for (const x of s) {\n      yield x;\n    }\n  })();\n}\n\nexport { itr8FromStringAsync };\n", "import { TPushable } from \"../types.js\";\n\n/**\n * Creates an AsyncIterableIterator, that also exposes\n * * a push(...) method that can be used to push values into it (for example based on events).\n * * a done() method that can be used to indicate that no more values will follow.\n *\n * The optional bufferSize parameter defines how large the buffer is that will hold the\n * messages until they are pulled by a next() call. The oldest messages will be\n * dropped if no one is consuming the iterator fast enough.\n *\n * If no bufferSize is specified, the buffer will keep growing indefinitely.\n *\n * @param observable\n * @returns\n *\n * @category interface/standard\n */\nfunction itr8Pushable<T>(\n  bufferSize?: number,\n): AsyncIterableIterator<T> & TPushable {\n  const buffer: any[] = [];\n\n  let currentResolve;\n  // let currentReject;\n  let currentDataPromise;\n  // let done = false;\n\n  const createNewCurrentDataPromise = () => {\n    currentDataPromise = new Promise((resolve /*, reject */) => {\n      currentResolve = resolve;\n      // currentReject = reject;\n    });\n    buffer.push(currentDataPromise);\n    while (bufferSize !== undefined && buffer.length > bufferSize + 1) {\n      // remove the oldest one from the buffer\n      buffer.shift();\n    }\n  };\n\n  createNewCurrentDataPromise();\n\n  const retVal: AsyncIterableIterator<T> & TPushable<T> = {\n    [Symbol.asyncIterator]: () => retVal,\n    next: async () => {\n      // if (done) {\n      //   return { done: true };\n      // }\n      if (buffer.length > 0) {\n        // const [firstOfBufferPromise, ...restOfBuffer] = buffer;\n        // buffer = restOfBuffer;\n        const firstOfBufferPromise = buffer.shift();\n        const asyncNext = await firstOfBufferPromise;\n        return asyncNext;\n      } else {\n        throw new Error(\"[itr8FromObservable] No elements in the buffer?\");\n      }\n    },\n    push: (value: T) => {\n      currentResolve({ value });\n      createNewCurrentDataPromise();\n    },\n    done: () => {\n      currentResolve({ done: true });\n      createNewCurrentDataPromise();\n      // done = true;\n    },\n  };\n\n  return retVal;\n}\n\nexport { itr8Pushable };\n", "import { TPushable } from \"../types.js\";\nimport { itr8Pushable } from \"./itr8Pushable.js\";\n\n/**\n * Returns a (pushable async) iterator that will automatically fire with the Date.now() value\n * of when it fired (= the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC).\n *\n * When you want it to stop, call the done() method of the returned iterator, and the interval\n * will be cleaned up.\n *\n * @param intervalMilliseconds\n * @returns an AsyncIterableIterator\n *\n * @category interface/standard\n */\nfunction itr8Interval(\n  intervalMilliseconds: number,\n): AsyncIterableIterator<number> & TPushable {\n  const it = itr8Pushable<number>(Infinity); // infinite buffer !!!\n  const interval = setInterval(() => {\n    it.push(Date.now());\n  }, intervalMilliseconds);\n  const origDone = it.done;\n  it.done = () => {\n    clearInterval(interval);\n    return origDone();\n  };\n  return it;\n}\n\nexport { itr8Interval };\n", "/**\n * Utility function that produces an iterator producing numbers (not only integers)\n * starting and ending where you want, which is useful for trying out stuff\n * without manually having to create arrays.\n *\n * * 'from' can be higher than 'to', in which case the iterator will count down\n * * 'step' is always a positive number (but we are forgiving if it's not)\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8Range(0, 3)\n *      itr8ToArray,\n *    ) // => [0, 1, 2, 3]\n *\n *    pipe(\n *      itr8Range(0, 10, 3)\n *      itr8ToArray,\n *    ) // => [0, 3, 6, 9]\n *\n *    pipe(\n *      itr8Range(5, 1, 2)\n *      itr8ToArray,\n *    ) // => [5, 3, 1]\n * ```\n *\n * @param start start index\n * @param end end index\n * @param end step size, default = 1\n *\n * @category interface/standard\n */\nfunction itr8Range(\n  from: number,\n  to: number,\n  step?: number,\n): IterableIterator<number> {\n  const stepValue = step !== undefined ? Math.abs(step) : 1;\n  const upwards = from < to;\n  return (function* () {\n    if (upwards) {\n      for (let i = from; i <= to; i = i + stepValue) {\n        yield i;\n      }\n    } else {\n      for (let i = from; i >= to; i = i - stepValue) {\n        yield i;\n      }\n    }\n  })();\n}\n\nexport { itr8Range };\n", "/**\n * Utility function that produces an (async) iterator\n * producing integers starting and ending where you want,\n * which is useful for trying out stuff without manually\n * having to create arrays.\n *\n * * 'from' can be higher than 'to', in which case the iterator will count down\n * * 'step' is always a positive number (but we are forgiving if it's not)\n *\n * @param start start index\n * @param end end index\n * @param end step size, default = 1\n *\n * @category interface/standard\n */\nfunction itr8RangeAsync(\n  from: number,\n  to: number,\n  step?: number,\n): AsyncIterableIterator<number> {\n  const stepValue = step !== undefined ? Math.abs(step) : 1;\n  const upwards = from < to;\n  return (async function* () {\n    if (upwards) {\n      for (let i = from; i <= to; i = i + stepValue) {\n        yield i;\n      }\n    } else {\n      for (let i = from; i >= to; i = i - stepValue) {\n        yield i;\n      }\n    }\n  })();\n}\n\nexport { itr8RangeAsync };\n", "import { isPromise } from \"../util/index.js\";\n\n/**\n * Turns an itr8 into an array.\n *\n * @param iterator\n * @returns an array\n *\n * @category interface/standard\n */\nfunction itr8ToArray<T>(\n  iterator: Iterator<T> | AsyncIterator<T>,\n): Array<T | any> | Promise<Array<T | any>> {\n  let n = iterator.next();\n  if (isPromise(n)) {\n    return (async () => {\n      const asyncResult: T[] = [];\n      while (!(await n).done) {\n        asyncResult.push((await n).value);\n        n = iterator.next();\n      }\n      return asyncResult;\n    })();\n  } else {\n    // return Array.from(iterator);\n    const result: T[] = [];\n    for (\n      let nSync = n as IteratorResult<T>;\n      !nSync.done;\n      nSync = iterator.next() as IteratorResult<T>\n    ) {\n      result.push(nSync.value);\n    }\n    // let nSync = n as IteratorResult<T>;\n    // while (!nSync.done) {\n    //   result.push(nSync.value);\n    //   nSync = iterator.next() as IteratorResult<T>;\n    // }\n    return result;\n  }\n}\n\nexport { itr8ToArray };\n", "import { isPromise } from \"../util/index.js\";\n\n/**\n * Turns an itr8 into an object. It is like Object.fromEntries,\n * but it will work both for synchronous and asynchronous iterators\n *\n * @example\n * ```typescript\n *  // synchronous, same as Object.fromEntries(...)\n *  const myObj = pipe(\n *      itr8FromIterable([['a', 'value of A'], ['b', 'value of B'], ['c', 'value of C']]),\n *      itr8ToObject,\n *    ) // => {\n *      //      a: 'value of A',\n *      //      b: 'value of B',\n *      //      c: 'value of C',\n *      // }\n *\n *  // asynchronous\n *  await myObj2 = pipe(\n *      itr8FromIterable([['a', 'value of A'], ['b', 'value of B'], ['c', 'value of C']]),\n *      delay(100),     // delay every element by 100 milliseconds\n *      itr8ToObject,\n *    ) // => {\n *      //      a: 'value of A',\n *      //      b: 'value of B',\n *      //      c: 'value of C',\n *      // }\n * ```\n *\n * @param iterator\n * @returns an array\n *\n * @category interface/standard\n */\nfunction itr8ToObject<TK extends string | number | symbol, TV>(\n  iterator:\n    | Iterator<[TK: string | number | symbol, TV: unknown]>\n    | AsyncIterator<[TK: string | number | symbol, TV: any]>,\n): Record<TK, TV> | Promise<Record<TK, TV>> {\n  let n = iterator.next();\n  if (isPromise(n)) {\n    return (async () => {\n      const asyncResult: Record<TK, TV> = {} as Record<TK, TV>;\n      while (!(await n).done) {\n        const [k, v] = (await n).value;\n        asyncResult[k] = v;\n        n = iterator.next();\n      }\n      return asyncResult;\n    })();\n  } else {\n    // return Array.from(iterator);\n    const result: Record<TK, TV> = {} as Record<TK, TV>;\n    let nSync = n as IteratorResult<[TK, TV]>;\n    while (!nSync.done) {\n      const [k, v] = nSync.value;\n      result[k] = v;\n      nSync = iterator.next() as IteratorResult<[TK, TV]>;\n    }\n    return result;\n  }\n}\n\nexport { itr8ToObject };\n", "import { isPromise } from \"../util/index.js\";\nimport { forEach } from \"./forEach.js\";\n\n/**\n * Turns an iterator into a single string.\n * The strings will simply be 'glued' together, so if you need a separator,\n * use interperse first.\n *\n * It is the equivalent of Array.join('').\n *\n * @example\n * ```typescript\n *  pipe(\n *    itr8FromArray(['Hello', 'Goodbye']),\n *    intersperse(' / '), // adds | between every 2 elements\n *    itr8ToString,\n *  ) // => 'Hello / Goodbye'\n *\n *  const alphabet = pipe(\n *    itr8Range(0, 25),\n *    map((i: number) => String.fromCharCode(\"A\".charCodeAt(0) + i)),\n *    itr8ToString\n *  ); // => 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n * ```\n *\n * @param iterator\n * @returns a string\n *\n * @category interface/standard\n */\nfunction itr8ToString<T>(\n  iterator: Iterator<T> | AsyncIterator<T>,\n): string | Promise<string> {\n  let n = iterator.next();\n  if (isPromise(n)) {\n    return (async () => {\n      let asyncResult = \"\";\n      while (!(await n).done) {\n        asyncResult = asyncResult + (await n).value;\n        n = iterator.next();\n      }\n      return asyncResult;\n    })();\n  } else {\n    // return Array.from(iterator);\n    let result = \"\";\n    let nSync = n as IteratorResult<T>;\n    while (!nSync.done) {\n      result = result + nSync.value;\n      nSync = iterator.next() as IteratorResult<T>;\n    }\n    return result;\n  }\n}\n\nexport { itr8ToString };\n", "import { itr8FromIterable } from \"../../interface/index.js\";\nimport {\n  TNextFnResult,\n  TThenable,\n  TTransIteratorSyncOrAsync,\n} from \"../../types.js\";\nimport {\n  pipe,\n  doAfter,\n  forLoop,\n  isPromise,\n  thenable,\n  thenableFactory,\n  doAfterFactory,\n} from \"../../util/index.js\";\n\n/**\n * The powerMap can be used as the base for many many other operators.\n *\n * An operator is 'a function that generates a transIterator'.\n * So for example filter(...) is an operator, because when called with an argument\n * (the filter function) the result of that will be another function which is the transIterator.\n *\n * A transIterator is simply a function with an iterator as single argument which will return\n * another iterator. This way we can easily 'build a chain of mulitple transIterators'.\n * So it transforms iterators, which is why I have called it transIterator (~transducers).\n *\n * powerMap is an operator that generates a transIterator that\n * will work both on synchronous and asynchronous iterators.\n * The powerMap needs to be provided with a single function of the form:\n *\n * ```typescript\n * (nextOfPreviousIteratorInTheChain, state) => TNextFnResult | Promise<[TNextFnResult]>\n * ```\n * and another function generating an initial 'state' (not every operator needs state)\n *\n * * *nextIn* is the (resolved if async) result of a next call of the input iterator.\n *   This means it will be of the form ```{ done: true }``` or ```{ done: false, value: <...> }```.\n * * The *state* parameter is used to allow operators to have state, but not all operators need this.\n *   For example: a 'map' operator doesn't need state, but the 'skip' operator would need to keep\n *   track of how many records have passed.\n *\n * Check the readme for some examples on how to write your own operators using 'powerMap'\n * (or check the source code as all the available operators have been built using this function).\n *\n * BEWARE: NEVER MODIFY THE STATE OBJECT (or any of its children!), ALWAYS RETURN A NEW VALUE!\n *\n * Why is the initial state not a simple value, but a function that produces the state?\n *  This way, even if nextFn would modify the state, it wouldn't mess with other instances\n *  of the same operator? Because if we'd like to deep clone the initial state ourselves, we might\n *  end up with some complex cases when classes are involved (I hope no one who's interested in\n *  this library will want to use classes as their state, because the library is more 'functional\n *  programming' oriented)\n *\n * @typeParam TIn the type of values that the input iterator must produce\n * @typeParam TOut the type of values that the output iterator will produce\n * @typeParam TState the type of the state that will be passed between all iterations\n *\n * @param nextFn\n * @param initialStateFactory a function that generates the initialSate\n * @returns a function taking an iterator as input and that has an iterator as output\n *\n * @category operators/general\n */\nconst powerMap = function <TIn = unknown, TOut = unknown, TState = void>(\n  nextFn: (\n    nextIn: IteratorResult<TIn>,\n    state: TState,\n  ) => TNextFnResult<TOut, TState> | Promise<TNextFnResult<TOut, TState>>,\n  initialStateFactory: () => TState,\n): TTransIteratorSyncOrAsync<TIn, TOut> {\n  type TOperatorState = {\n    state: TState;\n    currentOutputIterator: Iterator<TOut> | AsyncIterator<TOut> | undefined;\n    /** Means that we are done after this value or after finishing the currentOutputIterator */\n    isLastOutputIterator: boolean;\n    /** Means that we are done entirely */\n    done: boolean;\n  };\n\n  const operatorFunction = (\n    itIn: Iterator<TIn> | AsyncIterator<TIn>,\n    pState: TState,\n  ) => {\n    const operatorState: TOperatorState = {\n      state: pState,\n      currentOutputIterator: undefined,\n      isLastOutputIterator: false,\n      done: false,\n    };\n\n    let nextInPromiseOrValue:\n      | IteratorResult<TIn>\n      | Promise<IteratorResult<TIn>>\n      | undefined = undefined;\n    // let nextIn: IteratorResult<TIn> | undefined = undefined;\n    let isAsync: boolean | undefined = undefined;\n\n    let isAsyncInput: boolean | undefined = undefined;\n    function updateNextInPromiseOrValue() {\n      nextInPromiseOrValue = itIn.next();\n      if (isAsyncInput === undefined) {\n        isAsyncInput = isPromise(nextInPromiseOrValue);\n        isAsync = isAsync || isAsyncInput;\n      }\n    }\n    let isAsyncNextFn: boolean | undefined = undefined;\n    // let state = pState;\n\n    // let currentOutputIterator: Iterator<TOut> | AsyncIterator<TOut> | undefined = undefined;\n    let isAsyncCurrentOutputIterator: boolean | undefined = undefined;\n    // let done = false;\n\n    /**\n     * Can/should we make this kind of recursive?\n     * Figure out based on the input params whether we need to:\n     *  * return done because done = true\n     *  * return the next value of the current iterator\n     *    or empty the current iterator if we're at the end and call generateNextReturnVal\n     *  * do a call to nextFn\n     *    * if next = async, call generateNextReturnValAsync to handle this case\n     *    * set done to true if that is what it returns and call generateNextReturnVal\n     *    * return the value if it returns a value\n     *    * set current iterator if it returns an iterable and call generateNextReturnVal\n     * @returns\n     */\n    const generateNextReturnValSync = ():\n      | IteratorResult<TOut>\n      | Promise<IteratorResult<TOut>> => {\n      // while loop instead of calling this function recursively (call stack can become too large)\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if (operatorState.done) {\n          return { value: undefined, done: true };\n        }\n        // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n        if (operatorState.currentOutputIterator) {\n          const possibleNextValueOrPromise =\n            operatorState.currentOutputIterator.next();\n          if (\n            isAsyncCurrentOutputIterator ||\n            isPromise(possibleNextValueOrPromise)\n          ) {\n            isAsyncCurrentOutputIterator = true;\n            return generateNextReturnValAsync(\n              true,\n              undefined,\n              possibleNextValueOrPromise,\n            );\n          }\n          const possibleNext =\n            possibleNextValueOrPromise as IteratorResult<TOut>;\n\n          if (possibleNext.done) {\n            operatorState.currentOutputIterator = undefined;\n            if (operatorState.isLastOutputIterator) {\n              operatorState.done = true;\n              return { done: true, value: undefined };\n            }\n          } else {\n            return possibleNext;\n          }\n        }\n\n        // no running iterator, so we need to call nextFn again\n        updateNextInPromiseOrValue();\n        if (isAsyncInput) {\n          return generateNextReturnValAsync(false);\n        }\n        const nextIn = nextInPromiseOrValue as IteratorResult<TIn>;\n        const curNextFnResult = nextFn(\n          nextIn as IteratorResult<TIn>,\n          operatorState.state,\n        ) as TNextFnResult<TOut, TState>;\n        if (isAsyncNextFn === undefined) {\n          isAsyncNextFn = isPromise(curNextFnResult);\n          isAsync = isAsync || isAsyncNextFn;\n        }\n        if (isAsyncNextFn) {\n          return generateNextReturnValAsync(false, curNextFnResult);\n        }\n        if (\"state\" in curNextFnResult)\n          operatorState.state = curNextFnResult.state as TState;\n\n        if (curNextFnResult.done) {\n          operatorState.done = true;\n          return { done: true, value: undefined };\n        } else if (\"value\" in curNextFnResult) {\n          if (curNextFnResult.isLast) {\n            operatorState.done = true;\n          }\n          return { done: false, value: curNextFnResult.value };\n        } else if (\"iterable\" in curNextFnResult) {\n          if (operatorState.currentOutputIterator !== undefined)\n            throw new Error(\n              \"currentOutputIterator should be undefined at this point\",\n            );\n          operatorState.currentOutputIterator = itr8FromIterable(\n            curNextFnResult.iterable,\n          );\n          operatorState.isLastOutputIterator = !!curNextFnResult.isLast;\n          if (operatorState.currentOutputIterator?.next === undefined) {\n            throw new Error(\n              \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\",\n            );\n          }\n          // goto next round of while loop\n        } else {\n          // we need to call nextIn again\n          // goto next round of while loop\n        }\n      }\n    };\n\n    /**\n     * Almost the same method but in case input or nextFn is async\n     *\n     * @param callUpdateNextInPromiseOrValue\n     * @returns\n     */\n    const generateNextReturnValAsync = async (\n      callUpdateNextInPromiseOrValue = true,\n      nextFnResponse?,\n      currentOutputIteratorNext?,\n    ): Promise<IteratorResult<TOut>> => {\n      let doUpdateNextInPromiseOrValue = callUpdateNextInPromiseOrValue;\n      let alreadyKnownNextFnResponse = nextFnResponse;\n      let alreadyKnownCurrentOutputIteratorNext = currentOutputIteratorNext;\n      // while loop instead of calling this function recursively (call stack can become to large)\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if (operatorState.done) {\n          return { value: undefined, done: true };\n        }\n        // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n        if (operatorState.currentOutputIterator) {\n          let possibleNextValueOrPromise;\n          if (alreadyKnownCurrentOutputIteratorNext !== undefined) {\n            possibleNextValueOrPromise = alreadyKnownCurrentOutputIteratorNext;\n            alreadyKnownCurrentOutputIteratorNext = undefined; // only the first time !!!\n          } else {\n            possibleNextValueOrPromise =\n              operatorState.currentOutputIterator.next();\n          }\n          const possibleNext = (\n            isPromise(possibleNextValueOrPromise)\n              ? await possibleNextValueOrPromise\n              : possibleNextValueOrPromise\n          ) as IteratorResult<TOut>;\n\n          if (possibleNext.done) {\n            operatorState.currentOutputIterator = undefined;\n            if (operatorState.isLastOutputIterator) {\n              operatorState.done = true;\n              return { done: true, value: undefined };\n            }\n          } else {\n            return possibleNext;\n          }\n        }\n\n        // no running iterator, so we need to possibly call nextFn again\n        if (doUpdateNextInPromiseOrValue) {\n          updateNextInPromiseOrValue();\n        } else {\n          doUpdateNextInPromiseOrValue = true; // only possibly skip it the first time !!!\n        }\n        const nextIn = await nextInPromiseOrValue;\n        let curNextFnResultPromiseOrValue;\n        if (alreadyKnownNextFnResponse !== undefined) {\n          curNextFnResultPromiseOrValue = alreadyKnownNextFnResponse;\n          alreadyKnownNextFnResponse = undefined; // only use it the first time !!!\n        } else {\n          curNextFnResultPromiseOrValue = nextFn(\n            nextIn as IteratorResult<TIn>,\n            operatorState.state,\n          );\n        }\n        if (isAsyncNextFn === undefined) {\n          isAsyncNextFn = isPromise(curNextFnResultPromiseOrValue);\n          isAsync = isAsync || isAsyncNextFn;\n        }\n        const curNextFnResult = (\n          isAsyncNextFn\n            ? await curNextFnResultPromiseOrValue\n            : curNextFnResultPromiseOrValue\n        ) as TNextFnResult<TOut, TState>;\n        if (\"state\" in curNextFnResult)\n          operatorState.state = curNextFnResult.state as TState;\n\n        if (curNextFnResult.done) {\n          operatorState.done = true; // make sure we keep returning done\n          return { done: curNextFnResult.done, value: undefined };\n        } else if (\"value\" in curNextFnResult) {\n          if (curNextFnResult.isLast) {\n            operatorState.done = true;\n          }\n          return { done: false, value: curNextFnResult.value };\n        } else if (\"iterable\" in curNextFnResult) {\n          if (operatorState.currentOutputIterator !== undefined)\n            throw new Error(\n              \"currentOutputIterator should be undefined at this point\",\n            );\n          operatorState.currentOutputIterator = itr8FromIterable(\n            curNextFnResult.iterable,\n          );\n          operatorState.isLastOutputIterator = !!curNextFnResult.isLast;\n          if (operatorState.currentOutputIterator?.next === undefined) {\n            throw new Error(\n              \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\",\n            );\n          }\n          // goto next round of while loop\n          // return generateNextReturnValAsync();\n        } else {\n          // we need to call nextIn again\n          // goto next round of while loop\n          // return generateNextReturnValAsync();\n        }\n      }\n    };\n\n    /**\n     * This method will replace itself with the right method once we know\n     * in which case we are (sync, async)\n     *\n     * @returns {IteratorResult<TOut> | Promise<IteratorResult<TOut>>}\n     */\n    let generateNextReturnVal = ():\n      | IteratorResult<TOut>\n      | Promise<IteratorResult<TOut>> => {\n      // VERSION without 'magic' for debugging\n      return isAsync\n        ? generateNextReturnValAsync()\n        : generateNextReturnValSync();\n\n      // VERSION that replaces generateNextReturnVal with the sync or async version\n      // // if (isAsyncInput || isAsyncNextFn) {\n      // //   generateNextReturnVal = generateNextReturnValAsync;\n      // // } else {\n      // //   generateNextReturnVal = generateNextReturnValSync;\n      // // }\n\n      // return generateNextReturnVal();\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Here is the returned IterableIterator\n    ////////////////////////////////////////////////////////////////////////////////\n    const retVal = {\n      // return the current (async?) iterator to make it an iterable iterator (so we can use for ... of)\n      // since we can only know whether the output will be sync or async after the first next call,\n      // we'll expose both iterator and asynciterator functions...\n      [Symbol.iterator]: () => retVal,\n      [Symbol.asyncIterator]: () => retVal,\n      // pipe: (op:TTransIteratorSyncOrAsync) => op(retVal as Iterator<TOut>),\n      next: () => {\n        if (isAsyncInput || isAsyncNextFn) {\n          retVal.next = generateNextReturnValAsync;\n        } else {\n          retVal.next = generateNextReturnValSync;\n        }\n        return retVal.next();\n      },\n      // when the iterator is 'abandoned' (the user indicates no more next() calls will follow)\n      // we can do cleanup, but we also pass the message to our incoming iterator!\n      return: (value?: any) => {\n        itIn.return?.();\n        return isAsyncInput || isAsyncNextFn\n          ? Promise.resolve({ done: true, value })\n          : { done: true, value };\n      },\n      // when the iterator get a throw() call\n      // (the user indicates no more next() calls will follow because of an error)\n      // we can do cleanup, but we also pass the message to our incoming iterator!\n      throw: (err?: any) => {\n        itIn.throw?.(err);\n        return isAsyncInput || isAsyncNextFn\n          ? Promise.resolve({ done: true, value: undefined })\n          : { done: true, value: undefined };\n      },\n    };\n\n    return retVal as IterableIterator<TOut> | AsyncIterableIterator<TOut>;\n  };\n\n  const transIt = (\n    itIn: Iterator<TIn> | AsyncIterator<TIn>,\n  ): IterableIterator<TOut> | AsyncIterableIterator<TOut> => {\n    try {\n      return operatorFunction(itIn, initialStateFactory());\n    } catch (err) {\n      itIn.throw?.();\n      throw err;\n    }\n  };\n\n  // let cachedValueThenable:\n  //   | ((x: any | Promise<any>) => TThenable<any>)\n  //   | undefined = undefined;\n\n  /**\n   * Experiment: we could expose the \"transNextFn\" which is similar to a transducer:\n   * it is a function that transforms an existing nextFn, and by linking them all together\n   * we'll get a nextFn that combines multiple oeprations meaning we only need one 'intermediate'\n   * iterator. This might be more performant.\n   * But that can only be done if input and output match so they can be composed.\n   *\n   * So instead of getting (nextIn, state, params) as input (without the state) and\n   * TNextFnResult as output (without the state as well) we could create a function that\n   * gets TNextFnResult as input as well (or at least a subset of all the possibilities).\n   *\n   * By subset I mean: maybe only when they have a value or an iterable, and not when they\n   * have no value (meaning the element is skipped).\n   */\n  transIt.transNextFn = (\n    input: TNextFnResult<TIn, undefined>,\n  ): TNextFnResult<TOut, undefined> => {\n    const operatorState: TOperatorState = {\n      state: initialStateFactory(),\n      currentOutputIterator: undefined,\n      isLastOutputIterator: false,\n      done: false,\n    };\n\n    if (input.done === true) {\n      return input;\n    } else if (/* input.done === false && */ \"iterable\" in input) {\n      const iterator =\n        input.iterable[Symbol.iterator] || input.iterable[Symbol.asyncIterator];\n      const iterable: TOut[] = [];\n      const f = forLoop(\n        () => iterator.next(),\n        (n) => n.done !== true,\n        (n) => iterator.next(),\n        (nextIn: IteratorResult<TIn>) => {\n          thenable(\n            nextFn(nextIn as IteratorResult<TIn>, operatorState.state),\n          ).then((curNextFnResult) => {\n            // store the new state\n            operatorState.state = curNextFnResult.state;\n\n            // if it contains an iterable => iterate over it, otherwise add the value to the output array\n            if (curNextFnResult.done === false && curNextFnResult.iterable) {\n              // TODO support async iterable !!!\n              iterable.push(...curNextFnResult.iterable);\n            } else {\n              iterable.push(curNextFnResult.value);\n            }\n          }).src;\n        },\n      );\n      return thenable(f).then((_forLoopResult) => {\n        return { done: false, iterable };\n      }).src;\n    } else if (/* input.done === false && */ \"value\" in input) {\n      // if (cachedValueThenable === undefined) {\n      //   cachedValueThenable = thenableFactory(input);\n      // }\n      // return cachedValueThenable(input)\n      // .then((input) =>\n      return thenable(\n        nextFn(input as IteratorResult<TIn>, operatorState.state),\n      ).then((curNextFnResult) => {\n        const { newState, ...retVal } = curNextFnResult;\n        // store the new state\n        operatorState.state = curNextFnResult.state;\n        return retVal;\n      }).src;\n    } else {\n      // no value nor iterable in input, meaning this element should be skipped\n      // so don't call any other transformers on this element\n      return input;\n    }\n  };\n\n  return transIt;\n};\n\n/**\n * An experimental version of powerMap using doAfterFactory\n * (which is proven to be faster than thenable).\n * It seems slightly faster than powerMap for synchronous code, but is slower for async.\n *\n * The most important optimization is probably the same as what doAfterFactory does:\n * do a first run in order to figure out whether the first next() call is synchronous\n * and then replace the next function by an entirely synchronous version.\n * (And maybe the async version can be written with doAfterFactory (or a for-loop))\n *\n * Consequence: an iterable can only be async in a synchronous handler if it is used the first time\n * otherwise the iterator will already be synchronous.\n *\n * how do you make the while loop work for both synchronous and asynchronous code?\n * MAYBE I should reimplement the forLoop function using doAfter, and then use the powerMap version\n * that is written using the for-loop (and drop this one)?\n *\n * @param nextFn\n * @param initialStateFactory\n * @returns\n */\nconst powerMapWithDoAfter = function <\n  TIn = unknown,\n  TOut = unknown,\n  TState = void,\n>(\n  nextFn: (\n    nextIn: IteratorResult<TIn>,\n    state: TState,\n  ) => TNextFnResult<TOut, TState> | Promise<TNextFnResult<TOut, TState>>,\n  initialStateFactory: () => TState,\n): TTransIteratorSyncOrAsync<TIn, TOut> {\n  type TOperatorState = {\n    state: TState;\n    currentOutputIterator: Iterator<TOut> | AsyncIterator<TOut> | undefined;\n    /** Means that we are done after this value or after finishing the currentOutputIterator */\n    isLastOutputIterator: boolean;\n    /** Means that we are done entirely */\n    done: boolean;\n  };\n\n  const operatorFunction = (\n    itIn: Iterator<TIn> | AsyncIterator<TIn>,\n    pState: TState,\n  ) => {\n    const operatorState: TOperatorState = {\n      state: pState,\n      currentOutputIterator: undefined,\n      isLastOutputIterator: false,\n      done: false,\n    };\n\n    let nextInPromiseOrValue:\n      | IteratorResult<TIn>\n      | Promise<IteratorResult<TIn>>\n      | undefined = undefined;\n\n    /**\n     * This very first scroll through the loop should give us all the info we need\n     * in order to establish whether the iterator will be synchronous or asynchronous.\n     *\n     * After this first call, we can then overwrite the next function with either a sync\n     * or an async version.\n     * @returns\n     */\n    const generateFirstReturnValIfPossible = ():\n      | IteratorResult<TOut>\n      | Promise<IteratorResult<TOut>>\n      | null\n      | Promise<null> => {\n      return pipe(\n        itIn.next(),\n        doAfter((nextIn) => nextFn(nextIn, operatorState.state)),\n        doAfter((curNextFnResult) => {\n          if (\n            \"state\" in curNextFnResult &&\n            curNextFnResult.state !== undefined\n          ) {\n            operatorState.state = curNextFnResult.state;\n          }\n          if (curNextFnResult.done) {\n            operatorState.done = true;\n            return { done: true, value: undefined } as IteratorResult<TOut>;\n          } else if (\"value\" in curNextFnResult) {\n            if (curNextFnResult.isLast) {\n              operatorState.done = true;\n            }\n            return {\n              done: false,\n              value: curNextFnResult.value,\n            } as IteratorResult<TOut>;\n          } else if (\"iterable\" in curNextFnResult) {\n            if (operatorState.currentOutputIterator !== undefined) {\n              throw new Error(\n                \"currentOutputIterator should be undefined at this point\",\n              );\n            }\n            operatorState.currentOutputIterator = itr8FromIterable(\n              curNextFnResult.iterable,\n            );\n            operatorState.isLastOutputIterator = !!curNextFnResult.isLast;\n            if (operatorState.currentOutputIterator?.next === undefined) {\n              throw new Error(\n                \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\",\n              );\n            }\n            return pipe(\n              operatorState.currentOutputIterator.next(),\n              doAfter(\n                (currentOutputIteratorNext): IteratorResult<TOut> | null =>\n                  currentOutputIteratorNext.done\n                    ? null\n                    : currentOutputIteratorNext,\n              ),\n            );\n          } else {\n            return null;\n          }\n        }),\n      ) as\n        | IteratorResult<TOut>\n        | null\n        | Promise<IteratorResult<TOut>>\n        | Promise<null>;\n    };\n\n    const generateNextReturnValSync = ():\n      | IteratorResult<TOut>\n      | Promise<IteratorResult<TOut>> => {\n      // while loop instead of calling this function recursively (call stack can become too large)\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if (operatorState.done) {\n          return { value: undefined, done: true };\n        }\n        // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n        if (operatorState.currentOutputIterator) {\n          const possibleNext =\n            operatorState.currentOutputIterator.next() as IteratorResult<TOut>;\n\n          if (possibleNext.done) {\n            operatorState.currentOutputIterator = undefined;\n            if (operatorState.isLastOutputIterator) {\n              operatorState.done = true;\n              return { done: true, value: undefined };\n            }\n          } else {\n            return possibleNext;\n          }\n        }\n\n        // no running iterator, so we need to call nextFn again\n        const nextIn = itIn.next() as IteratorResult<TIn>;\n        const curNextFnResult = nextFn(\n          nextIn as IteratorResult<TIn>,\n          operatorState.state,\n        ) as TNextFnResult<TOut, TState>;\n        if (\"state\" in curNextFnResult)\n          operatorState.state = curNextFnResult.state as TState;\n\n        if (curNextFnResult.done) {\n          operatorState.done = true;\n          return { done: true, value: undefined };\n        } else if (\"value\" in curNextFnResult) {\n          if (curNextFnResult.isLast) {\n            operatorState.done = true;\n          }\n          return { done: false, value: curNextFnResult.value };\n        } else if (\"iterable\" in curNextFnResult) {\n          if (operatorState.currentOutputIterator !== undefined)\n            throw new Error(\n              \"currentOutputIterator should be undefined at this point\",\n            );\n          operatorState.currentOutputIterator = itr8FromIterable(\n            curNextFnResult.iterable,\n          );\n          operatorState.isLastOutputIterator = !!curNextFnResult.isLast;\n          if (operatorState.currentOutputIterator?.next === undefined) {\n            throw new Error(\n              \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\",\n            );\n          }\n          // goto next round of while loop\n        } else {\n          // we need to call nextIn again\n          // goto next round of while loop\n        }\n      }\n    };\n\n    const doAfters = {\n      /**\n       * This one handles when we have a current output iterator that is not done.\n       * It will generate the next value\n       */\n      currentOutputIteratorNextToNextOut: doAfterFactory<\n        IteratorResult<TOut>,\n        IteratorResult<TOut> | undefined\n      >((possibleNext): IteratorResult<TOut> | undefined => {\n        if (possibleNext.done) {\n          operatorState.currentOutputIterator = undefined;\n          if (operatorState.isLastOutputIterator) {\n            operatorState.done = true;\n            return { done: true, value: undefined };\n          }\n        } else {\n          return possibleNext;\n        }\n      }),\n      /**\n       * This will apply curNextFn to curNextIn\n       */\n      applyCurNextFnToNextIn: doAfterFactory<\n        IteratorResult<TIn>,\n        TNextFnResult<TOut, TState> | Promise<TNextFnResult<TOut, TState>>\n      >(\n        (nextIn) =>\n          nextFn(nextIn, operatorState.state) as TNextFnResult<TOut, TState>,\n      ),\n      /**\n       * This part will turn the result of applying nextFn to nextIn into\n       * an IteratorResult (or undefined if we need to go back to the top of\n       * the while loop\n       */\n      handleNextFnResult: doAfterFactory<\n        TNextFnResult<TOut, TState>,\n        IteratorResult<TOut> | undefined\n      >((curNextFnResult) => {\n        if (\"state\" in curNextFnResult) {\n          operatorState.state = curNextFnResult.state as TState;\n        }\n\n        if (curNextFnResult.done) {\n          operatorState.done = true;\n          return { done: true, value: undefined };\n        } else if (\"value\" in curNextFnResult) {\n          if (curNextFnResult.isLast) {\n            operatorState.done = true;\n          }\n          return { done: false, value: curNextFnResult.value };\n        } else if (\"iterable\" in curNextFnResult) {\n          if (operatorState.currentOutputIterator !== undefined)\n            throw new Error(\n              \"currentOutputIterator should be undefined at this point\",\n            );\n          operatorState.currentOutputIterator = itr8FromIterable(\n            curNextFnResult.iterable,\n          );\n          operatorState.isLastOutputIterator = !!curNextFnResult.isLast;\n          if (operatorState.currentOutputIterator?.next === undefined) {\n            throw new Error(\n              \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\",\n            );\n          }\n          // goto next round of while loop\n        } else {\n          // we need to call nextIn again\n          // goto next round of while loop\n        }\n      }),\n    };\n    const generateNextReturnValAsync = async (): Promise<\n      IteratorResult<TOut>\n    > => {\n      // while loop instead of calling this function recursively (call stack can become too large)\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if (operatorState.done) {\n          return { value: undefined, done: true };\n        }\n        // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n        if (operatorState.currentOutputIterator) {\n          const possibleNext = pipe(\n            operatorState.currentOutputIterator.next(),\n            doAfters.currentOutputIteratorNextToNextOut.doAfter,\n          );\n          if ((await possibleNext) !== undefined) {\n            return possibleNext as\n              | IteratorResult<TOut>\n              | Promise<IteratorResult<TOut>>;\n          }\n        }\n\n        // no running iterator, so we need to call nextFn again\n        const possibleNext = pipe(\n          itIn.next(),\n          doAfters.applyCurNextFnToNextIn.doAfter,\n          doAfters.handleNextFnResult.doAfter,\n        );\n        if ((await possibleNext) !== undefined) {\n          // (async () => console.log(\"Return possibleNext:\", await possibleNext))();\n          return possibleNext as\n            | IteratorResult<TOut>\n            | Promise<IteratorResult<TOut>>;\n        }\n        // if return has not been called, return to the top of the while loop again\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Here is the returned IterableIterator\n    ////////////////////////////////////////////////////////////////////////////////\n    const retVal = {\n      // return the current (async?) iterator to make it an iterable iterator (so we can use for ... of)\n      // since we can only know whether the output will be sync or async after the first next call,\n      // we'll expose both iterator and asynciterator functions...\n      [Symbol.iterator]: () => retVal,\n      [Symbol.asyncIterator]: () => retVal,\n      // pipe: (op:TTransIteratorSyncOrAsync) => op(retVal as Iterator<TOut>),\n      next: () => {\n        const n = generateFirstReturnValIfPossible();\n        const async = isPromise(n);\n        if (isPromise(n)) {\n          // const array = [];\n          retVal.next = generateNextReturnValAsync;\n          // async () => {\n          //   const n = await generateNextReturnValAsync();\n          //   if (!n) {\n          //     console.log(\"ASYNC next:\", n);\n          //     console.log(array);\n\n          //     console.log(\n          //       new Error(\"generateNextReturnValAsync returns undefined\")\n          //         .stack,\n          //     );\n          //   }\n          //   return n;\n          // }\n          return n.then((n2) => (n2 !== null ? n2 : retVal.next()));\n        } else {\n          retVal.next = generateNextReturnValSync;\n          return n !== null ? n : retVal.next();\n        }\n      },\n      // when the iterator is 'abandoned' (the user indicates no more next() calls will follow)\n      // we can do cleanup, but we also pass the message to our incoming iterator!\n      return: (value?: any) => {\n        itIn.return?.();\n        return retVal.next === generateNextReturnValSync\n          ? { done: true, value }\n          : Promise.resolve({ done: true, value });\n      },\n      // when the iterator get a throw() call\n      // (the user indicates no more next() calls will follow because of an error)\n      // we can do cleanup, but we also pass the message to our incoming iterator!\n      throw: (err?: any) => {\n        itIn.throw?.(err);\n        return retVal.next === generateNextReturnValSync\n          ? { done: true, value: undefined }\n          : Promise.resolve({ done: true, value: undefined });\n      },\n    };\n\n    return retVal as IterableIterator<TOut> | AsyncIterableIterator<TOut>;\n  };\n\n  const transIt = (\n    itIn: Iterator<TIn> | AsyncIterator<TIn>,\n  ): IterableIterator<TOut> | AsyncIterableIterator<TOut> => {\n    try {\n      return operatorFunction(itIn, initialStateFactory());\n    } catch (err) {\n      itIn.throw?.();\n      throw err;\n    }\n  };\n\n  // let cachedValueThenable:\n  //   | ((x: any | Promise<any>) => TThenable<any>)\n  //   | undefined = undefined;\n\n  /**\n   * Experiment: we could expose the \"transNextFn\" which is similar to a transducer:\n   * it is a function that transforms an existing nextFn, and by linking them all together\n   * we'll get a nextFn that combines multiple oeprations meaning we only need one 'intermediate'\n   * iterator. This might be more performant.\n   * But that can only be done if input and output match so they can be composed.\n   *\n   * So instead of getting (nextIn, state, params) as input (without the state) and\n   * TNextFnResult as output (without the state as well) we could create a function that\n   * gets TNextFnResult as input as well (or at least a subset of all the possibilities).\n   *\n   * By subset I mean: maybe only when they have a value or an iterable, and not when they\n   * have no value (meaning the element is skipped).\n   */\n  transIt.transNextFn = (\n    input: TNextFnResult<TIn, undefined>,\n  ): TNextFnResult<TOut, undefined> => {\n    const operatorState: TOperatorState = {\n      state: initialStateFactory(),\n      currentOutputIterator: undefined,\n      isLastOutputIterator: false,\n      done: false,\n    };\n\n    if (input.done === true) {\n      return input;\n    } else if (/* input.done === false && */ \"iterable\" in input) {\n      const iterator =\n        input.iterable[Symbol.iterator] || input.iterable[Symbol.asyncIterator];\n      const iterable: TOut[] = [];\n      const f = forLoop(\n        () => iterator.next(),\n        (n) => n.done !== true,\n        (n) => iterator.next(),\n        (nextIn: IteratorResult<TIn>) => {\n          thenable(\n            nextFn(nextIn as IteratorResult<TIn>, operatorState.state),\n          ).then((curNextFnResult) => {\n            // store the new state\n            operatorState.state = curNextFnResult.state;\n\n            // if it contains an iterable => iterate over it, otherwise add the value to the output array\n            if (curNextFnResult.done === false && curNextFnResult.iterable) {\n              // TODO support async iterable !!!\n              iterable.push(...curNextFnResult.iterable);\n            } else {\n              iterable.push(curNextFnResult.value);\n            }\n          }).src;\n        },\n      );\n      return thenable(f).then((_forLoopResult) => {\n        return { done: false, iterable };\n      }).src;\n    } else if (/* input.done === false && */ \"value\" in input) {\n      // if (cachedValueThenable === undefined) {\n      //   cachedValueThenable = thenableFactory(input);\n      // }\n      // return cachedValueThenable(input)\n      // .then((input) =>\n      return thenable(\n        nextFn(input as IteratorResult<TIn>, operatorState.state),\n      ).then((curNextFnResult) => {\n        const { newState, ...retVal } = curNextFnResult;\n        // store the new state\n        operatorState.state = curNextFnResult.state;\n        return retVal;\n      }).src;\n    } else {\n      // no value nor iterable in input, meaning this element should be skipped\n      // so don't call any other transformers on this element\n      return input;\n    }\n  };\n\n  return transIt;\n};\n\n/**\n * An experimental version of powerMap trying to learn from the lessons from\n * the powerMapWithDoAfter version\n * We'll remove doAfter again from the async version, and use simple ifs again.\n *\n * The most important optimization is probably the same as what doAfterFactory does:\n * do a first run in order to figure out whether the first next() call is synchronous\n * and then replace the next function by an entirely synchronous version.\n * (And maybe the async version can be written with doAfterFactory (or a for-loop))\n *\n * Consequence: an iterable can only be async in a synchronous handler if it is used the first time\n * otherwise the iterator will already be synchronous.\n *\n * how do you make the while loop work for both synchronous and asynchronous code?\n * MAYBE I should reimplement the forLoop function using doAfter, and then use the powerMap version\n * that is written using the for-loop (and drop this one)?\n *\n * @param nextFn\n * @param initialStateFactory\n * @returns\n */\nconst powerMapWithoutDoAfter = function <\n  TIn = unknown,\n  TOut = unknown,\n  TState = void,\n>(\n  nextFn: (\n    nextIn: IteratorResult<TIn>,\n    state: TState,\n  ) => TNextFnResult<TOut, TState> | Promise<TNextFnResult<TOut, TState>>,\n  initialStateFactory: () => TState,\n): TTransIteratorSyncOrAsync<TIn, TOut> {\n  type TOperatorState = {\n    state: TState;\n    currentOutputIterator: Iterator<TOut> | AsyncIterator<TOut> | undefined;\n    /** Means that we are done after this value or after finishing the currentOutputIterator */\n    isLastOutputIterator: boolean;\n    /** Means that we are done entirely */\n    // done: boolean;\n  };\n\n  const operatorFunction = (\n    itIn: Iterator<TIn> | AsyncIterator<TIn>,\n    pState: TState,\n  ) => {\n    const operatorState: TOperatorState = {\n      state: pState,\n      currentOutputIterator: undefined,\n      isLastOutputIterator: false,\n      // done: false,\n    };\n\n    /**\n     * This very first scroll through the loop should give us all the info we need\n     * in order to establish whether the iterator will be synchronous or asynchronous.\n     *\n     * After this first call, we can then overwrite the next function with either a sync\n     * or an async version.\n     * @returns\n     */\n    const generateFirstReturnValIfPossible = ():\n      | IteratorResult<TOut>\n      | Promise<IteratorResult<TOut>>\n      | null\n      | Promise<null> => {\n      return pipe(\n        itIn.next(),\n        doAfter((nextIn) => nextFn(nextIn, operatorState.state)),\n        doAfter((curNextFnResult) => {\n          if (\n            \"state\" in curNextFnResult &&\n            curNextFnResult.state !== undefined\n          ) {\n            operatorState.state = curNextFnResult.state;\n          }\n          if (curNextFnResult.done) {\n            returnedIterator.next = generateDoneSync; // operatorState.done = true;\n            return { done: true, value: undefined } as IteratorResult<TOut>;\n          } else if (\"value\" in curNextFnResult) {\n            if (curNextFnResult.isLast) {\n              returnedIterator.next = generateDoneSync; // operatorState.done = true;\n            }\n            return {\n              done: false,\n              value: curNextFnResult.value,\n            } as IteratorResult<TOut>;\n          } else if (\"iterable\" in curNextFnResult) {\n            if (operatorState.currentOutputIterator !== undefined) {\n              throw new Error(\n                \"currentOutputIterator should be undefined at this point\",\n              );\n            }\n            operatorState.currentOutputIterator = itr8FromIterable(\n              curNextFnResult.iterable,\n            );\n            operatorState.isLastOutputIterator = !!curNextFnResult.isLast;\n            if (operatorState.currentOutputIterator?.next === undefined) {\n              throw new Error(\n                \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\",\n              );\n            }\n            return pipe(\n              operatorState.currentOutputIterator.next(),\n              doAfter(\n                (currentOutputIteratorNext): IteratorResult<TOut> | null => {\n                  if (currentOutputIteratorNext.done) {\n                    operatorState.currentOutputIterator = undefined;\n                    return null;\n                  } else {\n                    // Don't set it here...\n                    // returnedIterator.next = generateNextFromOutputIteratorAsync;\n                    return currentOutputIteratorNext;\n                  }\n                },\n              ),\n            );\n          } else {\n            return null;\n          }\n        }),\n      ) as\n        | IteratorResult<TOut>\n        | null\n        | Promise<IteratorResult<TOut>>\n        | Promise<null>;\n    };\n\n    const generateDoneSync: () => IteratorResult<TOut> = () => ({\n      done: true,\n      value: undefined,\n    });\n    const generateNextFromOutputIteratorSync: () => IteratorResult<TOut> =\n      () => {\n        // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n        const possibleNext = (\n          operatorState.currentOutputIterator as Iterator<TOut>\n        ).next() as IteratorResult<TOut>;\n\n        if (possibleNext.done) {\n          operatorState.currentOutputIterator = undefined;\n          if (operatorState.isLastOutputIterator) {\n            returnedIterator.next = generateDoneSync; // operatorState.done = true;\n            return { done: true, value: undefined };\n          } else {\n            returnedIterator.next = generateNextReturnValSync;\n            return returnedIterator.next();\n          }\n        } else {\n          return possibleNext;\n        }\n      };\n\n    const generateNextReturnValSync = ():\n      | IteratorResult<TOut>\n      | Promise<IteratorResult<TOut>> => {\n      // while loop instead of calling this function recursively (call stack can become too large)\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        // no running iterator, so we need to call nextFn again\n        const curNextFnResult = nextFn(\n          itIn.next() as IteratorResult<TIn>,\n          operatorState.state,\n        ) as TNextFnResult<TOut, TState>;\n        if (\"state\" in curNextFnResult) {\n          operatorState.state = curNextFnResult.state as TState;\n        }\n\n        if (curNextFnResult.done) {\n          returnedIterator.next = generateDoneSync; // operatorState.done = true;\n          return { done: true, value: undefined };\n        } else if (\"value\" in curNextFnResult) {\n          if (curNextFnResult.isLast) {\n            returnedIterator.next = generateDoneSync; // operatorState.done = true;\n          }\n          return { done: false, value: curNextFnResult.value };\n        } else if (\"iterable\" in curNextFnResult) {\n          if (operatorState.currentOutputIterator !== undefined)\n            throw new Error(\n              \"currentOutputIterator should be undefined at this point\",\n            );\n          operatorState.currentOutputIterator = itr8FromIterable(\n            curNextFnResult.iterable,\n          );\n          operatorState.isLastOutputIterator = !!curNextFnResult.isLast;\n          if (operatorState.currentOutputIterator?.next === undefined) {\n            throw new Error(\n              \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\",\n            );\n          }\n          returnedIterator.next = generateNextFromOutputIteratorSync;\n          return returnedIterator.next();\n        } else {\n          // we need to call nextIn again\n          // goto next round of while loop\n        }\n      }\n    };\n\n    let outputIteratorIsAsync: boolean | undefined = undefined;\n    let inputIteratorIsAsync: boolean | undefined = undefined;\n    let nextFnIsAsync: boolean | undefined = undefined;\n\n    const generateDoneAsync: () => Promise<\n      IteratorResult<TOut>\n    > = async () => ({\n      done: true,\n      value: undefined,\n    });\n    const generateNextFromOutputIteratorAsync: () => Promise<\n      IteratorResult<TOut>\n    > = async () => {\n      // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n      if (operatorState.currentOutputIterator) {\n        const possibleNextValueOrPromise =\n          operatorState.currentOutputIterator.next();\n        if (outputIteratorIsAsync === undefined)\n          outputIteratorIsAsync = isPromise(possibleNextValueOrPromise);\n        const possibleNext = (\n          outputIteratorIsAsync\n            ? await possibleNextValueOrPromise\n            : possibleNextValueOrPromise\n        ) as IteratorResult<TOut>;\n\n        if (possibleNext.done) {\n          operatorState.currentOutputIterator = undefined;\n          if (operatorState.isLastOutputIterator) {\n            returnedIterator.next = generateDoneAsync; // operatorState.done = true;\n            return { done: true, value: undefined };\n          } else {\n            returnedIterator.next = generateNextReturnValAsync;\n            return returnedIterator.next();\n          }\n        } else {\n          return possibleNext;\n        }\n      }\n    };\n\n    const generateNextReturnValAsync = async (): Promise<\n      IteratorResult<TOut>\n    > => {\n      // while loop instead of calling this function recursively (call stack can become to large)\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        // no running iterator, so we need to possibly call nextFn again\n        const nextInPromiseOrValue = itIn.next();\n        if (inputIteratorIsAsync === undefined)\n          inputIteratorIsAsync = isPromise(nextInPromiseOrValue);\n        const nextIn = inputIteratorIsAsync\n          ? await nextInPromiseOrValue\n          : nextInPromiseOrValue;\n        const curNextFnResultPromiseOrValue = nextFn(\n          nextIn as IteratorResult<TIn>,\n          operatorState.state,\n        );\n        if (nextFnIsAsync === undefined)\n          nextFnIsAsync = isPromise(curNextFnResultPromiseOrValue);\n\n        const curNextFnResult = (\n          nextFnIsAsync\n            ? await curNextFnResultPromiseOrValue\n            : curNextFnResultPromiseOrValue\n        ) as TNextFnResult<TOut, TState>;\n        if (\"state\" in curNextFnResult)\n          operatorState.state = curNextFnResult.state as TState;\n\n        if (curNextFnResult.done) {\n          // make sure we keep returning done\n          returnedIterator.next = generateDoneAsync; // operatorState.done = true;\n          return { done: curNextFnResult.done, value: undefined };\n        } else if (\"value\" in curNextFnResult) {\n          if (curNextFnResult.isLast) {\n            returnedIterator.next = generateDoneAsync; // operatorState.done = true;\n          }\n          return { done: false, value: curNextFnResult.value };\n        } else if (\"iterable\" in curNextFnResult) {\n          if (operatorState.currentOutputIterator !== undefined)\n            throw new Error(\n              \"currentOutputIterator should be undefined at this point\",\n            );\n          operatorState.currentOutputIterator = itr8FromIterable(\n            curNextFnResult.iterable,\n          );\n          operatorState.isLastOutputIterator = !!curNextFnResult.isLast;\n          if (operatorState.currentOutputIterator?.next === undefined) {\n            throw new Error(\n              \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\",\n            );\n          }\n          returnedIterator.next = generateNextFromOutputIteratorAsync;\n          return returnedIterator.next();\n        } else {\n          // we need to call nextIn again\n          // goto next round of while loop\n          // return generateNextReturnValAsync();\n        }\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Here is the returned IterableIterator\n    ////////////////////////////////////////////////////////////////////////////////\n    const returnedIterator = {\n      // return the current (async?) iterator to make it an iterable iterator (so we can use for ... of)\n      // since we can only know whether the output will be sync or async after the first next call,\n      // we'll expose both iterator and asynciterator functions...\n      [Symbol.iterator]: () => returnedIterator,\n      [Symbol.asyncIterator]: () => returnedIterator,\n      // pipe: (op:TTransIteratorSyncOrAsync) => op(retVal as Iterator<TOut>),\n      next: () => {\n        const n = generateFirstReturnValIfPossible();\n        if (isPromise(n)) {\n          return (async () => {\n            // make sure all is handled before we decide what the next() function will become\n            const nResolved = await n;\n            returnedIterator.next =\n              operatorState.currentOutputIterator === undefined\n                ? generateNextReturnValAsync\n                : generateNextFromOutputIteratorAsync;\n            return nResolved !== null ? nResolved : returnedIterator.next();\n          })();\n        } else {\n          returnedIterator.next =\n            operatorState.currentOutputIterator === undefined\n              ? generateNextReturnValSync\n              : generateNextFromOutputIteratorSync;\n          return n !== null ? n : returnedIterator.next();\n        }\n      },\n      // when the iterator is 'abandoned' (the user indicates no more next() calls will follow)\n      // we can do cleanup, but we also pass the message to our incoming iterator!\n      return: (value?: any) => {\n        itIn.return?.();\n        return returnedIterator.next === generateNextReturnValSync\n          ? { done: true, value }\n          : Promise.resolve({ done: true, value });\n      },\n      // when the iterator get a throw() call\n      // (the user indicates no more next() calls will follow because of an error)\n      // we can do cleanup, but we also pass the message to our incoming iterator!\n      throw: (err?: any) => {\n        itIn.throw?.(err);\n        return returnedIterator.next === generateNextReturnValSync\n          ? { done: true, value: undefined }\n          : Promise.resolve({ done: true, value: undefined });\n      },\n    };\n\n    return returnedIterator as\n      | IterableIterator<TOut>\n      | AsyncIterableIterator<TOut>;\n  };\n\n  const transIt = (\n    itIn: Iterator<TIn> | AsyncIterator<TIn>,\n  ): IterableIterator<TOut> | AsyncIterableIterator<TOut> => {\n    try {\n      return operatorFunction(itIn, initialStateFactory());\n    } catch (err) {\n      itIn.throw?.();\n      throw err;\n    }\n  };\n\n  // let cachedValueThenable:\n  //   | ((x: any | Promise<any>) => TThenable<any>)\n  //   | undefined = undefined;\n\n  /**\n   * Experiment: we could expose the \"transNextFn\" which is similar to a transducer:\n   * it is a function that transforms an existing nextFn, and by linking them all together\n   * we'll get a nextFn that combines multiple oeprations meaning we only need one 'intermediate'\n   * iterator. This might be more performant.\n   * But that can only be done if input and output match so they can be composed.\n   *\n   * So instead of getting (nextIn, state, params) as input (without the state) and\n   * TNextFnResult as output (without the state as well) we could create a function that\n   * gets TNextFnResult as input as well (or at least a subset of all the possibilities).\n   *\n   * By subset I mean: maybe only when they have a value or an iterable, and not when they\n   * have no value (meaning the element is skipped).\n   */\n  transIt.transNextFn = (\n    input: TNextFnResult<TIn, undefined>,\n  ): TNextFnResult<TOut, undefined> => {\n    const operatorState: TOperatorState = {\n      state: initialStateFactory(),\n      currentOutputIterator: undefined,\n      isLastOutputIterator: false,\n      // done: false,\n    };\n\n    if (input.done === true) {\n      return input;\n    } else if (/* input.done === false && */ \"iterable\" in input) {\n      const iterator =\n        input.iterable[Symbol.iterator] || input.iterable[Symbol.asyncIterator];\n      const iterable: TOut[] = [];\n      const f = forLoop(\n        () => iterator.next(),\n        (n) => n.done !== true,\n        (n) => iterator.next(),\n        (nextIn: IteratorResult<TIn>) => {\n          thenable(\n            nextFn(nextIn as IteratorResult<TIn>, operatorState.state),\n          ).then((curNextFnResult) => {\n            // store the new state\n            operatorState.state = curNextFnResult.state;\n\n            // if it contains an iterable => iterate over it, otherwise add the value to the output array\n            if (curNextFnResult.done === false && curNextFnResult.iterable) {\n              // TODO support async iterable !!!\n              iterable.push(...curNextFnResult.iterable);\n            } else {\n              iterable.push(curNextFnResult.value);\n            }\n          }).src;\n        },\n      );\n      return thenable(f).then((_forLoopResult) => {\n        return { done: false, iterable };\n      }).src;\n    } else if (/* input.done === false && */ \"value\" in input) {\n      // if (cachedValueThenable === undefined) {\n      //   cachedValueThenable = thenableFactory(input);\n      // }\n      // return cachedValueThenable(input)\n      // .then((input) =>\n      return thenable(\n        nextFn(input as IteratorResult<TIn>, operatorState.state),\n      ).then((curNextFnResult) => {\n        const { newState, ...retVal } = curNextFnResult;\n        // store the new state\n        operatorState.state = curNextFnResult.state;\n        return retVal;\n      }).src;\n    } else {\n      // no value nor iterable in input, meaning this element should be skipped\n      // so don't call any other transformers on this element\n      return input;\n    }\n  };\n\n  return transIt;\n};\n\n/**\n * EXPERIMENTAL VERSION OF THIS FUNCTION written with forLoop and thenable, which might be easier\n * to read or maintain, and could be faster...\n *\n * An operator is 'a function that generates a transIterator'.\n * So for example filter(...) is an operator, because when called with an argument\n * (the filter function) the result of that will be another function which is the transIterator.\n *\n * A transIterator is simply a function with an iterator as single argument which will return\n * another iterator. This way we can easily 'build a chain of mulitple transIterators'.\n * So it transforms iterators, which is why I have called it transIterator (~transducers).\n *\n * powerMap is a function that generates a transIteratorthat\n * will work both on synchronous and asynchronous iterators.\n * The factory needs to be provided with a single function of the form:\n *\n * ```typescript\n * (nextOfPreviousIteratorInTheChain, state) => TNextFnResult | Promise<[TNextFnResult]>\n * ```\n * and an initial state\n *\n * * nextOfPreviousIteratorInTheChain is the (resolved if async) result of a next call of the input\n *   iterator. This means it will be of the form { done: true } or { done: false, value: <...> }.\n * * The state parameter is used to allow operators to have state, but not all operators need this.\n *   For example: a 'map' operator doesn't need state, but the 'skip' operator would need to keep\n * track of how many records have passed.\n * * The operator params are the argument that is given to the operator function, like a number for\n *   a 'take' operator, or the filter function for a 'filter' operator.\n *\n * Check the readme for some examples on how to write your own operators with powerMap\n * (or check the source code as all the available operators have been built using this function).\n *\n * BEWARE: NEVER MODIFY THE STATE OBJECT (or any of its children!), ALWAYS RETURN A NEW VALUE!\n *\n * QUESTION: would it be better to have an initial state producing function instead of an initial\n *  state?\n *  This way, even if nextFn would modify the state, it wouldn't mess with other instances\n *  of the same operator? Because if we'd like to deep clone the initial state ourselves, we might\n *  end up with some complex cases when classes are involved (I hope no one who's interested in\n *  this library will want to use classes in their state, because the library is more 'functional\n *  programming' oriented)\n *\n * @param nextFn\n * @param initialStateFactory a function that generates the initialSate\n * @returns a funtion taking an iterator (and optionally some argument) as input and that has an iterator as output\n *\n * @category util\n */\n// const itr8OperatorFactoryWithForLoop = function <TIn = any, TOut = any, TParams = any, TState = any>(\n//   nextFn: (nextIn: IteratorResult<TIn>, state: any, params: any) =>\n//     TNextFnResult<TOut, TState> | Promise<TNextFnResult<TOut, TState>>,\n//   initialStateFactory: () => TState,\n// ): (params: TParams) => TTransIteratorSyncOrAsync<TIn, TOut> {\n//   return function (params: TParams): TTransIteratorSyncOrAsync<TIn, TOut> {\n//     const operatorFunction = (itIn: Iterator<TIn> | AsyncIterator<TIn>, pState: TState) => {\n//       type TOperatorFactoryState = {\n//         state:TState,\n//         currentOutputIterator:Iterator<TOut> | AsyncIterator<TOut> | undefined,\n//         done:boolean,\n//       };\n\n//       const operatorFactoryState:TOperatorFactoryState = {\n//         state: pState,\n//         currentOutputIterator: undefined,\n//         done: false,\n//       };\n//       // let nextInPromiseOrValue: IteratorResult<TIn> | Promise<IteratorResult<TIn>> | undefined = undefined;\n//       // // let nextIn: IteratorResult<TIn> | undefined = undefined;\n//       // let isAsyncInput: boolean | undefined = undefined;\n//       // function updateNextInPromiseOrValue() {\n//       //   nextInPromiseOrValue = itIn.next();\n//       //   if (isAsyncInput === undefined) isAsyncInput = isPromise(nextInPromiseOrValue);\n//       // }\n//       // let isAsyncNextFn: boolean | undefined = undefined;\n//       // // let state = pState !== undefined ? pState : initialState;\n//       // let state = pState;\n\n//       // let currentOutputIterator: Iterator<TOut> | AsyncIterator<TOut> | undefined = undefined;\n//       // // let isAsyncCurrentOutputIterator:boolean | undefined = undefined;\n//       // let done = false;\n\n//       /**\n//        * Can/should we make this kind of recursive?\n//        * Figure out based on the input params whether we need to:\n//        *  * return done because done = true\n//        *  * return the next value of the current iterator\n//        *    or empty the current iterator if we're at the end and call generateNextReturnVal\n//        *  * do a call to nextFn\n//        *    * if next = async, call generateNextReturnValAsync to handle this case\n//        *    * set done to true if that is what it returns and call generateNextReturnVal\n//        *    * return the value if it returns a value\n//        *    * set current iterator if it returns an iterable and call generateNextReturnVal\n//        * @returns\n//        */\n//       const generateNextReturnVal = () => {\n\n//         forLoop<TOperatorFactoryState & { next?:IteratorResult<TOut>| undefined }>(\n//           () => (operatorFactoryState),\n//           ({next}) => next !== undefined,\n//           (state) => {\n//             if (state.done) {\n//               return { value: undefined, done: true };\n//             }\n//             // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n//             if (state.currentOutputIterator !== undefined) {\n//               return thenable(state.currentOutputIterator.next())\n//               .then((v) => {\n\n//               })\n//               if (isPromise(possibleNextValueOrPromise)) {\n//                 return generateNextReturnValAsync(true, undefined, possibleNextValueOrPromise);\n//               }\n//               const possibleNext = possibleNextValueOrPromise as IteratorResult<TOut>;\n\n//               if (possibleNext.done) {\n//                 currentOutputIterator = undefined;\n//               } else {\n//                 return possibleNext;\n//               }\n//             }\n\n//             return state;\n//           },\n//           () => {}\n//         );\n//         // while loop instead of calling this function recursively (call stack can become too large)\n//         while (true) {\n//           if (done) {\n//             return { value: undefined, done: true };\n//           }\n//           // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n//           if (currentOutputIterator) {\n//             const possibleNextValueOrPromise = currentOutputIterator.next();\n//             if (isPromise(possibleNextValueOrPromise)) {\n//               return generateNextReturnValAsync(true, undefined, possibleNextValueOrPromise);\n//             }\n//             const possibleNext = possibleNextValueOrPromise as IteratorResult<TOut>;\n\n//             if (possibleNext.done) {\n//               currentOutputIterator = undefined;\n//             } else {\n//               return possibleNext;\n//             }\n//           }\n\n//           // no running iterator, so we need to call nextFn again\n//           updateNextInPromiseOrValue();\n//           if (isAsyncInput) {\n//             return generateNextReturnValAsync(false);\n//           }\n//           const nextIn = nextInPromiseOrValue as IteratorResult<any>;\n//           const curNextFnResult = nextFn(nextIn as IteratorResult<TIn>, state, params) as TNextFnResult<TOut, TState>;\n//           if (isAsyncNextFn === undefined) isAsyncNextFn = isPromise(curNextFnResult);\n//           if (isAsyncNextFn) {\n//             return generateNextReturnValAsync(false, curNextFnResult);\n//           }\n//           if ('state' in curNextFnResult) state = curNextFnResult.state as TState;\n\n//           if (curNextFnResult.done) {\n//             done = true;\n//             // return generateNextReturnVal();\n//           } else if ('value' in curNextFnResult) {\n//             return { done: false, value: curNextFnResult.value };\n//           } else if ('iterable' in curNextFnResult) {\n//             if (currentOutputIterator !== undefined) throw new Error('currentOutputIterator should be undefined at this point');\n//             currentOutputIterator = itr8FromIterable(curNextFnResult.iterable);\n//             if (currentOutputIterator?.next === undefined) {\n//               throw new Error('Error while trying to get output iterator, did you specify something that is not an Iterable to the \\'iterable\\' property? (when using a generator function, don\\'t forget to call it in order to return an IterableIterator!)');\n//             }\n//             // goto next round of while loop\n//             // return generateNextReturnVal();\n//           } else {\n//             // we need to call nextIn again\n\n//             // goto next round of while loop\n//             // return generateNextReturnVal();\n//           }\n//         }\n//       };\n\n//       /**\n//        * Almost the same method but in case input or nextFn is async\n//        *\n//        * @param callUpdateNextInPromiseOrValue\n//        * @returns\n//        */\n//       const generateNextReturnValAsync = async (callUpdateNextInPromiseOrValue = true, nextFnResponse?, currentOutputIteratorNext?) => {\n//         let doUpdateNextInPromiseOrValue = callUpdateNextInPromiseOrValue;\n//         let alreadyKnownNextFnResponse = nextFnResponse;\n//         let alreadyKnownCurrentOutputIteratorNext = currentOutputIteratorNext;\n//         // while loop instead of calling this function recursively (call stack can become to large)\n//         while (true) {\n//           if (done) {\n//             return { value: undefined, done: true };\n//           }\n//           // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n//           if (currentOutputIterator) {\n//             let possibleNextValueOrPromise;\n//             if (alreadyKnownCurrentOutputIteratorNext !== undefined) {\n//               possibleNextValueOrPromise = alreadyKnownCurrentOutputIteratorNext;\n//               alreadyKnownCurrentOutputIteratorNext = undefined; // only the first time !!!\n//             } else {\n//               possibleNextValueOrPromise = currentOutputIterator.next() as any;\n//             }\n//             const possibleNext = (\n//               isPromise(possibleNextValueOrPromise)\n//                 ? await possibleNextValueOrPromise\n//                 : possibleNextValueOrPromise\n//             ) as IteratorResult<TOut>;\n\n//             if (possibleNext.done) {\n//               currentOutputIterator = undefined;\n//             } else {\n//               return possibleNext;\n//             }\n//           }\n\n//           // no running iterator, so we need to possibly call nextFn again\n//           if (doUpdateNextInPromiseOrValue) {\n//             updateNextInPromiseOrValue();\n//           } else {\n//             doUpdateNextInPromiseOrValue = true; // only possibly skip it the first time !!!\n//           };\n//           const nextIn = await nextInPromiseOrValue;\n//           let curNextFnResultPromiseOrValue;\n//           if (alreadyKnownNextFnResponse !== undefined) {\n//             curNextFnResultPromiseOrValue = alreadyKnownNextFnResponse;\n//             alreadyKnownNextFnResponse = undefined; // only use it the first time !!!\n//           } else {\n//             curNextFnResultPromiseOrValue = nextFn(nextIn as IteratorResult<TIn>, state, params);\n//           }\n//           if (isAsyncNextFn === undefined) isAsyncNextFn = isPromise(curNextFnResultPromiseOrValue);\n//           const curNextFnResult = (isAsyncNextFn ? await curNextFnResultPromiseOrValue : curNextFnResultPromiseOrValue) as TNextFnResult<TOut, TState>;\n//           if ('state' in curNextFnResult) state = curNextFnResult.state as TState;\n\n//           if (curNextFnResult.done) {\n//             done = true;\n//             // goto next round of while loop\n//             // return generateNextReturnValAsync();\n//           } else if ('value' in curNextFnResult) {\n//             return { done: false, value: curNextFnResult.value };\n//           } else if ('iterable' in curNextFnResult) {\n//             if (currentOutputIterator !== undefined) throw new Error('currentOutputIterator should be undefined at this point');\n//             currentOutputIterator = itr8FromIterable(curNextFnResult.iterable);\n//             if (currentOutputIterator?.next === undefined) {\n//               throw new Error('Error while trying to get output iterator, did you specify something that is not an Iterable to the \\'iterable\\' property? (when using a generator function, don\\'t forget to call it in order to return an IterableIterator!)');\n//             }\n//             // goto next round of while loop\n//             // return generateNextReturnValAsync();\n//           } else {\n//             // we need to call nextIn again\n\n//             // goto next round of while loop\n//             // return generateNextReturnValAsync();\n//           }\n//         }\n//       };\n\n//       ////////////////////////////////////////////////////////////////////////////////\n//       // Here is the returned IterableIterator\n//       ////////////////////////////////////////////////////////////////////////////////\n//       const retVal = {\n//         // return the current (async?) iterator to make it an iterable iterator (so we can use for ... of)\n//         // since we can only know whether the output will be sync or async after the first next call,\n//         // we'll expose both iterator and asynciterator functions...\n//         [Symbol.iterator]: () => retVal,\n//         [Symbol.asyncIterator]: () => retVal,\n//         // pipe: (op:TTransIteratorSyncOrAsync) => op(retVal as Iterator<TOut>),\n//         next: () => {\n//           if (isAsyncInput || isAsyncNextFn) {\n//             return generateNextReturnValAsync();\n//           }\n//           return generateNextReturnVal();\n//         },\n//       };\n\n//       return retVal as any;\n//     };\n\n//     return (itIn: Iterator<TIn> | AsyncIterator<TIn>) => operatorFunction(itIn, initialStateFactory());\n//   }\n// };\n\n/**\n * UNFINISHED (some tests are failing when using this version) !!!\n *\n * EXPERIMENTAL VERSION OF THIS FUNCTION that tries to rewrite the functions\n * after we've established which parts are synchronous (input iterator next, nextFn result, ...)\n * in order to avoid checking this over and over again.\n *\n * An operator is 'a function that generates a transIterator'.\n * So for example filter(...) is an operator, because when called with an argument\n * (the filter function) the result of that will be another function which is the transIterator.\n *\n * A transIterator is simply a function with an iterator as single argument which will return\n * another iterator. This way we can easily 'build a chain of mulitple transIterators'.\n * So it transforms iterators, which is why I have called it transIterator (~transducers).\n *\n * powerMap is a function that generates transIterators that\n * will work both on synchronous and asynchronous iterators.\n * The factory needs to be provided with a single function of the form:\n *\n * ```typescript\n * (nextOfPreviousIteratorInTheChain, state, operatorParams) => TNextFnResult | Promise<[TNextFnResult]>\n * ```\n * and an initial state\n *\n * * nextOfPreviousIteratorInTheChain is the (resolved if async) result of a next call of the input\n *   iterator. This means it will be of the form { done: true } or { done: false, value: <...> }.\n * * The state parameter is used to allow operators to have state, but not all operators need this.\n *   For example: a 'map' operator doesn't need state, but the 'skip' operator would need to keep\n * track of how many records have passed.\n * * The operator params are the argument that is given to the operator function, like a number for\n *   a 'take' operator, or the filter function for a 'filter' operator.\n *\n * Check the readme for some examples on how to write your own operators with powerMap\n * (or check the source code as all the available operators have been built using this function).\n *\n * BEWARE: NEVER MODIFY THE STATE OBJECT (or any of its children!), ALWAYS RETURN A NEW VALUE!\n *\n * QUESTION: would it be better to have an initial state producing function instead of an initial\n *  state?\n *  This way, even if nextFn would modify the state, it wouldn't mess with other instances\n *  of the same operator? Because if we'd like to deep clone the initial state ourselves, we might\n *  end up with some complex cases when classes are involved (I hope no one who's interested in\n *  this library will want to use classes in their state, because the library is more 'functional\n *  programming' oriented)\n *\n * @param nextFn\n * @param initialStateFactory a function that generates the initialSate\n * @returns a funtion taking an iterator (and optionally some argument) as input and that has an iterator as output\n *\n * @category util\n */\nconst itr8OperatorFactoryExperimental = function <\n  TIn = unknown,\n  TOut = unknown,\n  TState = unknown,\n  TParam1 = void,\n  TParam2 = void,\n  TParam3 = void,\n  TParam4 = void,\n>(\n  nextFn: (\n    nextIn: IteratorResult<TIn>,\n    state: TState,\n    param1: TParam1,\n    param2: TParam2,\n    param3: TParam3,\n    param4: TParam4,\n    ...otherParams: unknown[]\n  ) => TNextFnResult<TOut, TState> | Promise<TNextFnResult<TOut, TState>>,\n  initialStateFactory: (\n    param1: TParam1,\n    param2: TParam2,\n    param3: TParam3,\n    param4: TParam4,\n    ...otherParams: unknown[]\n  ) => TState,\n): (\n  param1: TParam1,\n  param2: TParam2,\n  param3: TParam3,\n  param4: TParam4,\n  ...otherParams: unknown[]\n) => TTransIteratorSyncOrAsync<TIn, TOut> {\n  return function (\n    param1: TParam1,\n    param2: TParam2,\n    param3: TParam3,\n    param4: TParam4,\n    ...otherParams: unknown[]\n  ): TTransIteratorSyncOrAsync<TIn, TOut> {\n    const operatorFunction = (\n      itIn: Iterator<TIn> | AsyncIterator<TIn>,\n      pState: TState,\n    ) => {\n      type TOperatorState = {\n        state: TState;\n        currentOutputIterator: Iterator<TOut> | AsyncIterator<TOut> | undefined;\n        done: boolean;\n      };\n\n      const operatorState: TOperatorState = {\n        state: pState,\n        currentOutputIterator: undefined,\n        done: false,\n      };\n\n      let nextInPromiseOrValue:\n        | IteratorResult<TIn>\n        | Promise<IteratorResult<TIn>>\n        | undefined = undefined;\n      // let nextIn: IteratorResult<TIn> | undefined = undefined;\n      let isAsyncInput: boolean | undefined = undefined;\n      function updateNextInPromiseOrValue() {\n        nextInPromiseOrValue = itIn.next();\n        if (isAsyncInput === undefined)\n          isAsyncInput = isPromise(nextInPromiseOrValue);\n      }\n      let isAsyncNextFn: boolean | undefined = undefined;\n      // let state = pState !== undefined ? pState : initialState;\n      // let state = pState;\n\n      // let currentOutputIterator: Iterator<TOut> | AsyncIterator<TOut> | undefined = undefined;\n      // let isAsyncCurrentOutputIterator:boolean | undefined = undefined;\n      // let done = false;\n\n      /**\n       * Can/should we make this kind of recursive?\n       * Figure out based on the input params whether we need to:\n       *  * return done because done = true\n       *  * return the next value of the current iterator\n       *    or empty the current iterator if we're at the end and call generateNextReturnVal\n       *  * do a call to nextFn\n       *    * if next = async, call generateNextReturnValAsync to handle this case\n       *    * set done to true if that is what it returns and call generateNextReturnVal\n       *    * return the value if it returns a value\n       *    * set current iterator if it returns an iterable and call generateNextReturnVal\n       * @returns\n       */\n      let generateNextReturnVal =\n        (): // itIn:Iterator<TIn> | AsyncIterator<TIn>,\n        // nextFn: (nextIn: IteratorResult<TIn>, state: TState, param1: TParam1, param2: TParam2, param3: TParam3, param4: TParam4, ...otherParams:unknown[]) =>\n        //         TNextFnResult<TOut, TState> | Promise<TNextFnResult<TOut, TState>>,\n        // operatorState:TOperatorState\n        IteratorResult<TOut> | Promise<IteratorResult<TOut>> => {\n          const nextReturnVal = thenable(itIn.next()).then(\n            (nextIn, isSyncInput) => {\n              return thenable(\n                nextFn(\n                  nextIn as IteratorResult<TIn>,\n                  operatorState.state,\n                  param1,\n                  param2,\n                  param3,\n                  param4,\n                  ...otherParams,\n                ),\n              ).then((nextFnResult, isSyncNextFn) => {\n                // nextFnResult as TNextFnResult<TOut, TState>\n                if (\"state\" in nextFnResult)\n                  operatorState.state = nextFnResult.state as TState;\n\n                let retVal;\n                if (nextFnResult.done) {\n                  operatorState.done = true;\n                  // return generateNextReturnVal();\n                  retVal = { done: true };\n                } else if (\"value\" in nextFnResult) {\n                  retVal = { done: false, value: nextFnResult.value };\n                } else if (\"iterable\" in nextFnResult) {\n                  if (operatorState.currentOutputIterator !== undefined)\n                    throw new Error(\n                      \"currentOutputIterator should be undefined at this point\",\n                    );\n                  operatorState.currentOutputIterator = itr8FromIterable(\n                    nextFnResult.iterable,\n                  );\n                  if (operatorState.currentOutputIterator?.next === undefined) {\n                    throw new Error(\n                      \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\",\n                    );\n                  }\n                  // goto next round of while loop\n                  // return generateNextReturnVal();\n                } else {\n                  // we need to call nextIn again\n                  // goto next round of while loop\n                  // return generateNextReturnVal();\n                }\n\n                // now we can rewrite the current function in an optimized way because we know\n                // which parts are async (if any) and which not\n                // const newGenerateNextReturnVal = new (isSyncInput && isSyncNextFn ? Function : AsyncFunction)(\n                //   'itIn',\n                //   'nextFn',\n                //   'operatorState',\n                //   `\n                //     // while loop instead of calling this function recursively (call stack can become too large)\n                //     // console.log('operatorState', operatorState);\n                //     while (true) {\n                //       if (operatorState.done) {\n                //         return { value: undefined, done: true };\n                //       }\n                //       // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n                //       if (operatorState.currentOutputIterator) {\n                //         const possibleNextValueOrPromise = operatorState.currentOutputIterator.next();\n                //         // if (isPromise(possibleNextValueOrPromise)) {\n                //         // if (typeof possibleNextValueOrPromise.then === 'Function') {\n                //         //     throw new Error('Async iterables inside nextFn response not supported at this time!!!');\n                //         //   // return { done: true };\n                //         // }\n                //         const possibleNext = possibleNextValueOrPromise;\n\n                //         if (possibleNext.done) {\n                //           operatorState.currentOutputIterator = undefined;\n                //         } else {\n                //           return possibleNext;\n                //         }\n                //       }\n\n                //       // no running iterator, so we need to call nextFn again\n                //       const nextIn = ${isSyncInput ? '' : 'await '}itIn.next();\n                //       const [_itIn, _nextFn, _operatorState, ...otherArgs] = [...arguments];\n                //       const curNextFnResult = ${isSyncNextFn ? '' : 'await '}nextFn(nextIn, operatorState.state, ...otherArgs);\n                //       if ('state' in curNextFnResult) operatorState.state = curNextFnResult.state as TState;\n\n                //       if (curNextFnResult.done) {\n                //         operatorState.done = true;\n                //       } else if ('value' in curNextFnResult) {\n                //         return { done: false, value: curNextFnResult.value };\n                //       } else if ('iterable' in curNextFnResult) {\n                //         if (operatorState.currentOutputIterator !== undefined) throw new Error('currentOutputIterator should be undefined at this point');\n                //         // operatorState.currentOutputIterator = (curNextFnResult.iterable[Symbol.iterator] || curNextFnResult.iterable[Symbol.asyncIterator])(); // itr8FromIterable(curNextFnResult.iterable);\n                //         if (curNextFnResult.iterable[Symbol.iterator]) {\n                //           operatorState.currentOutputIterator = curNextFnResult.iterable[Symbol.iterator]();\n                //         } else if (curNextFnResult.iterable[Symbol.asyncIterator]) {\n                //           operatorState.currentOutputIterator = curNextFnResult.iterable[Symbol.asyncIterator]();\n                //         }\n\n                //         if (!operatorState.currentOutputIterator || operatorState.currentOutputIterator.next === undefined) {\n                //           throw new Error('Error while trying to get output iterator, did you specify something that is not an Iterable to the \\\\'iterable\\\\' property? (when using a generator function, don\\\\'t forget to call it in order to return an IterableIterator!)');\n                //         }\n                //         // goto next round of while loop\n                //       } else {\n                //         // we need to call nextIn again\n                //         // goto next round of while loop\n                //       }\n                //     }\n                //   `,\n                // ) as () => IteratorResult<TOut> | Promise<IteratorResult<TOut>>;\n\n                /**\n                 * Can return a value or undefined\n                 * @param curNextFn\n                 */\n                const handleCurNextFnResult = (\n                  curNextFnResult: TNextFnResult<TOut, TState>,\n                ): IteratorResult<TOut> | undefined => {\n                  if (curNextFnResult.done) {\n                    operatorState.done = true;\n                  } else if (\"value\" in curNextFnResult) {\n                    return { done: false, value: curNextFnResult.value };\n                  } else if (\"iterable\" in curNextFnResult) {\n                    if (operatorState.currentOutputIterator !== undefined)\n                      throw new Error(\n                        \"currentOutputIterator should be undefined at this point\",\n                      );\n                    // operatorState.currentOutputIterator = (curNextFnResult.iterable[Symbol.iterator] || curNextFnResult.iterable[Symbol.asyncIterator])(); // itr8FromIterable(curNextFnResult.iterable);\n                    if (curNextFnResult.iterable[Symbol.iterator]) {\n                      operatorState.currentOutputIterator =\n                        curNextFnResult.iterable[Symbol.iterator]();\n                    } else if (curNextFnResult.iterable[Symbol.asyncIterator]) {\n                      operatorState.currentOutputIterator =\n                        curNextFnResult.iterable[Symbol.asyncIterator]();\n                    } else {\n                      // (!operatorState.currentOutputIterator || operatorState.currentOutputIterator.next === undefined) {\n                      throw new Error(\n                        \"Error while trying to get output iterator, did you specify something that is not an Iterable to the 'iterable' property? (when using a generator function, don't forget to call it in order to return an IterableIterator!)\",\n                      );\n                    }\n                    // goto next round of while loop\n                  } else {\n                    // we need to call nextIn again\n                    // goto next round of while loop\n                  }\n                  return undefined;\n                };\n\n                let newGenerateNextReturnVal;\n                if (isSyncInput && isSyncNextFn) {\n                  // sync version\n                  newGenerateNextReturnVal = () => {\n                    // while loop instead of calling this function recursively (call stack can become too large)\n                    // console.log('operatorState', operatorState);\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                      if (operatorState.done) {\n                        return { value: undefined, done: true };\n                      }\n                      // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n                      if (operatorState.currentOutputIterator) {\n                        const possibleNextValueOrPromise =\n                          operatorState.currentOutputIterator.next();\n                        // if (isPromise(possibleNextValueOrPromise)) {\n                        // if (typeof possibleNextValueOrPromise.then === 'Function') {\n                        //     throw new Error('Async iterables inside nextFn response not supported at this time!!!');\n                        //   // return { done: true };\n                        // }\n                        const possibleNext =\n                          possibleNextValueOrPromise as IteratorResult<TOut>;\n\n                        if (possibleNext.done) {\n                          operatorState.currentOutputIterator = undefined;\n                        } else {\n                          return possibleNext;\n                        }\n                      }\n\n                      // no running iterator, so we need to call nextFn again\n                      const nextIn = itIn.next() as IteratorResult<TIn>;\n                      const curNextFnResult = nextFn(\n                        nextIn,\n                        operatorState.state,\n                        param1,\n                        param2,\n                        param3,\n                        param4,\n                        ...otherParams,\n                      ) as TNextFnResult<TOut, TState>;\n                      if (\"state\" in curNextFnResult)\n                        operatorState.state = curNextFnResult.state as TState;\n\n                      const r = handleCurNextFnResult(curNextFnResult);\n                      if (r !== undefined) {\n                        return r;\n                      }\n                      // if not returned, continue to the next round of the while loop\n                    }\n                  };\n                } else if (isSyncInput) {\n                  newGenerateNextReturnVal = async () => {\n                    // while loop instead of calling this function recursively (call stack can become too large)\n                    // console.log('operatorState', operatorState);\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                      if (operatorState.done) {\n                        return { value: undefined, done: true };\n                      }\n                      // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n                      if (operatorState.currentOutputIterator) {\n                        const possibleNextValueOrPromise =\n                          operatorState.currentOutputIterator.next();\n                        // if (isPromise(possibleNextValueOrPromise)) {\n                        // if (typeof possibleNextValueOrPromise.then === 'Function') {\n                        //     throw new Error('Async iterables inside nextFn response not supported at this time!!!');\n                        //   // return { done: true };\n                        // }\n                        const possibleNext =\n                          possibleNextValueOrPromise as IteratorResult<TOut>;\n\n                        if (possibleNext.done) {\n                          operatorState.currentOutputIterator = undefined;\n                        } else {\n                          return possibleNext;\n                        }\n                      }\n\n                      // no running iterator, so we need to call nextFn again\n                      const nextIn = itIn.next() as IteratorResult<TIn>;\n                      const curNextFnResult = (await nextFn(\n                        nextIn,\n                        operatorState.state,\n                        param1,\n                        param2,\n                        param3,\n                        param4,\n                        ...otherParams,\n                      )) as TNextFnResult<TOut, TState>;\n                      if (\"state\" in curNextFnResult)\n                        operatorState.state = curNextFnResult.state as TState;\n\n                      const r = handleCurNextFnResult(curNextFnResult);\n                      if (r !== undefined) {\n                        return r;\n                      }\n                      // if not returned, continue to the next round of the while loop\n                    }\n                  };\n                } else if (isSyncNextFn) {\n                  newGenerateNextReturnVal = async () => {\n                    // while loop instead of calling this function recursively (call stack can become too large)\n                    // console.log('operatorState', operatorState);\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                      if (operatorState.done) {\n                        return { value: undefined, done: true };\n                      }\n                      // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n                      if (operatorState.currentOutputIterator) {\n                        const possibleNextValueOrPromise =\n                          operatorState.currentOutputIterator.next();\n                        // if (isPromise(possibleNextValueOrPromise)) {\n                        // if (typeof possibleNextValueOrPromise.then === 'Function') {\n                        //     throw new Error('Async iterables inside nextFn response not supported at this time!!!');\n                        //   // return { done: true };\n                        // }\n                        const possibleNext =\n                          possibleNextValueOrPromise as IteratorResult<TOut>;\n\n                        if (possibleNext.done) {\n                          operatorState.currentOutputIterator = undefined;\n                        } else {\n                          return possibleNext;\n                        }\n                      }\n\n                      // no running iterator, so we need to call nextFn again\n                      const nextIn = (await itIn.next()) as IteratorResult<TIn>;\n                      const curNextFnResult = nextFn(\n                        nextIn,\n                        operatorState.state,\n                        param1,\n                        param2,\n                        param3,\n                        param4,\n                        ...otherParams,\n                      ) as TNextFnResult<TOut, TState>;\n                      if (\"state\" in curNextFnResult)\n                        operatorState.state = curNextFnResult.state as TState;\n\n                      const r = handleCurNextFnResult(curNextFnResult);\n                      if (r !== undefined) {\n                        return r;\n                      }\n                      // if not returned, continue to the next round of the while loop\n                    }\n                  };\n                } else {\n                  newGenerateNextReturnVal = async () => {\n                    // while loop instead of calling this function recursively (call stack can become too large)\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                      if (operatorState.done) {\n                        return { value: undefined, done: true };\n                      }\n                      // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n                      if (operatorState.currentOutputIterator) {\n                        const possibleNextValueOrPromise =\n                          operatorState.currentOutputIterator.next();\n                        // if (isPromise(possibleNextValueOrPromise)) {\n                        // if (typeof possibleNextValueOrPromise.then === 'Function') {\n                        //     throw new Error('Async iterables inside nextFn response not supported at this time!!!');\n                        //   // return { done: true };\n                        // }\n                        const possibleNext =\n                          possibleNextValueOrPromise as IteratorResult<TOut>;\n\n                        if (possibleNext.done) {\n                          operatorState.currentOutputIterator = undefined;\n                        } else {\n                          return possibleNext;\n                        }\n                      }\n\n                      // no running iterator, so we need to call nextFn again\n                      const nextIn = (await itIn.next()) as IteratorResult<TIn>;\n                      const curNextFnResult = (await nextFn(\n                        nextIn,\n                        operatorState.state,\n                        param1,\n                        param2,\n                        param3,\n                        param4,\n                        ...otherParams,\n                      )) as TNextFnResult<TOut, TState>;\n                      if (\"state\" in curNextFnResult)\n                        operatorState.state = curNextFnResult.state as TState;\n\n                      const r = handleCurNextFnResult(curNextFnResult);\n                      if (r !== undefined) {\n                        return r;\n                      }\n                      // if not returned, continue to the next round of the while loop\n                    }\n                  };\n                }\n\n                // now overwrite the function within the same context as the original function\n                generateNextReturnVal = newGenerateNextReturnVal;\n\n                // console.log('           ----> next return val will be', retVal);\n                return retVal || generateNextReturnVal(); // generateNextReturnVal(itIn, nextFn, operatorState, param1, param2, param3, param4, ...otherParams);\n              });\n            },\n          ).src;\n\n          // console.log('         ----> next return val will be', nextReturnVal);\n          return nextReturnVal;\n        };\n\n      ////////////////////////////////////////////////////////////////////////////////\n      // Here is the returned IterableIterator\n      ////////////////////////////////////////////////////////////////////////////////\n      const retVal = {\n        // return the current (async?) iterator to make it an iterable iterator (so we can use for ... of)\n        // since we can only know whether the output will be sync or async after the first next call,\n        // we'll expose both iterator and asynciterator functions...\n        [Symbol.iterator]: () => retVal,\n        [Symbol.asyncIterator]: () => retVal,\n        // pipe: (op:TTransIteratorSyncOrAsync) => op(retVal as Iterator<TOut>),\n        next: ():\n          | IteratorResult<TOut>\n          | Promise<IteratorResult<TOut>>\n          | IteratorResult<TOut[]>\n          | Promise<IteratorResult<TOut[]>> => {\n          return generateNextReturnVal(); // generateNextReturnVal(itIn, nextFn, operatorState, param1, param2, param3, param4, ...otherParams);\n        },\n      };\n\n      return retVal as IterableIterator<TOut> | AsyncIterableIterator<TOut>;\n    };\n\n    return (\n      itIn: Iterator<TIn> | AsyncIterator<TIn>,\n    ): IterableIterator<TOut> | AsyncIterableIterator<TOut> =>\n      operatorFunction(\n        itIn,\n        initialStateFactory(param1, param2, param3, param4, ...otherParams),\n      );\n  };\n};\n\nexport { powerMapWithoutDoAfter as powerMap };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * Only take elements as long as the filter function returns true.\n *\n * The filter function can be asynchronous (in which case the resulting iterator will be\n * asynchronous regardless of the input iterator)!\n *\n * @category operators/general\n */\nconst takeWhile = <TIn>(filterFn: (x: TIn) => boolean | Promise<boolean>) =>\n  powerMap<TIn, TIn, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) return { done: true };\n\n      return thenable(filterFn(nextIn.value)).then((filterFnResult) => {\n        if (filterFnResult) return { done: false, value: nextIn.value };\n        return { done: true };\n      }).src;\n    },\n    () => undefined,\n  );\n\nexport { takeWhile };\n", "import { takeWhile } from \"../operators/general/takeWhile.js\";\nimport { pipe } from \"../util/index.js\";\nimport { forEach } from \"./forEach.js\";\n\n/**\n * When you want to process the same iterator mutltiple times in different ways\n * (you can think of it as 'splitting the stream'),\n * it would be cool to have a way to 'subscribe' many times to the same iterator.\n * An IterableIterator returns an iterator, but that will always return the current iterator,\n * and not a new one.\n *\n * This function produces an Iterable that returns a new iterator each time [Symbol.asyncIterator]()\n * gets called, so one needs to call next on all output iterators separately to get the next element\n * of the input iterator.\n *\n * This method creates a function that turns the iterator into an Iterable that returns\n * a new iterator on calling [Symbol.asynIterator] that starts from the current element\n * (or the oldest element any of the subscribers is at?) that we are at in the source iterator.\n *\n * In order to support the fact that not all output iterators will be pulled at the same time,\n * we need to keep a cache + the position that each iterator is at.\n *\n * @todo In order to protect ourselves from 'abandoned' iterators, a timeout could be used\n * to clean them up, so the cache can be emptied up to the oldest 'active' iterator.\n *\n * @category interface/standard\n */\nfunction itr8ToMultiIterable<T>(\n  it:\n    | Iterator<T>\n    | AsyncIterator<T> /*, abandonedTimeoutMilliseconds = Infinity */,\n): AsyncIterable<T> | Iterable<T> {\n  const subscriberMap: Map<\n    AsyncIterableIterator<T> | IterableIterator<T>,\n    number\n  > = new Map();\n  const buffer: Map<number, IteratorResult<T> | Promise<IteratorResult<T>>> =\n    new Map();\n\n  /** Helper to remove old elements from buffer that all current subscribers have read */\n  const cleanBuffer = () => {\n    const minIndex = Math.min(...subscriberMap.values());\n    // Maps are iterated in insertion order !\n    // ['IMPERATIVE' VERSION]\n    // for (const i of buffer.keys()) {\n    //   if (i < minIndex) {\n    //     buffer.delete(i);\n    //   } else {\n    //     break;\n    //   }\n    // }\n    // ['DECLARATIVE' VERSION]\n    pipe(\n      buffer.keys(),\n      takeWhile((i) => i < minIndex),\n      forEach((i) => {\n        buffer.delete(i);\n      }),\n    );\n  };\n  const iteratorGetter = () => {\n    const outIt: IterableIterator<T> | AsyncIterableIterator<T> = {\n      [Symbol.iterator]: () => outIt as IterableIterator<T>,\n      [Symbol.asyncIterator]: () => outIt as AsyncIterableIterator<T>,\n      next: () => {\n        const index = subscriberMap.get(outIt) as number;\n        if (!buffer.has(index)) {\n          buffer.set(index, it.next());\n        }\n        // remove old stuff in buffer\n        cleanBuffer();\n\n        subscriberMap.set(outIt, index + 1);\n        // if (isPromise(buffer.get(index))) {\n        //   return (buffer.get(index) ?? { done: true }) as Promise<IteratorResult<T>>;\n        // } else {\n        return (buffer.get(index) ?? { done: true }) as IteratorResult<T>;\n        // }\n      },\n      return: (value?: T) => {\n        subscriberMap.delete(outIt);\n        cleanBuffer();\n        return { done: true, value };\n      },\n      throw: (error?) => {\n        subscriberMap.delete(outIt);\n        cleanBuffer();\n        return { done: true, value: undefined };\n      },\n    };\n\n    // add the new iterator to the subscriberMap\n    subscriberMap.set(\n      outIt,\n      buffer.size === 0 ? 0 : Math.min(...buffer.keys()),\n    );\n    // TODO: set a disconnect timeout (we'll need to store the last get time, or the timeout id)\n    return outIt;\n  };\n\n  const retVal: AsyncIterable<T> | Iterable<T> = {\n    [Symbol.asyncIterator]: () => iteratorGetter() as AsyncIterableIterator<T>,\n    [Symbol.iterator]: () => iteratorGetter() as IterableIterator<T>,\n  };\n\n  // subscriberMap.set(outIt, buffer.size > 0 ? buffer.values.next().value : 0);\n  return retVal;\n}\n\nexport { itr8ToMultiIterable };\n", "import { isPromise } from \"../../util/index.js\";\n\n/**\n * Probably only useful on async iterators.\n *\n * It will turn an async iterator into an asynchronous iterator that will always return the\n * last known value, while waiting for the promise on the incoming iterator to resolve.\n *\n * Every value on the incoming iterator will be returned at least once in order to keep\n * the operator 'passive'. This operator will not actively drain the incoming iterator.\n *\n * @example\n * ```typescript\n * // input iterator\n * const it = itr8.itr8Pushable<string>();\n * // output iterator that will always return the mostRecent value of the input iterator\n * const itOut = pipe(it, mostRecent('My initial value'));\n *\n * await sleep(1);\n * await itOut.next(); // => { value: 'My initial value' }\n * await itOut.next(); // => { value: 'My initial value' }\n * await sleep(1);\n * await itOut.next(); // => { value: 'My initial value' }\n *\n * it.push('2nd value');\n * await sleep(1);\n * await itOut.next(); // => { value: '2nd value' }\n * await itOut.next(); // => { value: '2nd value' }\n *\n * it.push('third value');\n * // sync so 'third value' promise not resolved yet at this point\n * await itOut.next(); // => { value: '2nd value' }\n * await sleep(1);\n * await itOut.next(); // => { value: 'third value' }\n * await itOut.next(); // => { value: 'third value' }\n * await sleep(1);\n * await itOut.next(); // => { value: 'third value' }\n *\n * // see evey value at least once!!!\n * it.push('fourth value');\n * it.push('fifth value');\n * // sync so 'third value' promise not resolved yet\n * await itOut.next(); // => { value: 'third value' }\n * await sleep(0);\n * await itOut.next(); // => { value: 'fourth value' }\n * await sleep(0);\n * await itOut.next(); // => { value: 'fifth value' }\n *\n * it.done();\n * // sync so 'done' promise not resolved yet\n * await itOut.next(); // => { value: 'fifth value' }\n * await sleep(1);\n * await itOut.next(); // => { done: true }\n * await itOut.next(); // => { done: true }\n * ```\n *\n * @category operators/async\n */\nconst mostRecent = <T>(initalValue: T) => {\n  return (it: Iterator<T> | AsyncIterator<T>): AsyncIterator<T> => {\n    let nextOut: IteratorResult<T> = { value: initalValue };\n    let resolveNextOutRead;\n\n    const handleInputPromise = async () => {\n      let nextOutRead: Promise<boolean> | undefined = undefined;\n      do {\n        if (isPromise(nextOutRead)) {\n          await nextOutRead;\n        }\n        nextOut = await it.next();\n        nextOutRead = new Promise((resolve, reject) => {\n          resolveNextOutRead = resolve;\n        });\n      } while (!nextOut.done);\n    };\n\n    const retVal: AsyncIterableIterator<T> = {\n      // [Symbol.iterator]: () => retVal as IterableIterator<T>,\n      [Symbol.asyncIterator]: () => retVal,\n      next: async () => {\n        if (resolveNextOutRead === undefined) {\n          handleInputPromise();\n        } else {\n          resolveNextOutRead(true);\n        }\n        return nextOut;\n      },\n      // when the iterator is 'abandoned' (the user indicates no more next() calls will follow)\n      // we can do cleanup, but we also pass the message to our incoming iterator!\n      return: async (value?: any) => {\n        it.return?.();\n        return { done: true, value };\n      },\n      // when the iterator get a throw() call\n      // (the user indicates no more next() calls will follow because of an error)\n      // we can do cleanup, but we also pass the message to our incoming iterator!\n      throw: async (err: any) => {\n        it.throw?.(err);\n        return { done: true, value: undefined };\n      },\n    };\n\n    return retVal;\n  };\n};\n\nexport { mostRecent };\n", "import { isPromise } from \"../../util/index.js\";\n\n/**\n * Probably only useful on async iterators.\n *\n * Instead of only asking for the next value of the incoming iterator when a next call comes in,\n * make sure to do one or more next calls to the incoming iterator up-front, to decrease the\n * waiting time.\n *\n * This can be used to kind of 'parallelize' the processing, while respecting the order.\n * If the order is not important, you might want to take a look a the parallel(...) operator!\n *\n * This one can be useful, when the result needs to do some I/O (for example an API get\n * or a DB fetch), and processing also takes up a certain amount of time due to I/O.\n * In this case, it makes sense to already do the next call on the incoming iterator up-front,\n * so that it will hopefully already have resolved by the time you need it for processing.\n *\n * Nothing will be done before the first next call, but after the first next call the iterator\n * will always try to have a buffer with the given amount of prefetched results (which will be\n * impossible to achieve if processing is generally faster than fetching).\n *\n * forEach actually by default acts like it has a prefetch of 1, but imagine a case where the\n * processing time can vary significantly. Then, when processing takes a long time, by prefetching\n * more than one you can make sure that there is no waiting time for the next (maybe very fast)\n * processing to start because the promises they act upon are already resolved by the time they\n * are needed.\n *\n * @category operators/async\n */\nconst prefetch = (amount: number) => {\n  return <T>(\n    it: Iterator<T> | AsyncIterator<T>,\n  ): IterableIterator<T> | AsyncIterableIterator<T> => {\n    let inputs: Array<Promise<IteratorResult<T>> | IteratorResult<T>> = [];\n    let isAsyncInput: boolean;\n    const addInputIfNeeded = async () => {\n      if (inputs.length < amount) {\n        if (isAsyncInput && inputs.length > 0) await inputs[0];\n        const next = it.next();\n        if (isPromise(next)) {\n          // console.log('     add another (async) input, current nr of inputs = ', inputs.length, ' < ', amount);\n          isAsyncInput = true;\n          next.then((n) => {\n            if (!n.done) {\n              // console.log('  then: call addInputIfNeeded(), current nr of inputs = ', inputs.length, ' < ', amount);\n              addInputIfNeeded();\n            }\n          });\n        }\n        inputs.push(next);\n      }\n    };\n\n    const retVal = {\n      [Symbol.asyncIterator]: () => retVal as AsyncIterableIterator<T>,\n      [Symbol.iterator]: () => retVal as IterableIterator<T>,\n      next: () => {\n        // console.log('  next: call addInputIfNeeded(), current nr of inputs = ', inputs.length, ' < ', amount);\n        addInputIfNeeded();\n        if (inputs.length > 0) {\n          const [firstInput, ...remainingInputs] = inputs;\n          inputs = remainingInputs;\n          // console.log('  next: call 2 to addInputIfNeeded(), current nr of inputs = ', inputs.length, ' < ', amount);\n          addInputIfNeeded();\n          // console.log('  next: return ', firstInput);\n          return firstInput;\n        }\n        return isAsyncInput\n          ? (Promise.resolve({ done: true, value: undefined }) as Promise<\n              IteratorResult<T>\n            >)\n          : ({ done: true, value: undefined } as IteratorResult<T>);\n      },\n      // when the iterator is 'abandoned' (the user indicates no more next() calls will follow)\n      // we can do cleanup, but we also pass the message to our incoming iterator!\n      return: (value?: any) => {\n        it.return?.();\n        return isAsyncInput\n          ? Promise.resolve({ done: true, value })\n          : { done: true, value };\n      },\n      // when the iterator get a throw() call\n      // (the user indicates no more next() calls will follow because of an error)\n      // we can do cleanup, but we also pass the message to our incoming iterator!\n      throw: (err?: any) => {\n        it.throw?.(err);\n        return isAsyncInput\n          ? Promise.resolve({ done: true, value: undefined })\n          : { done: true, value: undefined };\n      },\n    };\n\n    return retVal as IterableIterator<T> | AsyncIterableIterator<T>;\n  };\n};\n\nexport { prefetch };\n", "import { pipe } from \"../../util/index.js\";\nimport {\n  forEach,\n  itr8FromSingleValue,\n  itr8Pushable,\n  itr8ToArray,\n} from \"../../interface/index.js\";\nimport { TPushable, TTransIteratorSyncOrAsync } from \"../../types\";\n\n/**\n * This operator should make it easy to run asynchronous transIterators in parallel, in order\n * to speed things up.\n * You can think of it as multiple lanes on a highway, but the output order of the elements\n * is still guaranteed by default! But if the order doesn't matter, you can speed up things\n * even more by allowing elements whose processing goes faster to overtake the slower ones.\n *\n * ```\n * \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n * \u2502input iterator\u2502\n * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *        \u2502\n *        \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *        \u2502             \u2502\n *   \u250C\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2510   \u250C\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2510\n *   \u2502transform\u2502   \u2502transform\u2502\n *   \u2502 lane 1  \u2502   \u2502 lane 2  \u2502   ...\n *   \u2514\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2518\n *        \u2502             \u2502\n *        \u2502             \u2502\n *        \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *        \u2502\n * \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n * \u2502output iterator\u2502\n * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n * ```\n *\n * The first argument specifies the maximum concurrency and whether the order must be respected.\n * All arguments after that are the transIterators that make up the algorithm to be run in parallel.\n *\n * 'keepOrder: false' can be useful in cases where the elements can be processed independently.\n * For example:\n * if you would model a webserver as a transIterator that turns a stream of http requests\n * into a stream of http responses, their processing can be done independently, and it would\n * make sense to respond as quickly as possible, instead of waiting for the previous request to be\n * processed first.\n *\n * This should be an ideal combination with the runInWorker operator so we can easily distribute\n * the work over the wanted amount of worker threads.\n *\n * @example\n * ```typescript\n * // run google searches and transform the result with an online api to produce a map of results\n * // but run maximum 4 api requests in parallel to speed things up\n * await pipe(\n *        itr8FromArray([ 'Garfield', 'H\u00E4gar the Horrible', 'Droopy', 'Calvin and Hobbes', 'Fritz the Cat', 'Popeye' ])\n *        parallel(\n *          { concurrency: 4 },\n *          map(async (term) => ...), // a call to google search to get the search results in html\n *          map(async (html) => ...), // another api call that turns the html into structered json { name: 'Garfield', searchResults: [ ... ] }\n *        ),\n *        map(({name, searchResults}) => [name, searchResults]),\n *        itr8ToObject, // like Object.fromEntries but for both synchronous and asynchronous iterators\n *      )\n * // => {\n * //   'Garfield': [ ...urls ],\n * //   'H\u00E4gar the Horrible': [ ...urls ],\n * //   'Droopy': [ ...urls ],\n * //   'Calvin and Hobbes': [ ...urls ],\n * //   'Fritz the Cat': [ ...urls ],\n * //   'Popeye': [ ...urls ],\n * // }\n * ```\n *\n * @param options\n * @param transIt\n * @param {...(it:Iterator<unknown> | AsyncIterator<unknown>)=>Iterator<unknown> | AsyncIterator<unknown>} moreTransIts\n * @returns\n *\n * @category operators/async\n */\nfunction parallel<A, B>(\n  options: { concurrency: number; keepOrder?: boolean },\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n): TTransIteratorSyncOrAsync<A, B>;\nfunction parallel<A, B, C>(\n  options: { concurrency: number; keepOrder?: boolean },\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n): TTransIteratorSyncOrAsync<A, C>;\nfunction parallel<A, B, C, D>(\n  options: { concurrency: number; keepOrder?: boolean },\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n  transIt3: TTransIteratorSyncOrAsync<C, D>,\n): TTransIteratorSyncOrAsync<A, D>;\nfunction parallel<A, B, C, D, E>(\n  options: { concurrency: number; keepOrder?: boolean },\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n  transIt3: TTransIteratorSyncOrAsync<C, D>,\n  transIt4: TTransIteratorSyncOrAsync<D, E>,\n): TTransIteratorSyncOrAsync<A, E>;\nfunction parallel<A, B, C, D, E, F>(\n  options: { concurrency: number; keepOrder?: boolean },\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n  transIt3: TTransIteratorSyncOrAsync<C, D>,\n  transIt4: TTransIteratorSyncOrAsync<D, E>,\n  transIt5: TTransIteratorSyncOrAsync<E, F>,\n): TTransIteratorSyncOrAsync<A, F>;\n// function pipe<IN, A, B, C, D, E>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E): E;\n// function pipe<IN, A, B, C, D, E, F>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E, fn6: (x: E) => F): F;\n// function pipe<IN, A, B, C, D, E, F, G>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E, fn6: (x: E) => F, fn7: (x: F) => G): G;\n// function pipe<IN, A, B, C, D, E, F, G, H>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E, fn6: (x: E) => F, fn7: (x: F) => G, fn8: (x: G) => H): H;\n// function pipe<IN, A, B, C, D, E, F, G, H, I>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E, fn6: (x: E) => F, fn7: (x: F) => G, fn8: (x: G) => H, fn9: (x: H) => I): I;\n// function pipe<IN, A, B, C, D, E, F, G, H, I, J>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E, fn6: (x: E) => F, fn7: (x: F) => G, fn8: (x: G) => H, fn9: (x: H) => I, fn10: (x: I) => J): J;\n// function pipe<IN, A, B, C, D, E, F, G, H, I, J>(input: IN, fn1: (x: IN) => A, fn2: (x: A) => B, fn3: (x: B) => C, fn4: (x: C) => D, fn5: (x: D) => E, fn6: (x: E) => F, fn7: (x: F) => G, fn8: (x: G) => H, fn9: (x: H) => I, fn10: (x: I) => J, ...moreFns: Array<(x: unknown) => unknown>): unknown;\n// function parallel<IN, A>(\nfunction parallel(\n  options: { concurrency: number; keepOrder?: boolean },\n  transIt: TTransIteratorSyncOrAsync,\n  ...moreTransIts: Array<TTransIteratorSyncOrAsync>\n): TTransIteratorSyncOrAsync {\n  // combine all parameters into a single transIterator in order to apply it\n  const transItsCombined = moreTransIts.reduce(\n    (acc, cur) => (input) => cur(acc(input)),\n    transIt,\n  );\n  // = compose(transIt, ...moreTransIts)\n\n  if (options.keepOrder === undefined || options.keepOrder) {\n    return <T, U>(\n      inIt: Iterator<T> | AsyncIterator<T>,\n    ): AsyncIterableIterator<U> => {\n      type TItOfItsElement = {\n        callbackIt: TPushable & AsyncIterableIterator<boolean>;\n        subIt: TPushable & AsyncIterableIterator<T>;\n      };\n\n      async function* iteratorOfIterables() {\n        // create an iterator to push the results of each 'lane' to\n        const outIteratorOfIterators = itr8Pushable<TItOfItsElement>();\n\n        // first setup the (concurrent) forEach on the incoming iterator, so that things will be pushed to the pushable iterator\n        (async () => {\n          // const start = Date.now();\n          // const timePassed = () => Date.now() - start;\n          await pipe(\n            inIt,\n            forEach(\n              async (inElement) => {\n                // console.log(`${JSON.stringify(inElement)}: taking lane (${timePassed()} ms)`);\n                const itOfItsElement: TItOfItsElement = {\n                  callbackIt: itr8Pushable<boolean>(),\n                  subIt: itr8Pushable(),\n                };\n                outIteratorOfIterators.push(itOfItsElement);\n                // actively drain the subIterator to force parallel processing\n                // and push the results onto the subItPushable\n                const subIt = transItsCombined(itr8FromSingleValue(inElement));\n                // await forEach(itOfItsElement.subIt.push)(subIt);\n                await forEach((v) => {\n                  // console.log(`${JSON.stringify(inElement)}: Pushing ${JSON.stringify(v)} to outIterator (${timePassed()} ms)`);\n                  itOfItsElement.subIt.push(v);\n                })(subIt);\n                // console.log(`${JSON.stringify(inElement)}: Pushing DONE to outIterator (${timePassed()} ms)`);\n                itOfItsElement.subIt.done();\n                // now wait until we get a signal that this subIterator has been processed (pulled in)\n                // so this 'lane' can start processing a new record\n                await itr8ToArray(itOfItsElement.callbackIt);\n                // console.log(`${JSON.stringify(inElement)}: clearing lane because outIterator has processed all elemants... (${timePassed()} ms)`);\n              },\n              { concurrency: options.concurrency },\n            ),\n          );\n\n          // after the forEach, make sure we indicate that the iterator is done!\n          outIteratorOfIterators.done();\n        })();\n\n        // second we'll loop through the outIteratorOfIterators\n        for await (const subItElement of outIteratorOfIterators) {\n          yield* subItElement.subIt;\n          // send signal back to forEach that the processing has finished for this subIterator\n          subItElement.callbackIt.done();\n        }\n      }\n      return iteratorOfIterables() as AsyncIterableIterator<U>;\n    };\n  } else {\n    return <T, U>(\n      inIt: Iterator<T> | AsyncIterator<T>,\n    ): AsyncIterableIterator<U> => {\n      type TItElement =\n        | { callbackIt: TPushable & AsyncIterableIterator<boolean> }\n        | { value: T };\n\n      async function* iteratorOfValues() {\n        // create an iterator to push calculated values onto\n        const outIterator = itr8Pushable<TItElement>();\n\n        // first setup the (concurrent) forEach on the incoming iterator, so that things will be pushed to the pushable iterator\n        (async () => {\n          await pipe(\n            inIt,\n            forEach(\n              async (inElement) => {\n                // actively drain the subIterator to force parallel processing\n                // and push the results onto the pushable outIterator\n                const subIt = transItsCombined(itr8FromSingleValue(inElement));\n                await forEach((v) => outIterator.push({ value: v }))(subIt);\n                // await forEach((v) => {\n                //   console.log(`${JSON.stringify(inElement)}: Pushing ${JSON.stringify(v)} to outIterator`);\n                //   outIterator.push({ value: v });\n                // })(subIt);\n                const callbackIt = itr8Pushable<boolean>();\n                // console.log(`${JSON.stringify(inElement)}: Pushing DONE to outIterator`);\n                outIterator.push({ callbackIt });\n                // now wait until we get a signal that this subIterator has been processed (pulled in)\n                // so this 'lane' can start processing a new record\n                await itr8ToArray(callbackIt);\n                // console.log(`${JSON.stringify(inElement)}: clearing lane because outIterator has processed all elemants...`);\n              },\n              { concurrency: options.concurrency },\n            ),\n          );\n\n          // after the forEach, make sure we indicate that the iterator is done!\n          outIterator.done();\n        })();\n\n        // second we'll loop through the outIterator\n        for await (const subItElement of outIterator) {\n          if ((subItElement as any).callbackIt === undefined) {\n            yield (subItElement as { value: T }).value;\n          } else {\n            // send signal back to forEach that the processing has finished for this subIterator\n            (\n              subItElement as {\n                callbackIt: TPushable & AsyncIterableIterator<boolean>;\n              }\n            ).callbackIt.done();\n          }\n        }\n      }\n      return iteratorOfValues() as AsyncIterableIterator<U>;\n    };\n  }\n}\n\nexport { parallel };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Return true if every item returns true on the test function.\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4, 5, 6 ]),\n *      every((x) => x > 2), // => [ false ]\n *    );\n * ```\n *\n * The filter function can be asynchronous (in which case the resulting iterator will be\n * asynchronous regardless of the input iterator)!\n *\n * @category operators/boolean\n */\nconst every = <TIn>(filterFn: (TIn) => boolean | Promise<boolean>) =>\n  powerMap<TIn, boolean, { done: boolean }>(\n    (nextIn, state) => {\n      if (state.done) return { done: true };\n      if (nextIn.done)\n        return { done: false, value: true, state: { done: true } };\n\n      return thenable(filterFn(nextIn.value)).then((result) => {\n        if (result) return { done: false, state: { done: false } };\n        return { done: false, value: result, state: { done: true } };\n      }).src;\n    },\n    () => ({ done: false }),\n  );\n\nexport { every };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Return true if at least 1 item returns true on the test function.\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4, 5, 6 ]),\n *      some((x) => x > 2), // => [ true ]\n *    );\n * ```\n *\n * The filter function can be asynchronous (in which case the resulting iterator will be\n * asynchronous regardless of the input iterator)!\n *\n * @category operators/boolean\n */\nconst some = <TIn>(filterFn: (TIn) => boolean | Promise<boolean>) =>\n  powerMap<TIn, boolean, { done: boolean }>(\n    (nextIn, state) => {\n      if (state.done) return { done: true };\n      if (nextIn.done)\n        return { done: false, value: false, state: { done: true } };\n\n      return thenable(filterFn(nextIn.value)).then((result) => {\n        if (result)\n          return { done: false, value: result, state: { done: true } };\n        return { done: false, state: { done: false } };\n      }).src;\n    },\n    () => ({ done: false }),\n  );\n\nexport { some };\n", "import { isPromise } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\nimport { TNextFnResult } from \"../../types.js\";\n\n/**\n * Translate each element into something else by applying the supplied mapping function\n * to each element.\n *\n * The mapping function can be asynchronous (in which case the resulting iterator will be\n * asynchronous regardless of the input iterator)!\n *\n * @param fn\n *\n * @category operators/general\n */\nconst map = <TIn, TOut>(mapFn: (v: TIn) => TOut | Promise<TOut>) => {\n  const returnIteratorResultSync = (\n    value: TOut,\n  ): TNextFnResult<TOut, void> => ({\n    done: false,\n    value,\n  });\n  const returnIteratorResultAsync = async (\n    valuePromise: Promise<TOut>,\n  ): Promise<TNextFnResult<TOut, void>> => ({\n    done: false,\n    value: await valuePromise,\n  });\n  let returnIteratorResult = (\n    mapFnResult: TOut | Promise<TOut>,\n  ): TNextFnResult<TOut, void> | Promise<TNextFnResult<TOut, void>> => {\n    if (isPromise(mapFnResult)) {\n      returnIteratorResult = returnIteratorResultAsync;\n    } else {\n      returnIteratorResult = returnIteratorResultSync;\n    }\n    return returnIteratorResult(mapFnResult);\n  };\n  return powerMap<TIn, TOut, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) {\n        return { done: true };\n      } else {\n        return returnIteratorResult(mapFn(nextIn.value));\n        // return thenable(mapFn(nextIn.value)).then((value) => ({\n        //   done: false,\n        //   value,\n        // })).src; // return the 'raw' value or promise, not the 'wrapped' version\n\n        // const nextValOrPromise = mapFn(nextIn.value);\n        // if (isPromise(nextValOrPromise)) {\n        //   return (async () => {\n        //     return {\n        //       done: false,\n        //       value: await nextValOrPromise,\n        //     }\n        //   })();\n        // } else {\n        //   return {\n        //     done: false,\n        //     value: nextValOrPromise,\n        //   }\n        // }\n      }\n    },\n    () => undefined,\n  );\n};\n\nexport { map };\n", "import { pipe } from \"../../util/index.js\";\nimport {\n  itr8FromIterable,\n  itr8ToMultiIterable,\n} from \"../../interface/index.js\";\nimport { TTransIteratorSyncOrAsync } from \"../../types.js\";\nimport { map } from \"./map.js\";\nimport { isPromise } from \"../../util/index.js\";\n\n/**\n * This operator should make it easy to perform multiple calculations on the same input\n * operator, and returning a tuple containing the multiple outputs.\n * This can be useful for example if you need to add a timestamp, get the running average,\n * the running max, and the running total of the same data, and you only want to iterate\n * over the data once.\n *\n * ```\n * \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n * \u2502input iterator\u2502\n * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *        \u2502\n *        \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *        \u2502             \u2502             \u2502             \u2502\n *   \u250C\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2510   \u250C\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2510                 \u250C\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2510\n *   \u2502 transIt \u2502   \u2502 transIt \u2502                 \u2502 transIt \u2502\n *   \u2502    1    \u2502   \u2502    2    \u2502       ...       \u2502    n    \u2502\n *   \u2514\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2518\n *        \u2502             \u2502             |             \u2502\n *        \u2502             \u2502             |             \u2502\n *        \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *        \u2502\n *  <COMBINE INTO TUPLES of size n>\n *        \u2502\n * \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n * \u2502output iterator\u2502\n * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n * ```\n *\n * All arguments are the transIterators that need to be run (use compose(for more complex operations)).\n *\n * @example\n * ```typescript\n * await pipe(\n *        itr8FromArray([ 1, 2, 3, 4 ])\n *        branchAndMerge(\n *          identity(), // keep the original values as the first element of the tuple\n *          runningAverage(),\n *          runningTotal(),\n *        ),\n *        map(([value, avg, total]) => ({ value, avg, total })),\n *        itr8ToArray,\n *      )\n * // => [\n * //   { value: 1, avg: 1,   total:  1 },\n * //   { value: 2, avg: 1.5, total:  3 },\n * //   { value: 3, avg: 2,   total:  6 },\n * //   { value: 4, avg: 2.5, total: 10 },\n * // ]\n * ```\n *\n * @param options\n * @param transIt\n * @param {...(it:Iterator<unknown> | AsyncIterator<unknown>)=>Iterator<unknown> | AsyncIterator<unknown>} moreTransIts\n * @returns\n *\n * @category operators/general\n */\nfunction branchAndMerge<A, B>(\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n): TTransIteratorSyncOrAsync<A, [A, B]>;\nfunction branchAndMerge<A, B, C>(\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n): TTransIteratorSyncOrAsync<A, [A, B, C]>;\nfunction branchAndMerge<A, B, C, D>(\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n  transIt3: TTransIteratorSyncOrAsync<C, D>,\n): TTransIteratorSyncOrAsync<A, [A, B, C, D]>;\nfunction branchAndMerge<A, B, C, D, E>(\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n  transIt3: TTransIteratorSyncOrAsync<C, D>,\n  transIt4: TTransIteratorSyncOrAsync<D, E>,\n): TTransIteratorSyncOrAsync<A, [A, B, C, D, E]>;\nfunction branchAndMerge<A, B, C, D, E, F>(\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n  transIt3: TTransIteratorSyncOrAsync<C, D>,\n  transIt4: TTransIteratorSyncOrAsync<D, E>,\n  transIt5: TTransIteratorSyncOrAsync<E, F>,\n): TTransIteratorSyncOrAsync<A, [A, B, C, D, E, F]>;\nfunction branchAndMerge<A, B, C, D, E, F, G>(\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n  transIt3: TTransIteratorSyncOrAsync<C, D>,\n  transIt4: TTransIteratorSyncOrAsync<D, E>,\n  transIt5: TTransIteratorSyncOrAsync<E, F>,\n  transIt6: TTransIteratorSyncOrAsync<F, G>,\n): TTransIteratorSyncOrAsync<A, [A, B, C, D, E, F, G]>;\nfunction branchAndMerge<A, B, C, D, E, F, G, H>(\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n  transIt3: TTransIteratorSyncOrAsync<C, D>,\n  transIt4: TTransIteratorSyncOrAsync<D, E>,\n  transIt5: TTransIteratorSyncOrAsync<E, F>,\n  transIt6: TTransIteratorSyncOrAsync<F, G>,\n  transIt7: TTransIteratorSyncOrAsync<G, H>,\n): TTransIteratorSyncOrAsync<A, [A, B, C, D, E, F, G, H]>;\nfunction branchAndMerge<A, B, C, D, E, F, G, H, I>(\n  transIt1: TTransIteratorSyncOrAsync<A, B>,\n  transIt2: TTransIteratorSyncOrAsync<B, C>,\n  transIt3: TTransIteratorSyncOrAsync<C, D>,\n  transIt4: TTransIteratorSyncOrAsync<D, E>,\n  transIt5: TTransIteratorSyncOrAsync<E, F>,\n  transIt6: TTransIteratorSyncOrAsync<F, G>,\n  transIt7: TTransIteratorSyncOrAsync<G, H>,\n  transIt8: TTransIteratorSyncOrAsync<H, I>,\n): TTransIteratorSyncOrAsync<A, [A, B, C, D, E, F, G, H, I]>;\nfunction branchAndMerge<A, B>(\n  transIt: TTransIteratorSyncOrAsync<A, B>,\n  ...moreTransIts: Array<TTransIteratorSyncOrAsync>\n): TTransIteratorSyncOrAsync {\n  return function (it) {\n    const multiIterable = itr8ToMultiIterable(it);\n    const itInput = itr8FromIterable(multiIterable);\n    // const transIts = [transIt, ...moreTransIts];\n    const moreTransItIterators = moreTransIts.map((transIt) =>\n      pipe(itr8FromIterable(multiIterable), transIt),\n    );\n\n    let isAsync: boolean;\n    const itOut = pipe(\n      itInput,\n      map((value) => {\n        const itrResultsPossiblePromises = moreTransItIterators.map(\n          (transItIterator) => transItIterator.next(),\n        );\n        if (isAsync === undefined) {\n          isAsync = itrResultsPossiblePromises.some((result) =>\n            isPromise(result),\n          );\n        }\n\n        if (isAsync === false) {\n          return [\n            value,\n            ...(\n              itrResultsPossiblePromises as Array<IteratorResult<unknown>>\n            ).map((result) => result.value),\n          ];\n        } else if (isAsync === true) {\n          let otherValues: Array<unknown> = [];\n          return (async () => {\n            for await (const result of itrResultsPossiblePromises) {\n              otherValues.push(result.value);\n            }\n            return [value, ...otherValues];\n          })();\n        }\n      }),\n    );\n    return itOut;\n  };\n}\n\nexport { branchAndMerge };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * Removes consecutive doubles.\n * If no argument is provided, standard !== will be used to compare both values.\n * If a mapping fn is provided, the result of the mapping fn will be compared using !==,\n * which means the mapping function should produce a 'simple' types like number or string.\n *\n * (The alternative option would have been to pass 2 arguments to the compare fn and if\n * it returns true, the elements would be considered equal)\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8.itr8FromArrayAsync([ 1, 2, 2, 2, 3, 4, 4, 3 ]),\n *      itr8.dedup(), // => [ 1, 2, 3, 4, 3 ]\n *    );\n * ```\n * @example\n * ```typescript\n *    pipe(\n *      itr8.itr8FromArrayAsync([ { id: 1 }, { id: 2 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 4 }, { id: 3 } ])\n *      itr8.dedup((a:{ id:number }) => id ) // => [ [ { id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 3 } ];\n *    );\n * ```\n *\n * @param mapFn\n *\n * @category operators/general\n */\nconst dedup = <TIn>(mapFn?: (v: TIn) => any) =>\n  powerMap<TIn, boolean, void | TIn>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n\n      // promise if mapFn is async!\n      const valueToCompare = mapFn ? mapFn(nextIn.value) : nextIn.value;\n      return thenable(valueToCompare).then((v) => {\n        return v !== state\n          ? { done: false, value: nextIn.value, state: v }\n          : { done: false, state: v };\n      }).src;\n    },\n    () => undefined,\n  );\n\nexport { dedup };\n", "import { itr8FromIterable } from \"../../interface/index.js\";\nimport { TTransIteratorSyncOrAsync } from \"../../types.js\";\nimport { isPromise } from \"../../util/index.js\";\n\n/**\n * This operator should make it easy to distribute different categories on the input iterator,\n * to multiple child iterators for further processing per category.\n * The child iterator depends on the 'category' that is determined by the first element\n * of the tuple.\n *\n * Imagine things like: I need to calculate the averages 'per year'.\n * That would mean, categorize per year, and then calculate the average\n * of the inner iterators by using a map after distribute.\n *\n * If you are not going to use all output iterators, make sure to filter out\n * the categories you don't need before using distribute, because otherwise an unused\n * buffer will be held needlessly in memory.\n *\n * The category is compared using simple equality checks, so strings and numbers are an easy fit.\n * If you need more complex categories (like an array), make sure to return the same instance\n * as the category. (Maybe we should create a 'categorize' or 'groupBy' operator that\n * can help with dealing with more complex categories?)\n *\n * Questions:\n *  - Imagine you use it to categorize http requests (for example by sender ip/port),\n *    how do we 'close' a channel after a while so we can avoid the memory to keep growing?\n *    I mean, after some time you'll assume that the same 'sender' has done, and the output terator's\n *    next() call should return { done: true }. Would that be a setting,\n *    like the (unfinished) 'abandoned timeout' in the 'multiIterable' operator?\n *  - It could make sense to create a version that can handle multiple categories per value.\n *    Like for instance: divisible by 2, divisible by 3, divisible by 5, etc.\n *    where some values can be in multiple categories.\n *    This could also be done by using a flatMap to categorize the values into multiple categories\n *    for each input, which keeps this operator simple.\n *\n * ```\n * \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n * \u2502input iterator with tuples of the form [ category, value ] |\n * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *        \u2502\n * \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n * \u2502 output iterator of iterators \u2502\n * \u2502 (1 next() for each category) \u2502\n * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *        \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ...\n *        \u2502                             \u2502\n *   \u250C\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250C\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *   \u2502 [ category 1, iterator ] \u2502  \u2502 [ category 2, iterator ] \u2502\n *   \u2514\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *        \u2502\n *        \u2502\n * \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n * \u2502 forEach([ cetegory, iterator ]) \u2502\n * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *        |\n *        \u21B3 pipe( iterator, )\n * ```\n *\n * @example\n * ```typescript\n *  // one value has one category\n *  pipe(\n *    itr8ange(1, 1000),\n *    map( (v) => [ v % 2 === 0 ? 'even' : 'odd', v ] as [string, number] ), // add the category to the value\n *    // adding the category first allows us to easily filter out categories we don't need\n *    distribute(),\n *    map(([category, iterator]) => ({\n *      category,\n *      values: pipe(\n *        iterator,\n *        take(2),\n *        itr8ToArray,\n *      ),\n *    })),\n *    itr8ToArray,\n *  )\n * // => [\n * //   { category: 'odd', values: [ 1, 3 ] },\n * //   { category: 'even', values:  [ 2, 4 ] },\n * // ]\n *\n * // one value has multiple categories (divisible by 2, 3, 4)\n * pipe(\n *  itr8Range(1, 1000),\n *  flatMap(function* (v) {\n *    if (v % 2 === 0) yield ['divisable by 2', v]; // 2, 4, 6, 8, 10, ...\n *    if (v % 3 === 0) yield ['divisible by 3', v]; //  3,   6,   9, 12, 15, ...\n *    if (v % 4 === 0) yield ['divisible by 4', v]; //    4,    8,   12,   16, ...\n *   }),\n *  distribute(),\n *  map(([category, iterator]) => ({\n *    category,\n *    values: itr8ToArray(iterator),\n *  }),\n * );\n * ```\n *\n * @category operators/general\n */\nfunction distribute<T, C = unknown>(): TTransIteratorSyncOrAsync<\n  [C, T],\n  [C, IterableIterator<T> | AsyncIterableIterator<T>]\n> {\n  const bufferMap = new Map<C, Array<T>>();\n  // we need an ordered list in order to respond to next calls on the outer iterator\n  const categoriesArray: Array<C> = [];\n  let categoriesIndex = -1;\n  let distributionDone = false;\n\n  const addToCategory = (category: C, value: T) => {\n    if (bufferMap.has(category)) {\n      bufferMap.get(category)!.push(value);\n    } else {\n      bufferMap.set(category, [value]);\n      categoriesArray.push(category);\n    }\n  };\n\n  /**\n   * It will return the first value from the buffer of the given category,\n   * and update the buffer at the same time.\n   *\n   * @param category\n   * @returns the value from the buffer, or Symbol['categoryEmpty']\n   */\n  const getFromCategory = (category: C) => {\n    if (bufferMap.has(category)) {\n      const buffer = bufferMap.get(category);\n      if (buffer && buffer.length > 0) {\n        return buffer.shift();\n      }\n    }\n    return Symbol[\"categoryEmpty\"];\n  };\n\n  /**\n   * The function that will categorize the input iterator's values and update the internal state.\n   * @param itResult\n   */\n  const distributeIn = (itResult: IteratorResult<[C, T]>) => {\n    if (itResult.done) {\n      distributionDone = true;\n    } else {\n      addToCategory(itResult.value[0], itResult.value[1]);\n    }\n  };\n\n  return (inputIterator: Iterator<[C, T]> | AsyncIterator<[C, T]>) => {\n    function* generateInnerIterableSync(category: C) {\n      if (!bufferMap.has(category)) {\n        throw new Error(`Category ${category} not found in bufferMap`);\n      }\n\n      let innerIterableDone = false;\n      while (!innerIterableDone) {\n        const valueToYieldMaybe = getFromCategory(category);\n        if (valueToYieldMaybe !== Symbol[\"categoryEmpty\"]) {\n          yield valueToYieldMaybe;\n        } else if (distributionDone) {\n          innerIterableDone = true;\n        } else {\n          distributeIn(inputIterator.next() as IteratorResult<[C, T]>);\n        }\n      }\n    }\n\n    /**\n     * This function is a generator that will categorize the input iterator's values\n     * and returns [category, iterator] tuples.\n     */\n    function* generateOuterIterableSync(\n      firstNext: IteratorResult<[C, T]>,\n    ): IterableIterator<[C, IterableIterator<T>]> {\n      for (\n        let nextIn = firstNext;\n        !nextIn.done;\n        nextIn = inputIterator.next() as IteratorResult<[C, T]>\n      ) {\n        distributeIn(nextIn);\n\n        while (categoriesIndex < categoriesArray.length - 1) {\n          categoriesIndex += 1;\n          const category = categoriesArray[categoriesIndex];\n          yield [\n            category,\n            itr8FromIterable(generateInnerIterableSync(category)),\n          ] as [C, IterableIterator<T>];\n        }\n      }\n      distributionDone = true;\n    }\n\n    async function* generateInnerIterableAsync(category: C) {\n      if (!bufferMap.has(category)) {\n        throw new Error(`Category ${category} not found in bufferMap`);\n      }\n\n      let innerIterableDone = false;\n      while (!innerIterableDone) {\n        const valueToYieldMaybe = getFromCategory(category);\n        if (valueToYieldMaybe !== Symbol[\"categoryEmpty\"]) {\n          yield valueToYieldMaybe;\n        } else if (distributionDone) {\n          innerIterableDone = true;\n        } else {\n          distributeIn((await inputIterator.next()) as IteratorResult<[C, T]>);\n        }\n      }\n    }\n\n    /**\n     * This function is a generator that will categorize the input iterator's values\n     * and returns [category, iterator] tuples.\n     */\n    async function* generateOuterIterableAsync(\n      firstNext: Promise<IteratorResult<[C, T]>>,\n    ): AsyncIterableIterator<[C, AsyncIterableIterator<T>]> {\n      for (\n        let nextIn = await firstNext;\n        !nextIn.done;\n        nextIn = await inputIterator.next()\n      ) {\n        distributeIn(nextIn);\n\n        while (categoriesIndex < categoriesArray.length - 1) {\n          categoriesIndex += 1;\n          const category = categoriesArray[categoriesIndex];\n          yield [\n            category,\n            itr8FromIterable(generateInnerIterableAsync(category)),\n          ] as [C, AsyncIterableIterator<T>];\n        }\n      }\n      distributionDone = true;\n    }\n\n    const firstNext = inputIterator.next();\n    return isPromise(firstNext)\n      ? generateOuterIterableAsync(firstNext)\n      : generateOuterIterableSync(firstNext);\n  };\n}\n\nexport { distribute };\n", "import { TNextFnResult } from \"../../types.js\";\nimport { isPromise } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * Only keep elements where the filter function returns true.\n *\n * The filter function can be asynchronous (in which case the resulting iterator will be\n * asynchronous regardless of the input iterator)!\n *\n * @category operators/general\n */\nconst filter = <TIn>(filterFn: (v: TIn) => boolean | Promise<boolean>) => {\n  // EXPERIMENTAL: create a self-replacing function (depending on sync or async)\n  let generateNextFnResultFromFilterFnResult = function (\n    firstFilterFnResult: boolean | Promise<boolean>,\n    nextIn,\n  ): TNextFnResult<TIn, void> | Promise<TNextFnResult<TIn, void>> {\n    const f = (filterFnResult, nextIn: IteratorResult<TIn, TIn>) => {\n      if (filterFnResult) {\n        return { done: false, value: nextIn.value } as const;\n      } else {\n        return { done: false } as const;\n      }\n    };\n\n    generateNextFnResultFromFilterFnResult = isPromise(firstFilterFnResult)\n      ? (resultPromise, nextIn) =>\n          (resultPromise as Promise<boolean>).then((result) =>\n            f(result, nextIn),\n          )\n      : f;\n    return generateNextFnResultFromFilterFnResult(firstFilterFnResult, nextIn);\n  };\n\n  return powerMap<TIn, TIn, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) return { done: true };\n\n      return generateNextFnResultFromFilterFnResult(\n        filterFn(nextIn.value),\n        nextIn,\n      );\n\n      // OLD: thenable is simple to use, but not performant\n      // return thenable(filterFn(nextIn.value)).then((result) => {\n      //   if (result) return { done: false, value: nextIn.value };\n      //   return { done: false };\n      // }).src;\n\n      // const result = filterFn(nextIn.value);\n      // if (isPromise(result)) {\n      //   return (async () => {\n      //     if (await result) return { done: false, value: nextIn.value };\n      //     return { done: false };\n      //   })();\n      // } else {\n      //   if (result) return { done: false, value: nextIn.value };\n      //   return { done: false };\n      // }\n    },\n    () => undefined,\n  );\n};\n\nexport { filter };\n", "import { TTransIteratorSyncOrAsync } from \"../../types.js\";\nimport { pipe, doAfter, isPromise } from \"../../util/index.js\";\n\nconst DONE_SYMBOL = Symbol.for(\"itr8.flatMap.done\");\n\n/**\n * flatMap is a essentially a combination of the map operator followed by flatten.\n * The mapping function can be any function that produces an iterable:\n *  * that means it could be an array\n *  * but it can also be a generator function that can yield 0, 1 or more values\n *  * and it could also be a ReadableStream\n *  * and it could be the result of another pipe chain of operators\n *\n * All elemants will be handled, and there is no state held between the values\n * of the input operator.\n *\n * @example\n * ```typescript\n *  // output an array with double the values of the input array\n *  pipe(\n *    itr8FromArray([1, 2, 3]),\n *    flatMap((n) => [n, n * 2]),\n *  );  // => 1, 2, 2, 4, 3, 6\n *\n *  // categorize by divisibility by 2, 3, 5, 7 by using a generator function\n *  pipe(\n *    itr8Range(1, 16),\n *    flatMap(function* (n) => {\n *      if (n % 2 === 0) yield [2, n];\n *      if (n % 3 === 0) yield [3, n];\n *      if (n % 5 === 0) yield [5, n];\n *      if (n % 7 === 0) yield [7, n];\n *    }),\n *  ); // => [2, 2], [3, 3], [2, 4], [5, 5], [2, 6], [3, 6], [2, 8], [7, 7], [2, 10], [5, 10], [2, 12], [3, 12], [2, 14], [7, 14], [3, 15], [5, 15], [2, 16]\n *\n *  // categorize by divisibility by 2, 3, 5, 7 by using another itr8 chain\n *  pipe(\n *    itr8Range(1, 16),\n *    flatMap((n) => pipe(\n *      itr8FromSingleValue(n),\n *      map((n) => {\n *        let result = [];\n *        if (n % 2 === 0) result.push([2, n]);\n *        if (n % 3 === 0) result.push([3, n]);\n *        if (n % 5 === 0) result.push([5, n]);\n *        if (n % 7 === 0) result.push([7, n]);\n *      }),\n *    ),\n *  ),\n * ```\n *\n * @param mapFn\n * @param initialStateFactory\n * @returns\n */\nconst flatMap = function <TIn = unknown, TOut = unknown>(\n  mapFn: (nextIn: TIn) => Iterable<TOut> | AsyncIterable<TOut>,\n): TTransIteratorSyncOrAsync<TIn, TOut> {\n  type TOperatorState = {\n    currentOutputIterator: Iterator<TOut> | AsyncIterator<TOut> | undefined;\n    /** Means that we are done entirely (inputIterator is done) */\n    done: boolean;\n  };\n\n  const operatorFunction = (itIn: Iterator<TIn> | AsyncIterator<TIn>) => {\n    const operatorState: TOperatorState = {\n      currentOutputIterator: undefined,\n      // isLastOutputIterator: false,\n      done: false,\n    };\n    let inputIteratorIsAsync: boolean | undefined = undefined;\n    let iterableIsAsync: boolean | undefined = undefined;\n\n    /**\n     * This very first scroll through the loop should give us all the info we need\n     * in order to establish whether the iterator will be synchronous or asynchronous.\n     *\n     * After this first call, we can then overwrite the next function with either a sync\n     * or an async version.\n     * @returns\n     */\n    const generateFirstReturnValIfPossible = ():\n      | IteratorResult<TOut>\n      | Promise<IteratorResult<TOut>>\n      | null\n      | Promise<null> => {\n      return pipe(\n        itIn.next(),\n        (firstNextIn) => {\n          inputIteratorIsAsync = isPromise(firstNextIn);\n          return firstNextIn;\n        },\n        doAfter((firstNextIn) => {\n          if (firstNextIn.done) {\n            operatorState.done = true;\n            return null;\n          } else {\n            return mapFn(firstNextIn.value);\n          }\n        }),\n        doAfter((firstIterable) => {\n          if (firstIterable === null) {\n            operatorState.currentOutputIterator = undefined;\n            return null;\n          }\n          const firstIterator = firstIterable[Symbol.iterator]\n            ? firstIterable[Symbol.iterator]()\n            : firstIterable[Symbol.asyncIterator]();\n          operatorState.currentOutputIterator = firstIterator;\n          const firstNext = firstIterator.next();\n          iterableIsAsync = isPromise(firstNext);\n          return firstNext;\n        }),\n        doAfter((firstGeneratorNext) => {\n          returnedIterator.next =\n            inputIteratorIsAsync || iterableIsAsync\n              ? generateNextReturnValAsync\n              : generateNextReturnValSync;\n          if (operatorState.done) {\n            operatorState.currentOutputIterator = undefined;\n            return { done: true };\n          } else {\n            return firstGeneratorNext.done\n              ? returnedIterator.next()\n              : firstGeneratorNext;\n          }\n        }),\n      ) as\n        | IteratorResult<TOut>\n        | null\n        | Promise<IteratorResult<TOut>>\n        | Promise<null>;\n    };\n\n    const generateNextReturnValSync = (): IteratorResult<TOut> => {\n      while (true) {\n        if (operatorState.currentOutputIterator) {\n          // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n          const possibleNext = (\n            operatorState.currentOutputIterator as Iterator<TOut>\n          ).next() as IteratorResult<TOut>;\n\n          if (possibleNext.done) {\n            operatorState.currentOutputIterator = undefined;\n            // got to next loop iteration\n          } else {\n            return possibleNext;\n          }\n        } else if (operatorState.done) {\n          return { done: true, value: undefined };\n        } else {\n          // no running iterator, so we need to call nextFn again\n          const nextIn = itIn.next() as IteratorResult<TIn>;\n          if (nextIn.done) {\n            operatorState.done = true;\n            return { done: true, value: undefined };\n          }\n          const iterable = mapFn(nextIn.value);\n          operatorState.currentOutputIterator = iterable[Symbol.iterator]\n            ? iterable[Symbol.iterator]()\n            : iterable[Symbol.asyncIterator]();\n          // got to next loop iteration\n        }\n      }\n    };\n\n    const generateNextReturnValAsync = async (): Promise<\n      IteratorResult<TOut>\n    > => {\n      while (true) {\n        if (operatorState.currentOutputIterator) {\n          // if an iterator of a previous nextFn call is not entirely sent yet, get the next element\n          const nextFromIterable = operatorState.currentOutputIterator.next();\n          const possibleNext = (\n            iterableIsAsync ? await nextFromIterable : nextFromIterable\n          ) as IteratorResult<TOut>;\n\n          if (possibleNext.done) {\n            operatorState.currentOutputIterator = undefined;\n            // got to next loop iteration\n          } else {\n            return possibleNext;\n          }\n        } else if (operatorState.done) {\n          return { done: true, value: undefined };\n        } else {\n          // no running iterator, so we need to call nextFn again\n          const nextIn = inputIteratorIsAsync\n            ? await itIn.next()\n            : (itIn.next() as IteratorResult<TIn>);\n          if (nextIn.done) {\n            operatorState.done = true;\n            return { done: true, value: undefined };\n          }\n          const iterable = mapFn(nextIn.value);\n          operatorState.currentOutputIterator = iterable[Symbol.iterator]\n            ? iterable[Symbol.iterator]()\n            : iterable[Symbol.asyncIterator]();\n          // got to next loop iteration\n        }\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Here is the returned IterableIterator\n    ////////////////////////////////////////////////////////////////////////////////\n    const returnedIterator = {\n      // return the current (async?) iterator to make it an iterable iterator (so we can use for ... of)\n      // since we can only know whether the output will be sync or async after the first next call,\n      // we'll expose both iterator and asynciterator functions...\n      [Symbol.iterator]: () => returnedIterator,\n      [Symbol.asyncIterator]: () => returnedIterator,\n      // pipe: (op:TTransIteratorSyncOrAsync) => op(retVal as Iterator<TOut>),\n      next: () => {\n        return pipe(\n          generateFirstReturnValIfPossible(),\n          doAfter((n) => (n !== null ? n : returnedIterator.next())),\n        );\n      },\n      // when the iterator is 'abandoned' (the user indicates no more next() calls will follow)\n      // we can do cleanup, but we also pass the message to our incoming iterator!\n      return: (value?: any) => {\n        itIn.return?.();\n        return inputIteratorIsAsync || iterableIsAsync\n          ? Promise.resolve({ done: true, value })\n          : { done: true, value };\n      },\n      // when the iterator get a throw() call\n      // (the user indicates no more next() calls will follow because of an error)\n      // we can do cleanup, but we also pass the message to our incoming iterator!\n      throw: (err?: any) => {\n        itIn.throw?.(err);\n        return inputIteratorIsAsync || iterableIsAsync\n          ? Promise.resolve({ done: true, value: undefined })\n          : { done: true, value: undefined };\n      },\n    };\n\n    return returnedIterator as\n      | IterableIterator<TOut>\n      | AsyncIterableIterator<TOut>;\n  };\n\n  const transIt = (\n    itIn: Iterator<TIn> | AsyncIterator<TIn>,\n  ): IterableIterator<TOut> | AsyncIterableIterator<TOut> => {\n    try {\n      return operatorFunction(itIn);\n    } catch (err) {\n      itIn.throw?.();\n      throw err;\n    }\n  };\n\n  return transIt;\n};\n\nexport { flatMap };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * The incoming elements are arrays, and send out each element of the array 1 by one.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ [1, 2], [3, 4], [5, 6] ]),\n *      flatten(), // => [ 1, 2, 3, 4, 5, 6 ]\n *    );\n * ```\n *\n * @category operators/general\n */\nconst flatten = <TIn>() =>\n  powerMap<Iterable<TIn>, TIn, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) return { done: true };\n      return { done: false, iterable: nextIn.value };\n    },\n    () => undefined,\n  );\nexport { flatten };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Group the incoming elements so the output iterator will return arrays/tuples of a certain size.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4, 5, 6 ]),\n *      groupPer(2), // => [ [1, 2], [3, 4], [5, 6] ]\n *    );\n * ```\n *\n * @category operators/general\n */\nconst groupPer = <TIn>(groupSize: number) =>\n  powerMap<TIn, Array<TIn>, { done: boolean; buffer: Array<TIn> }>(\n    (nextIn, state) => {\n      if (state.done || (nextIn.done && state.buffer.length === 0)) {\n        return { done: true };\n      } else if (nextIn.done) {\n        return {\n          done: false,\n          value: state.buffer,\n          state: { done: true, buffer: [] },\n        };\n      } else if (state.buffer.length + 1 === groupSize) {\n        return {\n          done: false,\n          value: [...state.buffer, nextIn.value],\n          state: { done: false, buffer: [] },\n        };\n      }\n      return {\n        done: false,\n        state: { ...state, buffer: [...state.buffer, nextIn.value] },\n      };\n    },\n    () => ({ done: false, buffer: [] }),\n  );\n\nexport { groupPer };\n", "import { TTransIteratorSyncOrAsync } from \"../../types.js\";\n\n/**\n * This operator returns the same iterator, but makes sure it\n * will be an (Async)IterableIterator.\n *\n * @example\n * ```typescript\n * const iterableIterator = await pipe(\n *        someBareIterator,\n *        identity(),\n *      )\n * ```\n *\n * @returns the same (Async)Iterator but guaranteed to be an (Async)IterableIterator\n *\n * @category operators/async\n */\nfunction identity<T>(): TTransIteratorSyncOrAsync<T> {\n  return function <T>(\n    it: Iterator<T> | AsyncIterator<T>,\n  ): IterableIterator<T> | AsyncIterableIterator<T> {\n    if (it[Symbol.asyncIterator]) {\n      return it as AsyncIterableIterator<T>;\n    } else if (it[Symbol.iterator]) {\n      return it as IterableIterator<T>;\n    } else {\n      const itOut: IterableIterator<T> = {\n        next: it.next as () => IteratorResult<T>,\n        [Symbol.iterator]: () => itOut,\n      };\n      return itOut;\n    }\n  };\n}\n\nexport { identity };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Intersperse the the argument bewteen each element of the iterator.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 'hello', 'world', 'and', 'goodbye' ]),\n *      intersperse('|'), // => [ [ 'hello', '|', 'world', '|', 'and', '|', 'goodbye' ] ]\n *    );\n * ```\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4 ]),\n *      intersperse(true), // => [ 1, true, 2, true, 3, true, 4 ]\n *    );\n * ```\n *\n * @category operators/general\n */\nconst intersperse = (intersperseThing: unknown) =>\n  powerMap<unknown, unknown, boolean>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        return { done: true };\n      } else if (state) {\n        return {\n          done: false,\n          iterable: [intersperseThing, nextIn.value],\n          state,\n        };\n      }\n      // first time, just return the first element\n      return { done: false, iterable: [nextIn.value], state: true };\n    },\n    () => false,\n  );\n\nexport { intersperse };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * To solve some problems you need to know what the next element(s) is (are) going\n * to be, or look back at the previous value(s).\n *\n * so instead of returning the simple value of the incoming iterator, an object will be returned\n * that looks like this:\n * ```typescript\n *  {\n *    value: 'the current value',\n *    next: [ 'next value', 'next + 1 value' ],\n *    previous: [ 'previous value', 'previous - 1 value' ],\n *  }\n * ```\n *\n * @example\n * ```typescript\n * // the output of: find src \\( -type d -printf \"%p/\\n\" , ! -type d -print \\)\n * const str = `src/\n * src/interface/\n * src/interface/itr8ToArray.ts\n * src/interface/itr8Pushable.ts\n * src/interface/index.ts\n * src/peer/\n * src/peer/observable.ts\n * src/peer/parseJson.ts\n * src/types.ts\n * src/index.ts\n * src/operators/\n * src/operators/numeric/\n * src/operators/numeric/max.ts\n * src/operators/numeric/min.ts\n * src/operators/numeric/average.ts\n * src/operators/numeric/total.ts\n * src/operators/strings/\n * src/operators/strings/lineByLine.ts\n * src/operators/strings/stringToChar.ts\n * src/operators/general/\n * src/operators/general/uniq.ts\n * src/operators/general/reduce.ts\n * src/operators/general/split.ts\n * src/operators/boolean/\n * src/operators/boolean/every.ts\n * src/operators/boolean/some.ts\n * src/operators/index.ts`;\n *\n * const printableTreeView = pipe(\n *   itr8FromString(str),\n *   lineByLine(),\n *   peek(),\n *   // parse the string into a data structure (peeking to next to fill the isLastInLevel & isVeryLast flags)\n *   map(({value, next, prev}) => {\n *     const valueSplit = value.split('/');\n *     const isDir = value.endsWith('/');\n *     const pathLength = valueSplit.length - (isDir ? 2 : 1);\n *     const nextIsDir = next[0]?.endsWith('/');\n *     const nextPathLength = next[0]?.split('/').length - (nextIsDir ? 2 : 1);\n *     const isLastInLevel = nextPathLength < pathLength;\n *     const isVeryLast = next.length === 0;\n *     return { isDir, name: valueSplit[pathLength], level: pathLength, isLastInLevel, isVeryLast };\n *   }),\n *   // turn the data structure into a new string\n *   map(({ isDir, name, level, isLastInLevel, isVeryLast }) => {\n *     const padding = pipe(\n *       itr8FromSingleValue(' \u2502 ')\n *       repeatEach(level - 1),\n *       itr8ToString,\n *     );\n *\n *     const line = !(isLastInLevel || isVeryLast)\n *                ? ' \u251C\u2500'\n *                : ' \u2514\u2500' // (!isVeryLast ? ' \u2514\u2500' : '\u2500\u2534\u2500')\n *     ;\n *\n *     const filename = `${isDir ? '\uD83D\uDCC1' : '\uD83D\uDCC4'} ${name}`;\n *\n *     return `${padding}${level > 0 ? line : ''}${filename}`;\n *   }),\n *   intersperse('\\n'),\n *   itr8ToString,\n * )\n * // =>\n * // \uD83D\uDCC1 src\n * //  \u251C\u2500\uD83D\uDCC1 interface\n * //  \u2502  \u251C\u2500\uD83D\uDCC4 itr8ToArray.ts\n * //  \u2502  \u251C\u2500\uD83D\uDCC4 itr8Pushable.ts\n * //  \u2502  \u2514\u2500\uD83D\uDCC4 index.ts\n * //  \u251C\u2500\uD83D\uDCC1 peer\n * //  \u2502  \u251C\u2500\uD83D\uDCC4 observable.ts\n * //  \u2502  \u2514\u2500\uD83D\uDCC4 parseJson.ts\n * //  \u251C\u2500\uD83D\uDCC4 types.ts\n * //  \u251C\u2500\uD83D\uDCC4 index.ts\n * //  \u251C\u2500\uD83D\uDCC1 operators\n * //  \u2502  \u251C\u2500\uD83D\uDCC1 numeric\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 max.ts\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 min.ts\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 average.ts\n * //  \u2502  \u2502  \u2514\u2500\uD83D\uDCC4 total.ts\n * //  \u2502  \u251C\u2500\uD83D\uDCC1 strings\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 lineByLine.ts\n * //  \u2502  \u2502  \u2514\u2500\uD83D\uDCC4 stringToChar.ts\n * //  \u2502  \u251C\u2500\uD83D\uDCC1 general\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 uniq.ts\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 reduce.ts\n * //  \u2502  \u2502  \u2514\u2500\uD83D\uDCC4 split.ts\n * //  \u2502  \u251C\u2500\uD83D\uDCC1 boolean\n * //  \u2502  \u2502  \u251C\u2500\uD83D\uDCC4 every.ts\n * //  \u2502  \u2502  \u2514\u2500\uD83D\uDCC4 some.ts\n * //  \u2502  \u2514\u2500\uD83D\uDCC4 index.ts\n * ```\n *\n * @category operators/general\n */\nconst peek = <TIn>(peekForward = 1, peekBackward = 1) =>\n  powerMap<\n    TIn,\n    { value: TIn; previous: TIn[]; next: TIn[] },\n    { previous: TIn[]; current: TIn; next: TIn[] }\n  >(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        // drain what's left of the next elements\n        if (state.next.length === 0 || peekForward === 0) {\n          return {\n            done: true,\n            state: {\n              current: Symbol[\"ITR8_NO_CURRENT\"],\n              next: [],\n              previous: state.previous,\n            },\n          };\n        } else {\n          const [firstOfNext, ...restOfNext] = state.next;\n\n          const newState = {\n            current: firstOfNext,\n            next: restOfNext || [],\n            previous: [state.current, ...state.previous].slice(\n              0,\n              peekBackward as number,\n            ),\n          };\n          return {\n            done: false,\n            value: {\n              value: newState.current,\n              next: newState.next,\n              previous: newState.previous,\n            },\n            state: newState,\n          };\n        }\n      } else {\n        // NOT nextIn.done\n        if (state.next.length < peekForward) {\n          const newState = {\n            current: state.current, // still Symbol['ITR8_NO_CURRENT'] until we have enough next values\n            next: [...state.next, nextIn.value].slice(0, peekForward as number),\n            previous: state.previous,\n          };\n          return { done: false, state: newState };\n        } else {\n          // the 'normal' case in the middle of a flow\n          const [firstOfNext, ...restOfNext] = state.next;\n          const current = peekForward === 0 ? nextIn.value : firstOfNext;\n          const newState = {\n            current,\n            next: [...(restOfNext || []), nextIn.value].slice(\n              0,\n              peekForward as number,\n            ),\n            previous: (state.current === Symbol[\"ITR8_NO_CURRENT\"]\n              ? state.previous\n              : [state.current, ...(state.previous || [])]\n            ).slice(0, peekBackward as number),\n          };\n          return {\n            done: false,\n            value: {\n              value: newState.current,\n              next: newState.next,\n              previous: newState.previous,\n            },\n            state: newState,\n          };\n        }\n      }\n    },\n    () => ({\n      // hasPrevious: false,\n      previous: [],\n      current: Symbol[\"ITR8_NO_CURRENT\"],\n      next: [],\n      // hasNext\n    }),\n  );\n// const peek = (amountNext: number, amountPrevious: number = 0) => {\n\n//   // return <T>(it: Iterator<T> | AsyncIterator<T>):Iterator<T> | AsyncIterator<T> => {\n//   //   let inputs:Array<Promise<IteratorResult<T>> | IteratorResult<T>> = [];\n//   //   let isAsyncInput:boolean;\n//   //   const addInputIfNeeded = async () => {\n//   //     if (inputs.length < amount) {\n//   //       if (isAsyncInput && inputs.length > 0) await inputs[0];\n//   //       const next = it.next();\n//   //       if (isPromise(next)) {\n//   //         // console.log('     add another (async) input, current nr of inputs = ', inputs.length, ' < ', amount);\n//   //         isAsyncInput = true;\n//   //         next.then((n) => {\n//   //           if (!n.done) {\n//   //             // console.log('  then: call addInputIfNeeded(), current nr of inputs = ', inputs.length, ' < ', amount);\n//   //             addInputIfNeeded();\n//   //           }\n//   //         });\n//   //       }\n//   //       inputs.push(next);\n//   //     }\n//   //   }\n\n//   //   const retVal = {\n//   //     [Symbol.asyncIterator]: () => retVal as AsyncIterableIterator<T>,\n//   //     [Symbol.iterator]: () => retVal as IterableIterator<T>,\n//   //     next: () => {\n//   //       // console.log('  next: call addInputIfNeeded(), current nr of inputs = ', inputs.length, ' < ', amount);\n//   //       addInputIfNeeded();\n//   //       if (inputs.length > 0) {\n//   //         const [firstInput, ...remainingInputs] = inputs;\n//   //         inputs = remainingInputs;\n//   //         // console.log('  next: call 2 to addInputIfNeeded(), current nr of inputs = ', inputs.length, ' < ', amount);\n//   //         addInputIfNeeded();\n//   //         // console.log('  next: return ', firstInput);\n//   //         return firstInput;\n//   //       }\n//   //       return isAsyncInput\n//   //         ? Promise.resolve({ done: true, value: undefined }) as Promise<IteratorResult<T>>\n//   //         : { done: true, value: undefined } as IteratorResult<T>;\n//   //     }\n//   //   };\n\n//   //   return retVal as any;\n//   // }\n// };\n\nexport { peek };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * The reduce() method executes a user-supplied \"reducer\" callback function on each element of\n * the iterator, in order, passing in the return value from the calculation on the preceding\n * element. The final result of running the reducer across all elements of the array is a\n * single value, so the ouput iterator will only produce 1 result before finishing.\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4 ]),\n *      reduce((acc, cur) => acc + cur, 0),\n *    );\n *    // => [ 10 ]\n * ```\n *\n * The reduce function can be an asynchronous function (in which case the resulting\n * iterator will be asynchronous regardless of the input iterator)!\n *\n * @param reducer\n * @param initialValue: value passed as 'accumulator' on the very first call to the reducer function\n *\n * @category operators/general\n */\nconst reduce = <TIn, TOut>(\n  reducer: (\n    accumulator: TOut,\n    currentValue: TIn,\n    presentIndex?: number,\n  ) => TOut | Promise<TOut>,\n  initialValue: TOut,\n) =>\n  powerMap<TIn, TOut, { index: number; accumulator: TOut; done: boolean }>(\n    (nextIn, state) => {\n      if (state.done) {\n        return { done: true };\n      }\n\n      const acc = state.accumulator;\n\n      if (nextIn.done) {\n        return { done: false, value: acc, state: { ...state, done: true } };\n      }\n\n      return thenable(reducer(acc, nextIn.value, state.index)).then(\n        (reduced) => ({\n          done: false,\n          state: {\n            ...state,\n            index: state.index + 1,\n            accumulator: reduced,\n          },\n        }),\n      ).src;\n\n      // const reduced = params.reducer(acc, nextIn.value, state.index);\n      // if (isPromise(reduced)) {\n      //   return (async () => ({\n      //     done: false,\n      //     state: {\n      //       ...state,\n      //       index: state.index + 1,\n      //       accumulator: await reduced,\n      //     }\n      //   }))();\n      // }\n\n      // // synchronous\n      // return {\n      //   done: false,\n      //   state: {\n      //     ...state,\n      //     index: state.index + 1,\n      //     accumulator: reduced,\n      //   }\n      // };\n    },\n    () => ({ index: 0, accumulator: initialValue, done: false }),\n  );\n\nexport { reduce };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Repeat the entire iterator the given amount.\n * If the amount is zero (or negative), you'll end up with an empty iterator.\n *\n * BEWARE: In order to be able to repeat everything, the entire collection must be kept in memory\n * (as opposed to repeatEach where only a single element needs to be stored).\n *\n * @example\n * ```typescript\n * pipe(\n *     itr8FromArray([ 'hello', 'world' ]),\n *     repeat(2)\n *   ) // => [ 'hello', 'world', 'hello', 'world' ]\n * ```\n * @example\n * ```typescript\n * // creating an indentation function is easy (even if it's 0)\n * function getIndentation(indentationLevel, tabSize = 2) {\n *   const singleTab = pipe(\n *      itr8FromSingleValue(' '),\n *      repeat(tabSize),\n *      itr8ToSTring,\n *   );\n *   return pipe(\n *     itr8FromSingleValue(singleTab)\n *     repeat(indentationLevel),\n *     itr8ToSTring,\n *   );\n * }\n * getIndentation(3); // => '      ' (6 spaces)\n * ```\n *\n * @category operators/general\n */\nconst repeat = <TIn>(count = 2) =>\n  powerMap<TIn, TIn, { list: Array<TIn>; remaining: number }>(\n    (nextIn, { list, remaining }) => {\n      if (remaining <= 0) {\n        return { done: true };\n      }\n\n      if (nextIn.done) {\n        return {\n          done: false,\n          iterable: list,\n          state: { list, remaining: remaining - 1 },\n        };\n      }\n\n      return {\n        done: false,\n        value: nextIn.value,\n        state: { list: list.concat(nextIn.value), remaining },\n      };\n    },\n    () => ({ list: [], remaining: count - 1 }),\n  );\n\nexport { repeat };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Repeat each element of the iterator for the given amount.\n * If the amount is zero (or negative), you'll end up with an empty iterator.\n *\n * @example\n * ```typescript\n * pipe(\n *     itr8FromArray([ 'hello', 'world' ]),\n *     repeatEach(2)\n *   ) // => [ 'hello', 'hello', 'world', 'world' ]\n * ```\n * @example\n * ```typescript\n * // creating an indentation function is easy (even if it's 0)\n * function getIndentation(indentationLevel, tabSize = 2) {\n *   const singleTab = pipe(\n *      itr8FromSingleValue(' '),\n *      repeatEach(tabSize),\n *      itr8ToSTring,\n *   );\n *   return pipe(\n *     itr8FromSingleValue(singleTab)\n *     repeatEach(indentationLevel),\n *     itr8ToSTring,\n *   );\n * }\n * getIndentation(3); // => '      ' (6 spaces)\n * ```\n *\n * @category operators/general\n */\nconst repeatEach = <TIn>(count = 2) =>\n  powerMap<TIn, TIn, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n      return {\n        done: false,\n        iterable: (function* () {\n          for (let i = 0; i < count; i++) {\n            yield nextIn.value;\n          }\n        })(),\n      };\n    },\n    () => undefined,\n  );\n\nexport { repeatEach };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * The runnigReduce() method executes a user-supplied \"reducer\" callback function on each element of\n * the iterator, in order, passing in the return value from the calculation on the preceding\n * element. Eaxch next call produces the result of running the reducer across all elements so far.\n * (called scan in RxJS)\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4 ]),\n *      reduce((acc, cur) => acc + cur, 0),\n *    );\n *    // => [ 1, 3, 6, 10 ]\n * ```\n *\n * The reduce function can be an asynchronous function (in which case the resulting\n * iterator will be asynchronous regardless of the input iterator)!\n *\n * @param reducer\n * @param initialValue: value passed as 'accumulator' on the very first call to the reducer function\n *\n * @category operators/general\n */\nconst runningReduce = <TIn, TOut>(\n  reducer: (\n    accumulator: TOut,\n    currentValue: TIn,\n    presentIndex?: number,\n  ) => TOut | Promise<TOut>,\n  initialValue: TOut,\n) =>\n  powerMap<TIn, TOut, { index: number; accumulator: TOut; done?: true }>(\n    (nextIn, state) => {\n      if (state.done) {\n        return { done: true };\n      }\n\n      const acc = state.index === 0 ? initialValue : state.accumulator;\n\n      if (nextIn.done) {\n        return { done: true, value: acc, state };\n      }\n\n      return thenable(reducer(acc, nextIn.value, state.index)).then(\n        (reduced) => ({\n          done: false,\n          value: reduced,\n          state: {\n            ...state,\n            index: state.index + 1,\n            accumulator: reduced,\n          },\n        }),\n      ).src;\n    },\n    () => ({ index: 0, accumulator: initialValue }),\n  );\n\nexport { runningReduce };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Skip the 'amount' first elements and return all the others unchanged.\n *\n * @param amount\n *\n * @category operators/general\n */\nconst skip = <TIn>(params = 0) =>\n  powerMap<TIn, TIn, number>(\n    (nextIn, state) => {\n      if (nextIn.done) return { done: true };\n      if (state < params) return { done: false, state: state + 1 };\n      return { done: false, value: nextIn.value };\n    },\n    () => 0,\n  );\n\nexport { skip };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * Skip the first elements as long as the filter function returns true,\n * and return all the others unchanged.\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([1, 2, 3, 4, 1, 2, 6]),\n *      skipWhile(x => x < 4), // => [4, 1, 2, 6]\n *    );\n * ```\n *\n * @param whileFn a fuction that returns true as long as elements should be dropped\n *\n * @category operators/general\n */\nconst skipWhile = <TIn>(whileFn: (v: TIn) => boolean | Promise<boolean>) =>\n  powerMap<TIn, TIn, boolean>(\n    (nextIn, state) => {\n      if (nextIn.done) return { done: true };\n      if (state) {\n        return thenable(whileFn(nextIn.value)).then(\n          (keepSkipping: boolean, _isSync: boolean) =>\n            keepSkipping\n              ? { done: false, state }\n              : { done: false, value: nextIn.value, state: false },\n        ).src;\n        // return { done: false, state };\n      }\n      return { done: false, value: nextIn.value, state: false };\n    },\n    () => true,\n  );\n\nexport { skipWhile };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Sorts the elements (using the given sort function if provided).\n * Beware: all elements need to fit in memory before they can be sorted!\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, -2, 7, 4 ]),\n *      sort(), // => [ -2, 1, 4, 7 ]\n *    );\n * ```\n * @example\n * ```typescript\n *    pipe(\n *      itr8.itr8FromArrayAsync([ { v: 1 }, { v: -4 }, { v: 7 }, { v: 2 } ]),\n *      itr8.sort((a:{ v:number }, b:{ v:number }, => a.v - b.v))\n *    );\n * ```\n *\n * @param amount\n *\n * @category operators/general\n */\nconst sort = <TIn>(sortFn?: (a: TIn, b: TIn) => number) =>\n  powerMap<TIn, TIn, { done: boolean; list: TIn[] }>(\n    (nextIn: IteratorResult<any>, state) => {\n      if (state.done) {\n        return { done: true };\n      } else if (nextIn.done) {\n        // sort function modifes the state, so this is not 'pure'\n        return {\n          done: false,\n          iterable: state.list.sort(sortFn ? sortFn : undefined),\n          state: { ...state, done: true },\n        };\n      }\n      return {\n        done: false,\n        state: { ...state, list: [...state.list, nextIn.value] },\n      };\n      // bad (but more performant?): modifying state.list instead of returning a new state!\n      // state.list.push(nextIn.value);\n      // return { done: false, state: { ...state, list: state.list /* [...state.list, nextIn.value] */ } };\n    },\n    () => ({ done: false, list: [] }),\n  );\n\nexport { sort };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * like string.split => output arrays of elements and use the given parameter as a delimiter\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 'hello', '|', 'world' ]),\n *      split('|'), // => [ ['hello'], ['world'] ]\n *    );\n * ```\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, true, 2, 3, true, 4 ]),\n *      split(true), // => [ [1], [2,3], [4] ]\n *    );\n * ```\n *\n * @category operators/general\n */\nconst split = <TIn>(delimiter) =>\n  powerMap<TIn, TIn, TIn[] | null>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        if (state === null) {\n          return { done: true };\n        }\n        return { done: false, value: state, state: null };\n      } else if (nextIn.value === delimiter) {\n        return { done: false, value: state || [], state: [] };\n      }\n      return {\n        done: false,\n        state: [...(state === null ? [] : state), nextIn.value],\n      };\n    },\n    () => null,\n  );\n\nexport { split };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Only take 'amount' elements and then stop.\n *\n * (Beware: if the source is an Observable or a stream, it will not know that we stopped,\n * so the buffer will keep building up. The observable or stream should be closed by the user!)\n *\n * @param amount\n *\n * @category operators/general\n */\nconst take = <TIn>(count = Infinity) =>\n  powerMap<TIn, TIn, number>(\n    (nextIn, state) => {\n      if (nextIn.done) return { done: true };\n      if (state < count) {\n        const newState = state + 1;\n        return {\n          done: false,\n          value: nextIn.value,\n          state: newState,\n          isLast: newState == count,\n        };\n      }\n      return { done: true };\n    },\n    () => 0,\n  );\n\nexport { take };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Tap will run a function 'on the side' without while passing the iterator\n * unchanged to the next.\n *\n * @param fn\n *\n * @category operators/general\n */\nconst tap = <TIn>(tapFn: (value: TIn) => void) =>\n  powerMap<TIn, TIn, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) {\n        return { done: true };\n      } else {\n        try {\n          tapFn(nextIn.value);\n        } catch (e) {\n          console.warn(\"Tap function caused an exception\", e, e.stack);\n        }\n        return { done: false, value: nextIn.value };\n      }\n    },\n    () => undefined,\n  );\n\nexport { tap };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Only returns unique elements. It works with a simple compare, so ok for simple types like\n * numbers and strings, but for objects it will work on the reference. If you need something\n * more sophisticated, ```uniqBy(...)``` is propably what you need.\n *\n * Beware: all unique elements need to fit in memory to keep track of the ones that we already\n * have seen!\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, -2, 7, 4, -2, -2, 4, 1 ]),\n *      uniq(), // => [ 1, -2, 7, 4 ]\n *    );\n * ```\n *\n * @category operators/general\n */\nconst uniq = <TIn>() =>\n  powerMap<TIn, TIn, Set<TIn>>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        return { done: true };\n      } else if (state.has(nextIn.value)) {\n        return { done: false, state };\n      }\n      const newState = new Set(state);\n      newState.add(nextIn.value);\n      return { done: false, value: nextIn.value, state: newState };\n    },\n    () => new Set([]),\n  );\n\nexport { uniq };\n", "import { powerMap } from \"./powerMap.js\";\n\n/**\n * Only returns unique elements by comparing the result of the mapping function applied\n * to the element.\n * Beware: all mapped elements need to fit in memory to keep track of the ones that we already\n * have seen!\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8.itr8FromArrayAsync([ { id: 1 }, { id: 2 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 4 }, { id: 3 } ])\n *      itr8.uniqBy((a:{ id:number }) => id ) // => [ [ { id: 1 }, { id: 2 }, { id: 3 }, { id: 4 } ];\n *    );\n * ```\n *\n * @param mapFn\n *\n * @category operators/general\n */\nconst uniqBy = <TIn, TMapFn>(mapFn: (v: TIn) => TMapFn) =>\n  powerMap<TIn, TIn, Set<TMapFn>>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n      const hash = mapFn(nextIn.value);\n      if (state.has(hash)) {\n        return { done: false, state };\n      }\n      const newState = new Set(state);\n      newState.add(hash);\n      return { done: false, value: nextIn.value, state: newState };\n    },\n    () => new Set([]),\n  );\n\nexport { uniqBy };\n", "import { thenable } from \"../../util/index.js\";\nimport { powerMap } from \"./powerMap.js\";\n\n/**\n * The zip() operator outputs tuples containing 1 element from the first and\n * one element from the second iterator. The first iterator is leading, so when\n * the first iterator is done, the output iterator is done. When the second iterator\n * is 'shorter', the tuples will contain undefined as the second element.\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4 ]),\n *      zip(itr8FromArray([ 'a', 'b', 'c', 'd' ]), // => [ [1, 'a'], [2, 'b'], [3, 'c'], [4, 'd' ] ]\n *    );\n * ```\n *\n * @param secondIterator\n *\n * @category operators/general\n */\nconst zip = <TIn>(secondIterator: Iterator<any> | AsyncIterator<any>) =>\n  powerMap<TIn, TIn, void>(\n    (nextIn, _state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n\n      return thenable(secondIterator.next()).then((secondNext) => ({\n        done: false,\n        value: [nextIn.value, (secondNext as IteratorResult<any>).value],\n      })).src;\n\n      // const secondNext = secondIterator.next();\n      // if (isPromise(secondNext)) {\n      //   return (async () => ({\n      //     done: false,\n      //     value: [nextIn.value, (await secondNext as IteratorResult<any>).value],\n      //   }))();\n      // }\n\n      // // synchronous\n      // return {\n      //   done: false,\n      //   value: [nextIn.value, (secondNext as IteratorResult<any>).value],\n      // };\n    },\n    () => undefined,\n  );\n\nexport { zip };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Output the average.\n * @example\n * ```typescript\n *    pipe(\n *      itr8Range(1,100),\n *      average(),  // => [ 50 ]\n *    );\n * ```\n *\n * @param it\n * @param amount\n *\n * @category operators/numeric\n */\nconst average = () =>\n  powerMap<number, number, { done: boolean; count: number; sum: number }>(\n    (nextIn, state) => {\n      if (state.done) return { done: true };\n      if (nextIn.done)\n        return {\n          done: false,\n          value: state.sum / state.count,\n          state: { ...state, done: true },\n        };\n      const newCount = state.count + 1;\n      const newSum = state.sum + nextIn.value;\n      return { done: false, state: { ...state, count: newCount, sum: newSum } };\n    },\n    () => ({ done: false, count: 0, sum: 0 }),\n  );\n\nexport { average };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Output a single thing which is the highest of all values.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 7, 4 ]),\n *      total(), // => [ 7 ]\n *    );\n * ```\n *\n * @param amount\n *\n * @category operators/numeric\n */\nconst max = () =>\n  powerMap<number, number, { done: boolean; max: number }>(\n    (nextIn, state) => {\n      if (state.done) {\n        return { done: true };\n      } else if (nextIn.done) {\n        return {\n          done: false,\n          value: state.max,\n          state: { ...state, done: true },\n        };\n      }\n      return {\n        done: false,\n        state: { ...state, max: Math.max(state.max, nextIn.value) },\n      };\n    },\n    () => ({ done: false, max: -Infinity }),\n  );\n\nexport { max };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Output a single thing which is the lowest of all values.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, -2, 7, 4 ]),\n *      total(), // => [ -2 ]\n *    );\n * ```\n * @param amount\n *\n * @category operators/numeric\n */\nconst min = () =>\n  powerMap<number, number, { done: boolean; min: number }>(\n    (nextIn, state) => {\n      if (state.done) {\n        return { done: true };\n      } else if (nextIn.done) {\n        return {\n          done: false,\n          value: state.min,\n          state: { ...state, done: true },\n        };\n      }\n      return {\n        done: false,\n        state: { ...state, min: Math.min(state.min, nextIn.value) },\n      };\n    },\n    () => ({ done: false, min: Infinity }),\n  );\n\nexport { min };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Output the percentile(x)\n * It is simply using the nearest-rank method,\n * cfr. [Wikipedia](https://en.wikipedia.org/wiki/Percentile#Calculation_methods)\n * but it will only keep an ordered list of the n largest elements so far, which means that\n * computing the 90th percentile only needs to keep 10% of all the values seen in memory,\n * but the 50th percentile needs a buffer of 50% of all values.\n *\n * Various 'streaming' implementations exist, but they are more complex, so ... maybe later.\n *\n * @example\n * ```typescript\n *    pipe(\n *      itr8Range(1,100),\n *      percentile(95),  // => [ 95 ]\n *    );\n * ```\n *\n * @param amount\n *\n * @category operators/numeric\n */\nconst percentile = (percentage: number) =>\n  powerMap<\n    number,\n    number,\n    { done: boolean; count: number; topArray: number[] }\n  >(\n    (nextIn, state) => {\n      if (state.done) return { done: true };\n      if (nextIn.done)\n        return {\n          done: false,\n          value: state.topArray[0],\n          state: { ...state, done: true },\n        };\n      const newCount = state.count + 1;\n      const newTopArraySize =\n        Math.floor(((100 - percentage) / 100) * newCount) + 1;\n      const newTopArray = [...state.topArray, nextIn.value];\n      newTopArray.sort((a, b) => a - b);\n      while (newTopArraySize < newTopArray.length) {\n        newTopArray.shift();\n      }\n      // console.log('value', nextIn.value, 'percentage', percentage, 'count', state.count, 'newTopArraySize', newTopArraySize, 'state.topArray', state.topArray);\n      return {\n        done: false,\n        state: { ...state, count: newCount, topArray: newTopArray },\n      };\n    },\n    () => ({ done: false, count: 0, topArray: [] }),\n  );\n\nexport { percentile };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * On every item, output the average so far\n * @example\n * ```typescript\n *    pipe(\n *      itr8Range(1,10),\n *      runningAverage(),  // => [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5]\n *    );\n * ```\n *\n * @param it\n * @param amount\n *\n * @category operators/numeric\n */\nconst runningAverage = () =>\n  powerMap<number, number, { done: boolean; count: number; sum: number }>(\n    (nextIn, state) => {\n      if (nextIn.done) return { done: true };\n      const newCount = state.count + 1;\n      const newSum = state.sum + nextIn.value;\n      return {\n        done: false,\n        state: { ...state, count: newCount, sum: newSum },\n        value: newSum / newCount,\n      };\n    },\n    () => ({ done: false, count: 0, sum: 0 }),\n  );\n\nexport { runningAverage };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * On every item, output the percentile(x) so far\n * @example\n * ```typescript\n *    pipe(\n *      itr8Range(1,10),\n *      percentile(50),  // => [ 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 5 ]\n *    );\n * ```\n *\n * @param amount\n *\n * @category operators/numeric\n */\nconst runningPercentile = (percentage: number) =>\n  powerMap<number, number, { count: number; topArray: number[] }>(\n    (nextIn, state) => {\n      if (nextIn.done) return { done: true };\n      const newCount = state.count + 1;\n      const newTopArraySize =\n        Math.floor(((100 - percentage) / 100) * newCount) + 1;\n      const newTopArray = [...state.topArray, nextIn.value];\n      newTopArray.sort((a, b) => a - b);\n      while (newTopArraySize < newTopArray.length) {\n        newTopArray.shift();\n      }\n      // console.log('value', nextIn.value, 'percentage', percentage, 'count', state.count, 'newTopArraySize', newTopArraySize, 'state.topArray', state.topArray);\n      return {\n        done: false,\n        state: { ...state, count: newCount, topArray: newTopArray },\n        value: newTopArray[0],\n      };\n    },\n    () => ({ count: 0, topArray: [] }),\n  );\n\nexport { runningPercentile };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * On every item, output the total so far.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4 ]),\n *      runningTotal(),  // => [ 1, 3, 6, 10 ]\n *    );\n * ```\n *\n * @param amount\n *\n * @category operators/numeric\n */\nconst runningTotal = () =>\n  powerMap<number, number, number>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n      const newTotal = state + nextIn.value;\n      return { done: false, value: newTotal, state: newTotal };\n    },\n    () => 0,\n  );\n\nexport { runningTotal };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Output a single thing containing the sum of all values.\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 1, 2, 3, 4 ]),\n *      total(), // => [ 10 ]\n *    );\n * ```\n *\n * @param amount\n *\n * @category operators/numeric\n */\nconst total = () =>\n  powerMap<number, number, { done: boolean; total: number }>(\n    (nextIn, state) => {\n      if (state.done) {\n        return { done: true };\n      } else if (nextIn.done) {\n        return {\n          done: false,\n          value: state.total,\n          state: { ...state, done: true },\n        };\n      }\n      return {\n        done: false,\n        state: { ...state, total: state.total + nextIn.value },\n      };\n    },\n    () => ({ done: false, total: 0 }),\n  );\n\nexport { total };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * The input must be a stream of characters or strings,\n * and the output will be 1 string for each line.\n * \\n is used as the default line separator, but you can pass any string as a parameter\n * to be used as the line separator!\n *\n * @example\n * ```typescript\n *    // simplest case: an iterator of single characters\n *    pipe(\n *      itr8FromArray([ 'h', 'e', 'l', 'l', 'o', '\\n', 'w', 'o', 'r', 'l', 'd' ]),\n *      lineByLine(), // => [ 'hello', 'world' ]\n *    );\n *\n *    // second case: an iterator of string chunks\n *    pipe(\n *      itr8FromArray(['Hel', 'lo\\nWorld\\n\\nGo', 'od', 'by', 'e', '\\nSpace', '!']),\n *      lineByLine(), // => ['Hello', 'World', '', 'Goodbye', 'Space!'];\n *    );\n *\n *    // thrid case: the newline separator is something else than \\n\n *    pipe(\n *      itr8FromArray(['Hel', 'lo<br>>World<br><br>Go', 'od', 'by', 'e', '<br>Space', '!']),\n *      lineByLine(), // => ['Hello', 'World', '', 'Goodbye', 'Space!'];\n *    );\n * ```\n * @param {string} separator: the string that will be considered the newline sequence\n * @category operators/strings\n */\nconst lineByLine = (splitBy = \"\\n\") =>\n  powerMap<string, string, { done: boolean; buffer: string }>(\n    (nextIn, { done, buffer }) => {\n      if (nextIn.done) {\n        if (done) {\n          return { done: true, state: { done: true, buffer: \"\" } };\n        } else {\n          return {\n            done: false,\n            value: buffer,\n            state: { done: true, buffer: \"\" },\n          };\n        }\n      } else {\n        const lines = nextIn.value.split(splitBy as string);\n        if (lines.length === 1) {\n          return {\n            done: false,\n            state: { done: false, buffer: buffer + lines[0] },\n          };\n        } else if (lines.length === 2) {\n          return {\n            done: false,\n            value: buffer + lines[0],\n            state: { done: false, buffer: lines[1] },\n          };\n        } else {\n          return {\n            done: false,\n            iterable: [buffer + lines[0], ...lines.slice(1, -1)],\n            state: { done: false, buffer: lines[lines.length - 1] },\n          };\n        }\n      }\n    },\n    () => ({ done: false, buffer: \"\" }),\n  );\n\n// Original implementation by combining other operators\n// const lineByLine = () => compose(\n//   stringToChar(),\n//   split('\\n'),\n//   map(x => x.reduce((acc, cur) => acc + cur, '')),\n// );\n\nexport { lineByLine };\n", "import { itr8FromString } from \"../../interface/itr8FromString.js\";\nimport { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Takes all strings from the input and outputs them as single characters\n * @example\n * ```typescript\n *    pipe(\n *      itr8FromArray([ 'hello', 'world' ]),\n *      stringToChar(), // => [ 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd' ]\n *    );\n * ```\n *\n * @category operators/strings\n */\nconst stringToChar = () =>\n  powerMap<string, string>(\n    (nextIn, _state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n      return {\n        done: false,\n        iterable: itr8FromString(nextIn.value),\n      };\n    },\n    () => undefined,\n  );\n\nexport { stringToChar };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Mainly useful on async iterators (for example generated from a stream of events), but see below for other options.\n *\n * Wait for x milliseconds of 'no events' before firing one.\n * So an event will either not be handled (busy period),\n * or handled after the calm period (so with a delay of x milliseconds)\n *\n * The second parameter can be used if the timestamps can be calculated from the values on the input iterator\n * (by default Date.now() will be used).\n * This makes it possible to use this operator on synchronous iterators as well!\n *\n * @example\n * ```typescript\n * // imagine a stream of values fired at this pace onto an asyncIterator called itIn:\n * // 1, wait 10ms, 2, 3, wait 30ms, 4, wait 10ms, 5, wait 10ms, 6, 7, 8, 9, wait 40ms, 10\n * const result = await pipe(itIn, debounce(20), itr8ToArray);\n * // => [1, 4, 10]\n *\n * const valuesWithTimestamps = [\n *    { value: 1, timestamp: 0 },\n *    { value: 2, timestamp: 10 },\n *    { value: 3, timestamp: 10 },\n *    { value: 4, timestamp: 40 },\n *    { value: 5, timestamp: 50 },\n *    { value: 6, timestamp: 60 },\n *    { value: 7, timestamp: 60 },\n *    { value: 8, timestamp: 60 },\n *    { value: 9, timestamp: 60 },\n *    { value: 10, timestamp: 100 },\n * ];\n *\n * // or get the timestamp from the input values\n * const result = await pipe(\n *    itr8FromIterable(valuesWithTimestamps),\n *    debounce(20, ([_v, ts]) => ts),           // debounce with function that gets timestamp from input\n *    map(([v, _ts]) => v),                     // only keep values\n *    itr8ToArray,\n * );\n * // => [1, 4, 10]\n * ```\n *\n * @category operators/timeBased\n */\nconst debounce = <TIn>(\n  cooldownMilliseconds: number,\n  getTimestamp = (_value: TIn) => Date.now(),\n) =>\n  powerMap<TIn, TIn, number>(\n    (nextIn, state) => {\n      if (nextIn.done) return { done: true };\n      const newState = getTimestamp(nextIn.value);\n      const timePassed = newState - state;\n      if (timePassed > cooldownMilliseconds) {\n        return { done: false, value: nextIn.value, state: newState };\n      }\n      return { done: false, state: newState };\n    },\n    () => -Infinity,\n  );\n\nexport { debounce };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Simply delay every element by the given nr of milliseconds.\n * (Will always produce an async iterator!).\n *\n * @category operators/timeBased\n */\nconst delay = <TIn>(timeout: number) =>\n  powerMap<TIn, TIn, void>(\n    (nextIn, _state) => {\n      return new Promise<any>((resolve /*, reject*/) => {\n        setTimeout(() => resolve(nextIn), timeout);\n      });\n    },\n    () => undefined,\n  );\n\nexport { delay };\n", "import { powerMap } from \"../general/powerMap.js\";\n\n/**\n * Mainly useful on async iterators (for example generated from a stream of events), but see below for other options.\n *\n * Only throw events at most every x milliseconds.\n *\n * So when a few events happen quickly in succession, only the first one will be handled,\n * and the next ones will be ignored until enough time (x ms) has passed with\n * the previously handled event.\n *\n * The second parameter can be used if the timestamps can be calculated from the values on the input iterator\n * (by default Date.now() will be used).\n * This makes it possible to use this operator on synchronous iterators as well!\n *\n * @example\n * ```typescript\n * // imagine a stream of values fired at this pace onto an asyncIterator called itIn:\n * // 1, wait 5ms, 2, 3, wait 15ms, 4, wait 5ms, 5, wait 5ms, 6wait 10ms, 7wait 5ms, 8\n\n * const result = await pipe(itIn, throttle(15), itr8ToArray);\n * // => [1, 4, 7]\n *\n * const valuesWithTimestamps = [\n *    { value: 1, timestamp: 0 },\n *    { value: 2, timestamp: 5 },\n *    { value: 3, timestamp: 5 },\n *    { value: 4, timestamp: 20 },\n *    { value: 5, timestamp: 25 },\n *    { value: 6, timestamp: 30 },\n *    { value: 7, timestamp: 40 },\n *    { value: 8, timestamp: 45 },\n * ];\n *\n * // or get the timestamp from the input values\n * const result = await pipe(\n *    itr8FromIterable(valuesWithTimestamps),\n *    throttle(15, ([_v, ts]) => ts),           // throttle with function that gets timestamp from input\n *    map(([v, _ts]) => v),                     // only keep values\n *    itr8ToArray,\n * );\n * // => [1, 4, 7]\n * ```\n * @category operators/timeBased\n */\nconst throttle = <TIn>(\n  throttleMilliseconds: number,\n  getTimestamp = (_value: TIn) => Date.now(),\n) =>\n  powerMap<TIn, TIn, number>(\n    (nextIn, state) => {\n      if (nextIn.done) {\n        return { done: true };\n      }\n      const now = getTimestamp(nextIn.value);\n\n      if (now - state > throttleMilliseconds) {\n        return { done: false, value: nextIn.value, state: now };\n      }\n      return { done: false, state };\n    },\n    () => -Infinity,\n  );\n\nexport { throttle };\n"],
  "mappings": "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",
  "names": ["isPromise", "p", "AsyncFunction", "thenable", "x", "newX", "args", "value", "okHandler", "retVal", "thenableFactory", "y", "cachedThenable", "firstRun", "thenResult", "okHandlerResult", "doAfter", "f", "valueOrPromise", "doAfterFactory", "doAfterObj", "forLoop", "initialStateFactory", "testBeforeEach", "afterEach", "codeToExecute", "initialState", "isSyncInit", "testResult", "isSyncTest", "_", "isSyncBody", "firstStateAfterEach", "isSyncAfterBody", "state", "compose", "first", "params", "acc", "cur", "arg", "pipe", "input", "fn1", "functionsToApply", "forEach", "handler", "options", "it", "throwCount", "maxRunningHandlers", "runningHandlers", "waitForOpenSpot", "addToRunningHandlersList", "handlerPromise", "tryHandler", "v", "errorCatcher", "e", "handlerPossiblePromise", "isPromise", "nextPromiseOrValue", "nextPromise", "handleNext", "nextValue", "next", "handlerPossiblePromiseIn", "itr8FromArray", "a", "itr8FromArrayAsync", "a", "x", "itr8FromImpureFunction", "f", "retVal", "thenable", "value", "itr8FromIterable", "it", "itr8FromSingleValue", "v", "itr8FromSingleValueAsync", "v", "itr8FromString", "s", "itr8FromIterable", "itr8FromStringAsync", "s", "x", "itr8Pushable", "bufferSize", "buffer", "currentResolve", "currentDataPromise", "createNewCurrentDataPromise", "resolve", "retVal", "value", "itr8Interval", "intervalMilliseconds", "it", "itr8Pushable", "interval", "origDone", "itr8Range", "from", "to", "step", "stepValue", "upwards", "i", "itr8RangeAsync", "from", "to", "step", "stepValue", "upwards", "i", "itr8ToArray", "iterator", "n", "isPromise", "asyncResult", "result", "nSync", "itr8ToObject", "iterator", "n", "isPromise", "asyncResult", "k", "v", "result", "nSync", "itr8ToString", "iterator", "n", "isPromise", "asyncResult", "result", "nSync", "powerMapWithoutDoAfter", "nextFn", "initialStateFactory", "operatorFunction", "itIn", "pState", "operatorState", "generateFirstReturnValIfPossible", "pipe", "doAfter", "nextIn", "curNextFnResult", "returnedIterator", "generateDoneSync", "itr8FromIterable", "currentOutputIteratorNext", "generateNextFromOutputIteratorSync", "possibleNext", "generateNextReturnValSync", "outputIteratorIsAsync", "inputIteratorIsAsync", "nextFnIsAsync", "generateDoneAsync", "generateNextFromOutputIteratorAsync", "possibleNextValueOrPromise", "isPromise", "generateNextReturnValAsync", "nextInPromiseOrValue", "curNextFnResultPromiseOrValue", "n", "nResolved", "value", "err", "transIt", "input", "iterator", "iterable", "f", "forLoop", "thenable", "_forLoopResult", "newState", "retVal", "takeWhile", "filterFn", "powerMapWithoutDoAfter", "nextIn", "_state", "thenable", "filterFnResult", "itr8ToMultiIterable", "it", "subscriberMap", "buffer", "cleanBuffer", "minIndex", "pipe", "takeWhile", "i", "forEach", "iteratorGetter", "outIt", "index", "value", "error", "mostRecent", "initalValue", "it", "nextOut", "resolveNextOutRead", "handleInputPromise", "nextOutRead", "isPromise", "resolve", "reject", "retVal", "value", "err", "prefetch", "amount", "it", "inputs", "isAsyncInput", "addInputIfNeeded", "next", "isPromise", "n", "retVal", "firstInput", "remainingInputs", "value", "err", "parallel", "options", "transIt", "moreTransIts", "transItsCombined", "acc", "cur", "input", "inIt", "iteratorOfIterables", "outIteratorOfIterators", "itr8Pushable", "pipe", "forEach", "inElement", "itOfItsElement", "subIt", "itr8FromSingleValue", "v", "itr8ToArray", "subItElement", "iteratorOfValues", "outIterator", "callbackIt", "every", "filterFn", "powerMapWithoutDoAfter", "nextIn", "state", "thenable", "result", "some", "filterFn", "powerMapWithoutDoAfter", "nextIn", "state", "thenable", "result", "map", "mapFn", "returnIteratorResultSync", "value", "returnIteratorResultAsync", "valuePromise", "returnIteratorResult", "mapFnResult", "isPromise", "powerMapWithoutDoAfter", "nextIn", "_state", "branchAndMerge", "transIt", "moreTransIts", "it", "multiIterable", "itr8ToMultiIterable", "itInput", "itr8FromIterable", "moreTransItIterators", "pipe", "isAsync", "map", "value", "itrResultsPossiblePromises", "transItIterator", "result", "isPromise", "otherValues", "dedup", "mapFn", "powerMapWithoutDoAfter", "nextIn", "state", "valueToCompare", "thenable", "v", "distribute", "bufferMap", "categoriesArray", "categoriesIndex", "distributionDone", "addToCategory", "category", "value", "getFromCategory", "buffer", "distributeIn", "itResult", "inputIterator", "generateInnerIterableSync", "innerIterableDone", "valueToYieldMaybe", "generateOuterIterableSync", "firstNext", "nextIn", "itr8FromIterable", "generateInnerIterableAsync", "generateOuterIterableAsync", "isPromise", "filter", "filterFn", "generateNextFnResultFromFilterFnResult", "firstFilterFnResult", "nextIn", "f", "filterFnResult", "isPromise", "resultPromise", "result", "powerMapWithoutDoAfter", "_state", "DONE_SYMBOL", "flatMap", "mapFn", "operatorFunction", "itIn", "operatorState", "inputIteratorIsAsync", "iterableIsAsync", "generateFirstReturnValIfPossible", "pipe", "firstNextIn", "isPromise", "doAfter", "firstIterable", "firstIterator", "firstNext", "firstGeneratorNext", "returnedIterator", "generateNextReturnValAsync", "generateNextReturnValSync", "possibleNext", "nextIn", "iterable", "nextFromIterable", "n", "value", "err", "flatten", "powerMapWithoutDoAfter", "nextIn", "_state", "groupPer", "groupSize", "powerMapWithoutDoAfter", "nextIn", "state", "identity", "it", "itOut", "intersperse", "intersperseThing", "powerMapWithoutDoAfter", "nextIn", "state", "peek", "peekForward", "peekBackward", "powerMapWithoutDoAfter", "nextIn", "state", "firstOfNext", "restOfNext", "newState", "reduce", "reducer", "initialValue", "powerMapWithoutDoAfter", "nextIn", "state", "acc", "thenable", "reduced", "repeat", "count", "powerMapWithoutDoAfter", "nextIn", "list", "remaining", "repeatEach", "count", "powerMapWithoutDoAfter", "nextIn", "_state", "i", "runningReduce", "reducer", "initialValue", "powerMapWithoutDoAfter", "nextIn", "state", "acc", "thenable", "reduced", "skip", "params", "powerMapWithoutDoAfter", "nextIn", "state", "skipWhile", "whileFn", "powerMapWithoutDoAfter", "nextIn", "state", "thenable", "keepSkipping", "_isSync", "sort", "sortFn", "powerMapWithoutDoAfter", "nextIn", "state", "split", "delimiter", "powerMapWithoutDoAfter", "nextIn", "state", "take", "count", "powerMapWithoutDoAfter", "nextIn", "state", "newState", "tap", "tapFn", "powerMapWithoutDoAfter", "nextIn", "_state", "e", "uniq", "powerMapWithoutDoAfter", "nextIn", "state", "newState", "uniqBy", "mapFn", "powerMapWithoutDoAfter", "nextIn", "state", "hash", "newState", "zip", "secondIterator", "powerMapWithoutDoAfter", "nextIn", "_state", "thenable", "secondNext", "average", "powerMapWithoutDoAfter", "nextIn", "state", "newCount", "newSum", "max", "powerMapWithoutDoAfter", "nextIn", "state", "min", "powerMapWithoutDoAfter", "nextIn", "state", "percentile", "percentage", "powerMapWithoutDoAfter", "nextIn", "state", "newCount", "newTopArraySize", "newTopArray", "b", "runningAverage", "powerMapWithoutDoAfter", "nextIn", "state", "newCount", "newSum", "runningPercentile", "percentage", "powerMapWithoutDoAfter", "nextIn", "state", "newCount", "newTopArraySize", "newTopArray", "b", "runningTotal", "powerMapWithoutDoAfter", "nextIn", "state", "newTotal", "total", "powerMapWithoutDoAfter", "nextIn", "state", "lineByLine", "splitBy", "powerMapWithoutDoAfter", "nextIn", "done", "buffer", "lines", "stringToChar", "powerMapWithoutDoAfter", "nextIn", "_state", "itr8FromString", "debounce", "cooldownMilliseconds", "getTimestamp", "_value", "powerMapWithoutDoAfter", "nextIn", "state", "newState", "delay", "timeout", "powerMapWithoutDoAfter", "nextIn", "_state", "resolve", "throttle", "throttleMilliseconds", "getTimestamp", "_value", "powerMapWithoutDoAfter", "nextIn", "state", "now"]
}
